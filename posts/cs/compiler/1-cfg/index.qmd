---
title: "ì»´íŒŒì¼ëŸ¬ ë°±ì—”ë“œ ì‹œë¦¬ì¦ˆ 1ë¶€: ì œì–´ íë¦„ ê·¸ëž˜í”„(CFG) êµ¬ì¶•í•˜ê¸°"
description: "Bril IRì„ ìž…ë ¥ë°›ì•„ ì„ í˜•ì ì¸ ì½”ë“œë¥¼ ê¸°ë³¸ ë¸”ë¡(Basic Block)ìœ¼ë¡œ ë¶„í• í•˜ê³ , ì´ë¥¼ ì—°ê²°í•˜ì—¬ ëª¨ë“  ë¶„ì„ì˜ ê¸°ì´ˆê°€ ë˜ëŠ” ì œì–´ íë¦„ ê·¸ëž˜í”„(CFG)ë¥¼ êµ¬ì¶• ë° ì‹œê°í™”í•˜ëŠ” ê³¼ì •ì„ ë¶„ì„í•©ë‹ˆë‹¤."
date: "2025-11-02"
categories: [Compiler, Python, Bril, CFG]
image: "images/cover_cfg.png"
---

## 1. ê¸°ë³¸ ë¸”ë¡ (Basic Block) ìƒì„±: CFGì˜ ê¸°ì´ˆ

ì»´íŒŒì¼ëŸ¬ ë°±ì—”ë“œì—ì„œ ìˆ˜í–‰í•˜ëŠ” ëª¨ë“  ë¶„ì„ê³¼ ìµœì í™”ì˜ ì²«ê±¸ìŒì€ ì½”ë“œë¥¼ ì˜ë¯¸ ìžˆëŠ” ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ëŠ” ê²ƒìž…ë‹ˆë‹¤. ê·¸ ê°€ìž¥ ê¸°ë³¸ì ì¸ ë‹¨ìœ„ê°€ ë°”ë¡œ **ê¸°ë³¸ ë¸”ë¡(Basic Block)**ìž…ë‹ˆë‹¤.

> **ê¸°ë³¸ ë¸”ë¡(Basic Block)ì´ëž€?**
> "ë‹¨ì¼ ì§„ìž…ì (Single Entry), ë‹¨ì¼ ì§„ì¶œì (Single Exit)" ì›ì¹™ì„ ë”°ë¥´ëŠ” ëª…ë ¹ì–´ì˜ ì—°ì†ëœ ì‹œí€€ìŠ¤ìž…ë‹ˆë‹¤.
> 1.  **ë‹¨ì¼ ì§„ìž…ì :** ì½”ë“œì˜ ë§¨ ìœ„ì—ì„œë¶€í„° ì‹¤í–‰ë˜ê±°ë‚˜, ë‹¤ë¥¸ ë¸”ë¡ì—ì„œì˜ ì í”„(jump) ëŒ€ìƒì´ ë˜ëŠ” 'ë¦¬ë”(leader)' ëª…ë ¹ì–´ë¡œë§Œ ì§„ìž…ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ë¸”ë¡ ì¤‘ê°„ìœ¼ë¡œ ì í”„í•´ ë“¤ì–´ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
> 2.  **ë‹¨ì¼ ì§„ì¶œì :** ë¸”ë¡ì˜ ê°€ìž¥ ë§ˆì§€ë§‰ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ë©´, ë‹¤ìŒ ë¸”ë¡ìœ¼ë¡œ ì œì–´ê°€ ë„˜ì–´ê°‘ë‹ˆë‹¤. ë¸”ë¡ ì¤‘ê°„ì—ì„œ ë°–ìœ¼ë¡œ ì í”„í•´ ë‚˜ê°ˆ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.

`form_blocks.py`ì˜ ìœ ì¼í•œ ìž„ë¬´ëŠ” Brilì˜ ì„ í˜•ì ì¸ ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸ë¥¼ ìž…ë ¥ë°›ì•„, ì´ ê¸°ë³¸ ë¸”ë¡ ì›ì¹™ì— ë”°ë¼ ì—¬ëŸ¬ ê°œì˜ ë¸”ë¡ ë¦¬ìŠ¤íŠ¸ë¡œ ë¶„í• í•˜ëŠ” ê²ƒìž…ë‹ˆë‹¤.



### `form_blocks.py` í•µì‹¬ ë¡œì§ ë¶„ì„

ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” Bril ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸(`instrs`)ë¥¼ ì²˜ìŒë¶€í„° ëê¹Œì§€ ë‹¨ í•œ ë²ˆ **ì„ í˜• ìŠ¤ìº”(linear scan)**í•˜ë©´ì„œ ë¸”ë¡ì„ ë‚˜ëˆ•ë‹ˆë‹¤. ë¸”ë¡ì„ ë‚˜ëˆ„ëŠ” ê¸°ì¤€ì€ ë§¤ìš° ëª…í™•í•˜ë©°, ë‹¤ìŒ ë‘ ê°€ì§€ ê·œì¹™ì„ ë”°ë¦…ë‹ˆë‹¤.

1.  **Terminators (ì¢…ê²°ìž):** `br` (ë¶„ê¸°), `jmp` (ë¬´ì¡°ê±´ ì í”„), `ret` (ë°˜í™˜) ëª…ë ¹ì–´ëŠ” í˜„ìž¬ ë¸”ë¡ì˜ **ë§ˆì§€ë§‰** ëª…ë ¹ì–´ìž…ë‹ˆë‹¤. ì´ ëª…ë ¹ì–´ë¥¼ ë§Œë‚˜ë©´ í˜„ìž¬ ë¸”ë¡ì„ ë‹«ê³  ë‹¤ìŒ ëª…ë ¹ì–´ë¶€í„° ìƒˆ ë¸”ë¡ì„ ì‹œìž‘í•©ë‹ˆë‹¤.
2.  **Labels (ë ˆì´ë¸”):** ë ˆì´ë¸”ì€ í•­ìƒ ìƒˆë¡œìš´ ë¸”ë¡ì˜ **ì‹œìž‘**ìž…ë‹ˆë‹¤. ë”°ë¼ì„œ ë ˆì´ë¸”ì„ ë§Œë‚˜ë©´, (ë§Œì•½ ê·¸ì „ê¹Œì§€ì˜ ë¸”ë¡ì— ë‚´ìš©ì´ ìžˆì—ˆë‹¤ë©´) ê·¸ì „ê¹Œì§€ì˜ ë¸”ë¡ì„ ë‹«ê³ , ì´ ë ˆì´ë¸”ë¶€í„° ìƒˆë¡œìš´ ë¸”ë¡ì„ ì‹œìž‘í•©ë‹ˆë‹¤.

í•µì‹¬ ë¡œì§ì€ `form_blocks` í•¨ìˆ˜ì— ìžˆìœ¼ë©°, Pythonì˜ **ì œë„ˆë ˆì´í„°(generator)**ë¡œ êµ¬í˜„ë˜ì–´ ìžˆì–´ ë©”ëª¨ë¦¬ íš¨ìœ¨ì ìž…ë‹ˆë‹¤.

```python
# Instructions that terminate a basic block.
TERMINATORS = 'br', 'jmp', 'ret'


def form_blocks(instrs):
    """Given a list of Bril instructions, generate a sequence of
    instruction lists representing the basic blocks in the program.
    """

    # Start with an empty block.
    cur_block = []

    for instr in instrs:
        if 'op' in instr:  # It's an instruction.
            # Add the instruction to the currently-being-formed block.
            cur_block.append(instr)

            # If this is a terminator (branching instruction), it's the
            # last instruction in the block. Finish this block and
            # start a new one.
            if instr['op'] in TERMINATORS:
                yield cur_block
                cur_block = []

        else:  # It's a label.
            # End the block here (if it contains anything).
            if cur_block:
                yield cur_block

            # Start a new block with the label.
            cur_block = [instr]

    # Produce the final block, if any.
    if cur_block:
        yield cur_block
```
### ì½”ë“œ í•´ì„¤

* **`cur_block`**: í˜„ìž¬ êµ¬ì„± ì¤‘ì¸ ê¸°ë³¸ ë¸”ë¡(ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸)ì„ ìž„ì‹œë¡œ ì €ìž¥í•˜ëŠ” ë³€ìˆ˜ìž…ë‹ˆë‹¤.
* **`if 'op' in instr:`**: Brilì—ì„œ ëª…ë ¹ì–´(instruction)ëŠ” `op` í‚¤ë¥¼ ê°€ì§€ê³ , ë ˆì´ë¸”(label)ì€ `label` í‚¤ë¥¼ ê°€ì§‘ë‹ˆë‹¤. ì´ ë¼ì¸ì€ í˜„ìž¬ í•­ëª©ì´ ëª…ë ¹ì–´ì¸ì§€ í™•ì¸í•©ë‹ˆë‹¤.
    * ëª…ë ¹ì–´ë¼ë©´ `cur_block`ì— ì¶”ê°€í•©ë‹ˆë‹¤.
    * ë§Œì•½ ì´ ëª…ë ¹ì–´ê°€ `TERMINATORS` ì¤‘ í•˜ë‚˜ë¼ë©´, ì´ ëª…ë ¹ì–´ëŠ” í˜„ìž¬ ë¸”ë¡ì˜ ë§ˆì§€ë§‰ì´ë¯€ë¡œ `yield` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©í•´ `cur_block`ì„ ë°˜í™˜í•˜ê³ , `cur_block`ì„ ë¹„ì›Œ ìƒˆ ë¸”ë¡ì„ ì¤€ë¹„í•©ë‹ˆë‹¤.
* **`else:`**: ë ˆì´ë¸”ì„ ë§Œë‚œ ê²½ìš°ìž…ë‹ˆë‹¤. ë ˆì´ë¸”ì€ ìƒˆë¡œìš´ ë¸”ë¡ì˜ ì‹œìž‘ìž…ë‹ˆë‹¤.
    * **`if cur_block:`**: ë§Œì•½ ë ˆì´ë¸”ì„ ë§Œë‚˜ê¸° ì§ì „ê¹Œì§€ `cur_block`ì— ëª…ë ¹ì–´ê°€ ìžˆì—ˆë‹¤ë©´ (ì¦‰, ì´ì „ ë¸”ë¡ì´ ì¢…ê²°ìž ì—†ì´ ëë‚œ ê²½ìš°), í•´ë‹¹ ë¸”ë¡ì„ `yield`ë¡œ ë°˜í™˜í•˜ì—¬ ë¨¼ì € ì¢…ë£Œì‹œí‚µë‹ˆë‹¤.
    * **`cur_block = [instr]`**: ì´ ë ˆì´ë¸”ì„ ì²« ë²ˆì§¸ í•­ëª©ìœ¼ë¡œ í•˜ëŠ” ìƒˆë¡œìš´ `cur_block`ì„ ì‹œìž‘í•©ë‹ˆë‹¤.
* **`if cur_block: (ë£¨í”„ ì¢…ë£Œ í›„)`**: ë§ˆì§€ë§‰ ë¸”ë¡ì´ `ret` ê°™ì€ ì¢…ê²°ìžë¡œ ëë‚˜ì§€ ì•Šì•˜ì„ ê²½ìš°, ë£¨í”„ê°€ ëë‚œ ë’¤ `cur_block`ì— ë‚¨ì•„ìžˆëŠ” ëª…ë ¹ì–´ê°€ ìžˆì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì´ë¥¼ ë§ˆì§€ë§‰ ë¸”ë¡ìœ¼ë¡œ ë°˜í™˜í•©ë‹ˆë‹¤.

---

## 2. ì œì–´ íë¦„ ê·¸ëž˜í”„ (CFG) êµ¬ì¶•

ì•žì„  ë‹¨ê³„ì—ì„œ ìš°ë¦¬ëŠ” ì„ í˜•ì ì¸ ì½”ë“œë¥¼ ì—¬ëŸ¬ ê°œì˜ 'ê¸°ë³¸ ë¸”ë¡' ë©ì–´ë¦¬ë¡œ ë¶„ë¦¬í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ë¸”ë¡ë“¤ì€ ì•„ì§ ì´ë¦„ë„ ì—†ê³  ì„œë¡œ ì–´ë–»ê²Œ ì—°ê²°ë˜ì–´ ìžˆëŠ”ì§€ë„ ëª¨ë¥´ëŠ”, ë§ ê·¸ëŒ€ë¡œ 'ëª…ë ¹ì–´ ë¦¬ìŠ¤íŠ¸ì˜ ë¦¬ìŠ¤íŠ¸'ì¼ ë¿ìž…ë‹ˆë‹¤.
`cfg.py`ì˜ ì—­í• ì€ ì´ ë¸”ë¡ë“¤ì— ê³ ìœ í•œ ì´ë¦„ì„ ë¶€ì—¬í•˜ê³ , ë¸”ë¡ ê°„ì˜ **ì œì–´ íë¦„(ê°„ì„ )**ì„ ëª…ì‹œì ìœ¼ë¡œ ì°¾ì•„ë‚´ì–´ **'ì „ìž„ìž(predecessors)'**ì™€ **'í›„ìž„ìž(successors)'** ëª©ë¡ì„ ê°€ì§„ ì™„ì „í•œ ê·¸ëž˜í”„ ìžë£Œêµ¬ì¡°ë¥¼ ë§Œë“œëŠ” ê²ƒìž…ë‹ˆë‹¤.

### `cfg.py` í•µì‹¬ ë¡œì§ ë¶„ì„

CFG êµ¬ì¶•ì€ ë‹¤ìŒ ì„¸ ê°€ì§€ ì£¼ìš” ë‹¨ê³„ë¥¼ í†µí•´ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

1.  **1ë‹¨ê³„: ë¸”ë¡ ë§µ ìƒì„± (`block_map`)**
    ê°€ìž¥ ë¨¼ì €, ê° ê¸°ë³¸ ë¸”ë¡(ë…¸ë“œ)ì„ ì‹ë³„í•  ê³ ìœ í•œ ì´ë¦„ì´ í•„ìš”í•©ë‹ˆë‹¤. `block_map` í•¨ìˆ˜ëŠ” `form_blocks`ì—ì„œ ìƒì„±ëœ ë¸”ë¡ ë¦¬ìŠ¤íŠ¸ë¥¼ ìˆœíšŒí•˜ë©° `OrderedDict` ìžë£Œêµ¬ì¡°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
    * **ë ˆì´ë¸”ì´ ìžˆëŠ” ë¸”ë¡:** `block[0]`(ë¸”ë¡ì˜ ì²« ë²ˆì§¸ í•­ëª©)ì´ ë ˆì´ë¸”ì´ë©´, í•´ë‹¹ ë ˆì´ë¸”ì„ ë¸”ë¡ì˜ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ëª…ë ¹ì–´ ëª©ë¡ì—ì„œ ë ˆì´ë¸”ì„ ì œê±°í•©ë‹ˆë‹¤.
    * **ìµëª… ë¸”ë¡(Anonymous Block):** ë ˆì´ë¸”ì´ ì—†ëŠ” ë¸”ë¡(ì˜ˆ: `jmp`ë‚˜ `br` ë°”ë¡œ ë‹¤ìŒì˜ ë¸”ë¡)ì€ `fresh('b', ...)` ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ `b1`, `b2`ì™€ ê°™ì´ ì¶©ëŒí•˜ì§€ ì•ŠëŠ” ìƒˆ ì´ë¦„ì„ ë¶€ì—¬ë°›ìŠµë‹ˆë‹¤.

```python
def block_map(blocks):
    """Given a sequence of basic blocks, which are lists of instructions,
    produce a `OrderedDict` mapping names to blocks.
    ...
    """
    by_name = OrderedDict()

    for block in blocks:
        # Generate a name for the block.
        if 'label' in block[0]:
            # The block has a label. Remove the label but use it for the
            # block's name.
            name = block[0]['label']
            block = block[1:]
        else:
            # Make up a new name for this anonymous block.
            name = fresh('b', by_name)

        # Add the block to the mapping.
        by_name[name] = block

    return by_name
```

### 2ë‹¨ê³„: ì•”ë¬µì  ì œì–´ íë¦„ ëª…ì‹œí™” (add_terminators)

`form_blocks` ë‹¨ê³„ì—ì„œ ìƒì„±ëœ ë¸”ë¡ ì¤‘ ì¼ë¶€ëŠ” `br`, `jmp`, `ret` ê°™ì€ ì¢…ê²°ìž(Terminator) ëª…ë ¹ì–´ ì—†ì´ ëë‚  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì´ëŠ” "ì‹¤í–‰ì´ ëë‚˜ë©´ ì½”ë”©ëœ ìˆœì„œìƒì˜ ë‹¤ìŒ ë¸”ë¡ìœ¼ë¡œ ì•”ë¬µì ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤(fall-through)"ëŠ” ì˜ë¯¸ìž…ë‹ˆë‹¤. í•˜ì§€ë§Œ ê·¸ëž˜í”„ ë¶„ì„ì„ ìœ„í•´ì„œëŠ” ëª¨ë“  ì œì–´ íë¦„ì´ **ëª…ì‹œì (explicit)**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.

`add_terminators` í•¨ìˆ˜ëŠ” `block_map`ì„ ìˆœíšŒí•˜ë©° ì¢…ê²°ìžê°€ ì—†ëŠ” ëª¨ë“  ë¸”ë¡ì„ ì°¾ì•„ë‚´ì–´ ëª…ì‹œì ì¸ `jmp` ë˜ëŠ” `ret` ëª…ë ¹ì–´ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

* ì¢…ê²°ìžê°€ ì—†ìœ¼ë©´ì„œ ë§ˆì§€ë§‰ ë¸”ë¡ì´ ì•„ë‹ˆë©´: **ë‹¤ìŒ ë¸”ë¡ìœ¼ë¡œ ê°€ëŠ” `jmp`**ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
* ì¢…ê²°ìžê°€ ì—†ìœ¼ë©´ì„œ ë§ˆì§€ë§‰ ë¸”ë¡ì´ë©´: **`ret`**ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

```python
def add_terminators(blocks):
    """Given an ordered block map, modify the blocks to add terminators
    to all blocks (avoiding "fall-through" control flow transfers).
    """
    for i, block in enumerate(blocks.values()):
        # ... (Check for empty blocks removed for brevity) ...
        if block[-1]['op'] not in TERMINATORS:
            if i == len(blocks) - 1:
                block.append({'op': 'ret', 'args': []})
            else:
                # Otherwise, jump to the next block.
                dest = list(blocks.keys())[i + 1]
                block.append({'op': 'jmp', 'labels': [dest]})
```

> ðŸ’¡ **ì¤‘ìš”:** ì´ `add_terminators` ë‹¨ê³„ê°€ ì™„ë£Œëœ ì‹œì ì—ì„œ, ê° ë¸”ë¡ì˜ ë§ˆì§€ë§‰ ëª…ë ¹ì–´ëŠ” ë°˜ë“œì‹œ `br`, `jmp`, `ret` ì¤‘ í•˜ë‚˜ê°€ ë˜ë©°, ì´ ëª…ë ¹ì–´ê°€ í•´ë‹¹ ë¸”ë¡ì—ì„œ ë‚˜ê°€ëŠ” ëª¨ë“  ê°„ì„ (edge) ì •ë³´ë¥¼ ë‹´ê³  ìžˆê²Œ ë©ë‹ˆë‹¤.

### 3ë‹¨ê³„: ê°„ì„  ìƒì„± (edges)

ì´ì œ ëª¨ë“  ë¸”ë¡ì´ ì´ë¦„ê³¼ ëª…ì‹œì ì¸ ì¢…ê²°ìžë¥¼ ê°€ì¡Œìœ¼ë¯€ë¡œ, ì‹¤ì œ ê·¸ëž˜í”„(ê°„ì„ )ë¥¼ ë§Œë“¤ ìˆ˜ ìžˆìŠµë‹ˆë‹¤. `edges` í•¨ìˆ˜ëŠ” `blocks` ë§µì„ ìˆœíšŒí•˜ë©° ê° ë¸”ë¡ì˜ ì¢…ê²°ìž(`block[-1]`)ë¥¼ ê²€ì‚¬í•©ë‹ˆë‹¤.

* `successors` í—¬í¼ í•¨ìˆ˜ë¥¼ í†µí•´ ì¢…ê²°ìžì— í¬í•¨ëœ `labels` (ëŒ€ìƒ ë ˆì´ë¸”) ëª©ë¡ì„ ê°€ì ¸ì˜µë‹ˆë‹¤.
* `succs[name].append(succ)`: í˜„ìž¬ ë¸”ë¡(`name`)ì˜ í›„ìž„ìž(successor) ëª©ë¡ì— ëŒ€ìƒ ë ˆì´ë¸”(`succ`)ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
* `preds[succ].append(name)`: ëŒ€ìƒ ë ˆì´ë¸” ë¸”ë¡(`succ`)ì˜ ì „ìž„ìž(predecessor) ëª©ë¡ì— í˜„ìž¬ ë¸”ë¡(`name`)ì„ ì¶”ê°€í•©ë‹ˆë‹¤.

```python
def successors(instr):
    """Get the list of jump target labels for an instruction.
    ...
    """
    if instr['op'] in ('jmp', 'br'):
        return instr['labels']
    elif instr['op'] == 'ret':
        return []  # No successors to an exit block.
    # ...

def edges(blocks):
    """Given a block map containing blocks complete with terminators,
    generate two mappings: predecessors and successors. Both map block
    names to lists of block names.
    """
    preds = {name: [] for name in blocks}
    succs = {name: [] for name in blocks}
    for name, block in blocks.items():
        for succ in successors(block[-1]):
            succs[name].append(succ)
            preds[succ].append(name)
    return preds, succs
```

## 3. CFG ì‹œê°í™” (Graphviz)

CFGëŠ” ê·¸ëž˜í”„ ìžë£Œêµ¬ì¡°ì´ë¯€ë¡œ, í…ìŠ¤íŠ¸ë¡œë§Œ íŒŒì•…í•˜ê¸°ëŠ” ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤. íŠ¹ížˆ ë³µìž¡í•œ ë¶„ê¸°ë¬¸(if/else)ì´ë‚˜ ë£¨í”„(loop)ê°€ í¬í•¨ëœ ê²½ìš°, ê·¸ëž˜í”„ë¥¼ ì‹œê°í™”í•˜ëŠ” ê²ƒì€ í•„ìˆ˜ì ìž…ë‹ˆë‹¤.

`cfg_dot.py` ìŠ¤í¬ë¦½íŠ¸ëŠ” `cfg.py`ì—ì„œ ë§Œë“  CFG(ë¸”ë¡ ë§µ)ë¥¼ ìž…ë ¥ë°›ì•„, **Graphviz**ë¼ëŠ” ê·¸ëž˜í”„ ì‹œê°í™” ë„êµ¬ê°€ ì½ì„ ìˆ˜ ìžˆëŠ” **DOT ì–¸ì–´** ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

### `cfg_dot.py` í•µì‹¬ ë¡œì§ ë¶„ì„

ì´ ìŠ¤í¬ë¦½íŠ¸ì˜ `cfg_dot` í•¨ìˆ˜ëŠ” ì´ì „ì— ìš°ë¦¬ê°€ ì •ì˜í•œ í•¨ìˆ˜ë“¤ì„ ìˆœì„œëŒ€ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.

1.  **`blocks = block_map(form_blocks(func['instrs'])):`** Bril í•¨ìˆ˜ë¡œë¶€í„° ê¸°ë³¸ ë¸”ë¡ì„ ë§Œë“¤ê³ , `block_map`ì„ í˜¸ì¶œí•˜ì—¬ ì´ë¦„ì´ ë¶€ì—¬ëœ ë¸”ë¡ ë§µì„ ìƒì„±í•©ë‹ˆë‹¤.
2.  **`add_terminators(blocks):`** `cfg.py`ì—ì„œ ë´¤ë˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ëª¨ë“  ë¸”ë¡ì´ ëª…ì‹œì ì¸ ì¢…ê²°ìž(ê°„ì„  ì •ë³´)ë¥¼ ê°–ë„ë¡ ë³´ìž¥í•©ë‹ˆë‹¤.
3.  **ì •ì (Vertices) ì¶œë ¥:** `blocks.items()`ë¥¼ ìˆœíšŒí•˜ë©° DOT íŒŒì¼ì— ë…¸ë“œ(ì •ì )ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
    * `-v (verbose)` ì˜µì…˜ì´ ì¼œì ¸ ìžˆìœ¼ë©´, ë…¸ë“œë¥¼ ì‚¬ê°í˜•(`shape=box`)ìœ¼ë¡œ ê·¸ë¦¬ê³  `label` ì†ì„±ì— í•´ë‹¹ ë¸”ë¡ì˜ ëª¨ë“  Bril ëª…ë ¹ì–´ë¥¼ `\l` (ì™¼ìª½ ì •ë ¬ ì¤„ë°”ê¿ˆ)ë¡œ ì—®ì–´ í•¨ê»˜ ì¶œë ¥í•©ë‹ˆë‹¤.
4.  **ê°„ì„ (Edges) ì¶œë ¥:** `blocks.items()`ë¥¼ ë‹¤ì‹œ ìˆœíšŒí•˜ë©° ê° ë¸”ë¡ì˜ ë§ˆì§€ë§‰ ëª…ë ¹ì–´(`block[-1]`)ì— ëŒ€í•´ `successors` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ `í˜„ìž¬ë¸”ë¡ -> í›„ìž„ìžë¸”ë¡;` í˜•íƒœì˜ DOT ê°„ì„ (í™”ì‚´í‘œ)ì„ ì¶œë ¥í•©ë‹ˆë‹¤.

```python
def cfg_dot(bril, verbose):
    """Generate a GraphViz "dot" file showing the control flow graph for
    a Bril program.
    ...
    """
    for func in bril['functions']:
        print('digraph {} {{'.format(func['name']))

        # 1. Get named blocks
        blocks = block_map(form_blocks(func['instrs']))

        # 2. Make edges explicit
        add_terminators(blocks)

        # 3. Add the vertices (nodes)
        for name, block in blocks.items():
            if verbose:
                import briltxt
                print(r'  {} [shape=box, xlabel="{}", label="{}\l"];'.format(
                    quote_if_needed(name),
                    name,
                    r'\l'.join(briltxt.instr_to_string(i) for i in block),
                ))
            else:
                print('  {};'.format(name))

        # 4. Add the control-flow edges (arrows)
        for i, (name, block) in enumerate(blocks.items()):
            succ = successors(block[-1])
            for label in succ:
                print('  {} -> {};'.format(quote_if_needed(name), 
                                        quote_if_needed(label)))

        print('}')
```

## Quartoì—ì„œ CFG ì‹œê°í™”í•˜ê¸°

`cfg_dot.py`ê°€ ìƒì„±í•œ DOT ì½”ë“œë¥¼ `.qmd` íŒŒì¼ì— ë‚´ìž¥í•˜ë©´, ë…ìžì—ê²Œ ì‹¤ì œ CFGë¥¼ ì¸í„°ëž™í‹°ë¸Œí•˜ê²Œ ë³´ì—¬ì¤„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, ê°„ë‹¨í•œ `if`ë¬¸ Bril ì½”ë“œë¥¼ ì´ ìŠ¤í¬ë¦½íŠ¸ë¡œ ì²˜ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ìœ ì‚¬í•œ DOT ì¶œë ¥ì„ ìƒì„±í•©ë‹ˆë‹¤.

```{dot}
digraph my_function { entry [shape=box, xlabel="entry", label="v: int = const 4\lbr cond if.then if.else\l"];

// ì—ì§€(edge)ë¥¼ ì •ì˜í•  ë•Œ ë”°ì˜´í‘œë¡œ ê°ì‹¸ì¤ë‹ˆë‹¤. 
entry -> "if.then"; entry -> "if.else";

// ë…¸ë“œ(node)ë¥¼ ì •ì˜í•  ë•Œë„ ë”°ì˜´í‘œë¡œ ê°ì‹¸ì¤ë‹ˆë‹¤. 
"if.then" [shape=box, xlabel="if.then", label="v: int = add v v\ljmp if.end\l"]; "if.then" -> "if.end";

"if.else" [shape=box, xlabel="if.else", label="v: int = const 0\ljmp if.end\l"]; "if.else" -> "if.end";

"if.end" [shape=box, xlabel="if.end", label="print v\lret\l"]; }
```