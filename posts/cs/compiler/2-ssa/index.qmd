---
title: "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리"
description: "CFG를 기반으로 '지배자(Dominator)'와 '지배 경계(Dominance Frontier)'를 계산하는 방법을 알아보고, 이를 활용해 Phi(φ) 함수를 삽입하여 코드를 SSA(Static Single Assignment) 폼으로 변환하는 핵심 과정을 분석합니다."
date: "2025-11-02"
categories: [Compiler, Python, Bril, SSA, Dominator]
image: "images/cover_ssa.png"
---

1부에서는 Bril 코드를 기본 블록으로 나누어 **제어 흐름 그래프(CFG)**를 구축했습니다. CFG가 "어디로 갈 수 있는가"에 대한 *흐름*을 보여준다면, 2부에서는 "어떤 노드를 실행하기 위해 **반드시** 먼저 거쳐야 하는 노드가 무엇인가"에 대한 *구조*를 분석합니다.

이것이 바로 **지배자(Dominator)** 분석이며, SSA 폼 변환의 심장부입니다.

## 4. 지배자 분석: "반드시 거치는 길" 찾기

> **지배 (Dominance)란?**
> CFG에서 노드 $A$가 노드 $B$를 **지배(dominates)**한다는 것은, 프로그램의 진입(entry) 노드에서 $B$로 가는 **모든 경로**가 **반드시** $A$를 거쳐야 함을 의미합니다. (이때 $A$는 $B$ 자신일 수도 있습니다.)
> * $LaTeX$ 표기: $A \text{ dom } B$
> * **직관적 의미:** $B$를 실행했다면, 그전에 $A$는 *무조건* 실행되었음이 보장된다.
> * **예시:** 루프(loop)의 헤더(header) 블록은 루프 본체(body)의 모든 블록을 지배합니다.

`dom.py` 스크립트는 이 지배 관계를 계산하고, 이를 바탕으로 SSA 변환에 필수적인 두 가지 핵심 자료구조를 구축합니다.

1.  **지배자 (Dominators) / `get_dom`**: 각 노드 $n$에 대해, $n$을 지배하는 모든 노드의 집합 $Dom(n)$을 계산합니다.
2.  **지배 경계 (Dominance Frontier) / `dom_fronts`**: $\phi$ 함수를 어디에 삽입할지 알려주는 핵심 정보입니다.

### 1. 지배자 관계 계산 (`get_dom`)

`get_dom` 함수는 고전적인 **반복적 데이터 흐름 분석(iterative data-flow analysis)** 알고リズム을 사용하여 지배자 집합 $Dom(n)$을 계산합니다.

이 알고리즘은 다음의 재귀적인 정의에 기반합니다.
$$Dom(n) = \{n\} \cup \left( \bigcap_{p \in \text{pred}(n)} Dom(p) \right)$$

* $Dom(n)$: 노드 $n$의 지배자 집합
* $\text{pred}(n)$: 노드 $n$의 모든 **전임자(predecessor)** 노드 집합
* (예외: 진입 노드 $n_0$의 경우 $Dom(n_0) = \{n_0\}$ 입니다.)

#### 코드 해설

`get_dom` 함수는 이 수식을 '고정점(fixed-point)'에 도달할 때까지 반복 계산합니다.

```python
def get_dom(succ, entry):
    pred = map_inv(succ)
    # 1. RPO(Reverse Postorder)로 노드 순회 순서 결정 (빠른 수렴을 위함)
    nodes = list(reversed(postorder(succ, entry))) 

    # 2. 초기화: Dom(n) = {모든 노드} (데이터 흐름 분석의 'Top' 원소)
    dom = {v: set(nodes) for v in succ}
    # 진입 노드의 Dom(entry)는 {entry}여야 하지만,
    # 아래 루프의 첫 번째 반복에서 자동으로 그렇게 설정됩니다.

    while True:
        changed = False

        # 3. 모든 노드를 RPO 순서로 순회
        for node in nodes:
            # 4. Meet 연산: pred(node)의 Dom 집합들의 교집합(intersection) 계산
            new_dom = intersect(dom[p] for p in pred[node])
            # 5. Transfer 함수: {n}을 추가
            new_dom.add(node)

            # 6. 수렴(Convergence) 확인
            if dom[node] != new_dom:
                dom[node] = new_dom
                changed = True

        if not changed:
            break  # 고정점에 도달하면(더 이상 변경이 없으면) 종료

    return dom
```

## 2. 지배자 트리 (Dominator Tree)

`get_dom`이 계산한 $Dom(n)$은 모든 지배자 집합입니다. 하지만 이 관계는 '트리' 구조로 단순화할 수 있습니다.

### 즉시 지배자 (Immediate Dominator, idom)

노드 $B$를 지배하는 노드 $A$가 $B$의 즉시 지배자라는 것은, $A$와 $B$ 사이에 $A$를 지배하면서 $B$를 지배하는 다른 노드가 존재하지 않는다는 의미입니다. (즉, $A$가 $B$로 가는 길의 '마지막' 지배자입니다.)

* 진입 노드를 제외한 모든 노드는 유일한(unique) 즉시 지배자를 가집니다.

이 `idom` 관계를 모아 그린 것이 **지배자 트리(Dominator Tree)**입니다. CFG가 복잡한 그래프일지라도, 지배자 트리는 항상 단순한 트리 구조가 됩니다.
`dom_tree` 함수는 `get_dom`의 결과를 바탕으로 이 `idom` 관계(부모-자식 관계)를 계산합니다.

---

## 3. 지배 경계 (Dominance Frontier)

드디어 SSA 변환의 가장 핵심적인 개념인 **지배 경계(Dominance Frontier)**입니다.

> **지배 경계 (Dominance Frontier, DF) 란?**
>
> 노드 $A$의 지배 경계 $DF(A)$는, $A$가 지배하는 노드($A$ 자신 포함)의 후임자이면서, $A$가 엄격하게(strictly) 지배하지는 않는 노드들의 집합입니다.
>
> * **엄격한 지배(Strict Dominance):** $A \text{ dom } B$ 이고 $A \ne B$ 인 경우.
> * **직관적 의미:** 변수의 영향력이 $A$의 '지배 영역'을 벗어나 처음으로 도달하는 **합류 지점(join point)**입니다.

**이것이 왜 중요할까요?**

어떤 블록 $A$에서 변수 $x$에 새로운 값이 할당(정의)되었다고 가정해봅시다. 이 $x$의 값은 $A$가 지배하는 모든 블록에서 유효합니다. 하지만 $A$의 '지배 영역'을 벗어나는 순간(즉, $DF(A)$에 속하는 블록), 다른 경로에서 온 $x$의 값과 합쳐져야 합니다.

따라서 $DF(A)$는 $\phi$ (phi) 함수가 삽입되어야 할 위치를 정확히 알려줍니다.

### 코드 해설 (dom_fronts)

`dom_fronts` 함수는 이 정의를 코드로 정확하게 구현합니다.

```python
def dom_fronts(dom, succ):
    """Compute the dominance frontier, given the dominance relation.
    """
    # dom_inv[A] = A가 지배하는 모든 노드 집합
    dom_inv = map_inv(dom)

    frontiers = {}
    for block in dom:  # 모든 노드 A (block)에 대해
        # Find all successors of dominated blocks.
        dominated_succs = set()
        # 1. A가 지배하는 모든 노드(dominated)를 찾고,
        for dominated in dom_inv[block]:
            # 2. 그 노드들의 모든 후임자(successors)를 찾는다.
            dominated_succs.update(succ[dominated])

        # 3. 이 후임자(b)들 중에서,
        #    A가 '엄격하게' 지배하지 않는 노드만 필터링한다.
        frontiers[block] = [b for b in dominated_succs
                            if b not in dom_inv[block] or b == block]

    return frontiers
```

## 5. SSA 폼 변환: $\phi$ 함수와 변수 이름 변경

이제 우리는 CFG, 지배자 트리, 그리고 지배 경계라는 재료를 모두 확보했습니다. 이 재료들을 사용해 IR을 SSA (Static Single Assignment) 폼으로 변환할 차례입니다.

> **SSA (Static Single Assignment)란?**
> 모든 변수(variable)가 프로그램 텍스트 상에서 **단 한 번만 할당(assignment)**되도록 보장하는 IR의 한 형태입니다.
> * 예시: `x = 1; x = x + 1;`
> * SSA 변환: `x.0 = 1; x.1 = add x.0 1;`

이 "단일 할당" 속성 덕분에, 변수의 '정의(definition)'와 '사용(use)' 관계가 매우 명확해져, 다양한 최적화를 강력하고 효율적으로 만듭니다.

이 변환은 두 단계 알고리즘으로 수행됩니다.

1.  **$\phi$ 함수 삽입:** 지배 경계(DF)를 이용해 $\phi$ 함수가 필요한 위치를 찾습니다.
2.  **변수 이름 변경 (Renaming):** 지배자 트리(Dominator Tree)를 순회하며 모든 변수의 정의와 사용을 `x.0`, `x.1` 등으로 다시 명명합니다.

### 1단계: $\phi$ 함수 위치 선정 (get_phis)

`get_phis` 함수는 `dom_fronts`가 계산한 지배 경계를 사용해 $\phi$ 함수가 필요한 위치를 찾습니다.

* $v$에 대한 정의가 블록 $D$에서 발생할 때, $DF(D)$에 속하는 모든 블록은 $v$에 대한 $\phi$ 함수가 필요할 수 있는 '합류 지점'입니다.
* `get_phis`는 이 과정을 $\phi$ 함수 자신이 또 다른 정의가 되는 것까지 고려하여, 새로운 $\phi$ 함수가 더 이상 추가되지 않을 때까지 반복적으로(Iterated Dominance Frontier) 수행합니다.

```python
def get_phis(blocks, df, defs):
    """Find where to insert phi-nodes in the blocks.
    ...
    """
    phis = {b: set() for b in blocks}
    for v, v_defs in defs.items():
        v_defs_list = list(v_defs)  # W = 리스트 (워크리스트)
        for d in v_defs_list:  # W에서 하나씩 꺼내는 동안 (W가 증가 가능)
            for block in df[d]:  # d의 지배 경계에 속하는 모든 블록
                if v not in phis[block]:
                    # 이 블록에 v에 대한 phi 함수가 필요하다고 표시
                    phis[block].add(v)
                    # phi 함수 자체가 새로운 정의이므로,
                    # 이 블록(block)도 워크리스트에 추가
                    if block not in v_defs_list:
                        v_defs_list.append(block)
    return phis
```

### 2단계: 변수 이름 변경 (ssa_rename)

`ssa_rename` 함수는 **지배자 트리를 전위 순회(pre-order traversal)**하는 재귀 알고리즘을 사용해 실제 변수 이름을 `v.0`, `v.1` 등으로 변경합니다.

* 각 변수명(예: 'x')마다, 현재 유효한 이름(예: 'x.3')을 저장하는 스택을 유지합니다.
* **지배자 트리를 순회하는 이유:** 트리를 따라 내려갈 때(즉, $A$에서 $A$가 지배하는 $B$로 이동할 때), 부모($A$)에서 정의된 변수 버전이 자식($B$)에서도 유효함이 보장됩니다.

`_rename(block)` 함수의 핵심 로직은 다음과 같습니다.

1.  **스택 백업:** 현재 스택 상태를 `old_stack`에 저장합니다.
2.  **$\phi$ 함수 정의:** 현재 블록의 $\phi$ 함수 목적지(`dest`) 이름을 새로 만듭니다(예: `x.4`). 이 새 이름을 스택에 푸시합니다.
3.  **일반 명령어 순회:**
    * **사용(args):** 명령어의 인자는 스택의 맨 위(`stack[arg][0]`) 이름으로 교체합니다.
    * **정의(dest):** 명령어의 목적지(`dest`)는 새 이름을 만들고(예: `v.1`), 스택에 푸시합니다.
4.  **후임자($\phi$) 인자 채우기:** CFG의 후임자(successor) 블록에 있는 $\phi$ 함수의 인자를 현재 스택의 맨 위 이름으로 채워줍니다.
5.  **재귀 호출:** *지배자 트리의 자식(child)*에 대해 `_rename(b)`를 재귀 호출합니다.
6.  **스택 복원:** `old_stack`을 사용해 스택을 재귀 호출 이전 상태로 되돌립니다. (형제 노드에게 영향을 주지 않기 위함)

```python
def ssa_rename(blocks, phis, succ, domtree, args):
    stack = defaultdict(list, {v: [v] for v in args}) # var -> [v.2, v.1, v.0]
    # ... (phi_args, phi_dests, counters 초기화) ...

    def _push_fresh(var):
        fresh = '{}.{}'.format(var, counters[var])
        counters[var] += 1
        stack[var].insert(0, fresh)
        return fresh

    def _rename(block):
        # 1. 스택 상태 저장
        old_stack = {k: list(v) for k, v in stack.items()}

        # 2. 이 블록의 phi-node 목적지(dest) 이름 변경
        for p in phis[block]:
            phi_dests[block][p] = _push_fresh(p)

        # 3. 일반 명령어 순회 (사용 -> 정의 순)
        for instr in blocks[block]:
            if 'args' in instr:
                instr['args'] = [stack[arg][0] for arg in instr['args']]
            if 'dest' in instr:
                instr['dest'] = _push_fresh(instr['dest'])

        # 4. 후임자(successor) 블록의 phi-node 인자(arg) 채우기
        for s in succ[block]:
            for p in phis[s]:
                if stack[p]:
                    phi_args[s][p].append((block, stack[p][0]))
                # ... (undefined 처리) ...

        # 5. 지배자 트리의 자식 노드 재귀 방문
        for b in sorted(domtree[block]):
            _rename(b)

        # 6. 이 블록에서 정의한 이름들을 스택에서 팝 (상태 복원)
        stack.clear()
        stack.update(old_stack)

    entry = list(blocks.keys())[0]
    _rename(entry)
    # ... (결과 반환) ...
```

## 6. SSA 폼 검증하기 (is_ssa)

`to_ssa.py`의 변환은 매우 복잡합니다. 이 변환이 성공했는지, 그 결과물이 SSA의 핵심 속성을 만족하는지 어떻게 보장할 수 있을까요?
`is_ssa.py` 스크립트는 이 변환을 검증하는 간단한 유틸리티입니다.

* **SSA의 핵심 정의:** 모든 변수는 함수 내의 텍스트에서 단 한 번만 할당(정의)되어야 합니다.

`is_ssa` 함수는 `assigned`라는 **집합(set)**을 사용해, 함수 전체를 선형 스캔하며 'dest' 키를 가진 변수명이 이미 `assigned` 집합에 있는지(즉, 중복 정의되었는지) 검사합니다.

```python
def is_ssa(bril):
    """Check whether a Bril program is in SSA form.
    """
    for func in bril['functions']:
        assigned = set()
        for instr in func['instrs']:
            if 'dest' in instr:
                if instr['dest'] in assigned:
                    # This variable was already assigned to. Not SSA.
                    return False
                else:
                    # This is the first assignment. Record it.
                    assigned.add(instr['dest'])
    # No variable was assigned to more than once.
    return True
```