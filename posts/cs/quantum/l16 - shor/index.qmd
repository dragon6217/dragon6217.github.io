---
title: "L16. Shor's Factoring Algorithm"
description: 'Shor의 인수분해 알고리즘을 분석합니다. 이 알고리즘은 1970년대의 고전 정수론(인수분해를 "위수 찾기"로 환원)과 L15의 양자 "주기 찾기" 서브루틴을 결합합니다. 알고리즘의 병목인 $O(n^3)$의 "모듈러 지수 연산" 오라클 구현과, $N \gg L^2$ 설정을 통해 "연분수 알고리즘"으로 양자 측정값 $s \approx k(N/L)$에서 주기 $L$을 복원하는 $O(n^3)$의 고전 후처리 과정을 탐구합니다.'
author: "Analysis by Gemini"
date: "2025-11-02"
categories: [Quantum Computing, Quantum Algorithms, Shor's Algorithm, Factoring, Number Theory, QFT]
image: "images/cover.png"
---

## L16. Shor's Factoring Algorithm

Shor의 인수분해 알고리즘은 100% 양자 알고리즘이 아닙니다. 이 알고리즘은 **"양자 컴퓨터가 매우 잘하는 핵심 서브루틴" (L15: 주기 찾기)**과, 이를 활용하는 **"영리한 고전 정수론"**의 조합입니다.

Shor의 천재성은 고전적으로 지수적 시간이 걸렸던 "주기 찾기(Order-Finding)"라는 단 하나의 병목 단계를 양자 컴퓨터로 대체한 데 있습니다.

### 1. 복습: L15의 "양자 주기 찾기 기계" (The Quantum Subroutine)

L15에서 우리는 다음과 같은 강력한 양자 서브루틴(Subroutine)을 완성했습니다.

* **입력 (Input):** 주기 $L$을 가진 함수 $F: \mathbb{Z}_N \to \text{COLORS}$를 구현하는 양자 오라클 $Q_F$.
* **알고리즘:** $H-Q_F-QFT \to \text{Measure}$ (L15의 푸리에 샘플링)
* **비용 (Cost):** $O(n^2)$ 또는 (근사) $O(n \log n)$ 게이트. ($n = \log N$)
* **출력 (The "Clue"):**
    알고리즘을 1회 실행하면, 고전적인 정수 $s$를 측정합니다.
    1.  **"Good" (확률 $\ge 40.5\%$):** $s$는 $L$에 대한 "좋은 단서"입니다.
        $$s = \text{Nearest Integer}\left(k \cdot \frac{N}{L}\right) \quad (\text{for a random } k \in \{0, \dots, L-1\})$$
    2.  **"Junk" (확률 $\le 59.5\%$):** $s$는 $L$과 관계없는 "쓰레기" 값입니다.



---

### 2. 고전적 환원: 인수분해 $\le$ 위수 찾기 (Factoring $\le$ Order-Finding)

우리의 목표는 $n$비트 정수 $M = P \cdot Q$ ($P, Q$는 소수)를 인수분해하는 것입니다. 이 문제는 1970년대(Gary Miller)부터 "위수 찾기(Order-Finding)" 문제로 (고전적으로) 환원될 수 있음이 알려져 있었습니다.

**핵심 정수론 트릭: 1의 비자명한 제곱근**
* $M=PQ$일 때, $R \not\equiv \pm 1 \pmod M$ 이면서 $R^2 \equiv 1 \pmod M$을 만족하는 "비자명한(nontrivial)" 해 $R$을 찾으면,
* $(R-1)(R+1) \equiv 0 \pmod M$ 이고, $M$은 두 항 중 어느 쪽도 나누지 못하므로,
* $\text{gcd}(R-1, M) = P$ (또는 $Q$)가 되어 인수분해에 성공합니다.
* **Shor의 전략:** 임의의 $A$의 "위수(order)" $L$을 찾아서, $R = A^{L/2}$로 이 "비자명한" $R$을 만듭니다.

#### 2.1. 고전 환원 알고리즘 (Classical Reduction)

1.  **[1] (고전) $A$ 선택:** $1 < A < M-1$ 범위에서 임의의 정수 $A$를 고릅니다.
2.  **[2] (고전) GCD 확인:** $\text{gcd}(A, M)$을 계산($O(n^3)$)합니다.
    * $G > 1$이면, $G$가 $M$의 소인수($P$ 또는 $Q$)입니다. (성공, 종료)
    * $G = 1$ (즉, $A \in \mathbb{Z}_M^*$)이라고 가정합니다.
3.  **[3] (양자) 주기 찾기:**
    * 함수 $F_A(x) = A^x \pmod M$ 를 정의합니다.
    * $F_A(x)$의 주기 $L$ (즉, $A^L \equiv 1 \pmod M$을 만족하는 최소 $L$)을 **L15의 양자 서브루틴**을 이용해 찾습니다. (이것이 유일한 양자 단계입니다.)
4.  **[4] (고전) "행운" 확인 1:** $L$이 짝수(even)인지 확인합니다. (홀수이면 1단계로 돌아가 $A$를 다시 선택)
5.  **[5] (고전) $R$ 계산:** $R = A^{L/2} \pmod M$ 을 계산($O(n^3)$)합니다.
6.  **[6] (고전) "행운" 확인 2:** $R \not\equiv -1 \pmod M$ 인지 확인합니다. ( $-1$ 이면 "사소한" 해이므로 1단계로 돌아가 $A$를 다시 선택)
7.  **[7] (고전) 인수분해:**
    * 우리는 $R \not\equiv \pm 1 \pmod M$ 이면서 $R^2 \equiv 1 \pmod M$ 인 "비자명한" $R$을 찾았습니다.
    * $P = \text{gcd}(R-1, M)$ ($O(n^3)$)
    * $Q = \text{gcd}(R+1, M)$ ($O(n^3)$)

---

### 3. 알고리즘의 병목과 확률

#### 3.1. 양자 오라클 $Q_F$의 효율성 (The Bottleneck)

Shor 알고리즘의 **진정한 병목(bottleneck)**은 QFT($O(n^2)$)가 아니라, 3단계에서 $F_A(x) = A^x \pmod M$ 함수를 구현하는 **양자 오라클 $Q_F$**입니다.

* $F_A(x)$는 "반복 제곱(repeated squaring)"을 통해 고전적으로 **$O(n^3)$** (또는 $O(n^2 \log n \dots)$) 시간에 계산할 수 있습니다.
* L10에 따라, 이 고전 회로는 $O(n^3)$ 게이트를 사용하는 **가역 양자 회로 $Q_F$**로 효율적으로 변환될 수 있습니다.
* **총 복잡도:** ( $O(1)$번 반복 $\times$ [ $O(n^3)$ 오라클 + $O(n^2)$ QFT ] ) + $O(n^3)$ 고전 후처리 $\implies$ **$O(n^3)$** (다항식 시간)

#### 3.2. "행운"의 확률 (Pr[Luck])
4, 6단계에서 실패(L이 홀수이거나 $R \equiv -1$)하고 1단계로 돌아갈 확률은 얼마일까요?

> **[핵심 보조정리 (Shor)]**
> $M=PQ$ (서로 다른 두 홀수 소수의 곱)일 때, $A \in \mathbb{Z}_M^*$를 무작위로 선택하면, "성공"할 확률 (즉, $L$이 짝수이고 $A^{L/2} \not\equiv -1 \pmod M$ 일 확률)은
>
> **$\text{Pr}[\text{Success}] \ge \frac{1}{2}$**

* **증명 (Sketch):** 중국인의 나머지 정리(CRT)에 의해 $\mathbb{Z}_M^* \cong \mathbb{Z}_P^* \times \mathbb{Z}_Q^*$ 입니다. $A \leftrightarrow (A_P, A_Q)$ 이고 $L = \text{lcm}(L_P, L_Q)$ 입니다.
* **(운 1)** $\text{Pr}[L \text{ is even}] = 1 - \text{Pr}[L_P \text{ odd}]\text{Pr}[L_Q \text{ odd}] = 1 - (1/2)(1/2) = \mathbf{3/4}$ 입니다.
* **(운 2)** "실패"($A^{L/2} \equiv -1$)는 $A \leftrightarrow (-1, -1)$ 쌍에 해당하며, 이는 $L_P, L_Q$의 $2$-adic power가 같을 때만 발생하여 확률을 $1/2$ 이하로 낮춥니다.
* **결론:** $O(1)$ (상수) 횟수만 알고리즘을 반복하면 1에 가까운 확률로 성공합니다.

---

### 4. [Part 1] 고전 후처리: "단서" $s$로부터 $L$ 찾기

알고리즘의 마지막 퍼즐은 3단계에서 얻은 "양자 단서" $s \approx k(N/L)$로부터 $L$을 **고전적으로** 복원하는 것입니다.

* **문제:** $\frac{s}{N} \approx \frac{k}{L}$ ( $s, N$은 알고 $k, L$은 모름)
* **해법:** **연분수 알고리즘 (Continued Fractions Algorithm, CFA)**
* CFA는 $O(n^3)$의 고전적 시간 안에, "나쁜" 근사 분수 $\frac{s}{N}$를 "최상의" 기약분수(lowest terms) $\frac{k'}{L'}$로 변환합니다.

#### 4.1. "마법"이 작동하는 이유 ($N \gg L^2$)

CFA가 우리가 원하는 $k, L$을 정확히(혹은 $L$의 약수를) 찾는다는 것을 어떻게 보장할까요?
**답:** $N$을 $L^2$보다 훨씬 크게 설정했기 때문입니다.

1.  **Shor의 설정:** $M$이 $m$비트일 때 $L < M \approx 2^m$ 입니다. 우리는 $n=2m$ (즉 $N=2^{2m} \approx M^2$) 또는 $n=10m$ 등으로 $N$을 설정합니다.
2.  **보장된 근사:** "좋은" $s$는 다음을 만족합니다:
    $$\left| \frac{s}{N} - \frac{k}{L} \right| \le \frac{1}{2N}$$
3.  **정수론 정리 (Legendre):** $\left| x - \frac{k}{L} \right| \le \frac{1}{2L^2}$를 만족하면, CFA는 *반드시* $\frac{k}{L}$ (혹은 그 약분)를 찾습니다.
4.  **Shor의 적용:** 우리는 $N \ge M^2 > L^2$ (즉, $\frac{1}{2N} \le \frac{1}{2M^2} < \frac{1}{2L^2}$) 로 $N$을 설정했습니다.
5.  **결론:** 우리의 근사($\frac{1}{2N}$)는 CFA가 작동하기 위한 조건($\frac{1}{2L^2}$)보다 훨씬 더 정밀하므로, CFA는 **반드시** $L$의 (약수) 후보 $L'$를 찾아냅니다.

#### 4.2. 고전 후처리 루프 (The Classical Loop)

1.  **[1] (양자)** $H-Q_F-QFT \to \text{Measure}$를 1회 실행하여 $s$를 얻습니다. (확률 $\ge 40\%$로 "좋음")
2.  **[2] (고전 $O(n^3)$)** CFA를 $\frac{s}{N}$에 적용하여 기약분수 후보 $\frac{k'}{L'}$를 찾습니다.
3.  **[3] (고전 $O(n^3)$)** **검증 (Verification):** $L'$가 "진짜" 주기의 약수인지 확인합니다. $\implies A^{L'} \pmod M$을 계산합니다.
4.  **[4] 판정 (Decision):**
    * **(실패)** $A^{L'} \not\equiv 1 \pmod M$ 이면, $s$가 "Junk"였거나 $k$가 $L$과 서로소가 아니어서(예: $k/L = 2/6 \to 1/3$) $L'$가 $L$이 아닌 $L$의 약수(3)로 나온 경우입니다. $\implies$ **1단계로 돌아가 양자 알고리즘을 다시 실행**합니다. (LCM 방식 등으로 보완 가능)
    * **(성공)** $A^{L'} \equiv 1 \pmod M$ 이면, $L'=L$ (또는 $L$의 약수)을 찾은 것입니다. $\implies$ 2.1절의 4~8단계(L이 짝수인지, $R$이 비자명한지 확인 후 $\text{gcd}$)를 진행합니다.