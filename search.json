[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html",
    "href": "posts/cs/shor-algorithm/index.html",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "",
    "text": "Shor 알고리즘은 양자 알고리즘과 정수론을 결합한 것입니다. 이 알고리즘의 양자적 핵심은 “주기 찾기(Period-Finding)”입니다.\n\n\n\n우리는 \\(F: Z_N \\to \\text{COLORS}\\) (여기서 \\(N=2^n\\)이라고 가정)를 구현하는 양자 오라클(Quantum Function, QF)에 접근할 수 있습니다.\n이 함수 \\(F\\)는 “\\(L\\)-주기성”을 갖는다고 약속되어 있습니다.\n\n즉, \\(\\forall x \\in Z_N, F(x) = F(x+L) = F(x+2L) = \\dots\\)\n더 엄밀하게는( \\(L|N\\) 가정 시), \\(F(x) = F(y) \\iff L | (y-x) \\pmod{N}\\) 입니다.\n\n예시: \\(L=4\\) 라면, 함수 \\(F\\)의 출력(색상)은 [R, G, B, Y] | [R, G, B, Y] | \\dots 와 같이 \\(0, 1, 2, 3\\) 이후로 계속 반복됩니다.\n목표: \\(F\\)는 고전적인 입력뿐 아니라 입력의 양자 중첩(superposition) 상태도 처리할 수 있습니다. 우리는 이 오라클을 사용해 \\(L\\)을 효율적으로 찾는 것이 목적입니다.\n\n\n\n\n이 주기 찾기 문제(\\(L\\)-Period Finding Problem)는 다음의 3단계로 해결할 수 있습니다.\n1단계: “Load” (중첩 상태 준비)\n\n두 개의 양자 레지스터(input, output)를 준비합니다.\nInput 레지스터에 Hadamard 게이트를 적용하여 유니폼 중첩(uniform superposition) 상태를 만듭니다.\n그 다음, 양자 오라클(QF)을 적용하여 함수 \\(F\\)의 결과값을 Output 레지스터에 “로드”합니다.\n시스템의 전체 상태는 다음과 같이 됩니다:\n\\[\\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |0\\rangle \\xrightarrow{QF} \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |F(x)\\rangle\\]\n\n2단계: “Measure” (Output 레지스터 측정)\n\n여기서, 우리는 Output 레지스터 (색상, \\(|F(x)\\rangle\\))만 먼저 측정합니다.\n함수 \\(F\\)는 \\(L\\)-주기적이므로, 각 색상(예: \\(C^*\\))은 정확히 \\(N/L\\)번 나타납니다 ( \\(L|N\\) 가정 시).\n따라서 어떤 특정 색상 \\(C^*\\)를 측정할 확률은 \\(\\frac{N/L}{N} = \\frac{1}{L}\\) 입니다.\n(중요) 측정이 일어나는 순간, 양자 상태는 붕괴(collapse)합니다. 만약 \\(C^*\\)가 측정되었다면, Input 레지스터의 상태는 \\(F(x)=C^*\\)를 만족하는 \\(x\\)값들의 균등한 중첩 상태로 붕괴합니다.\n즉, 어떤 \\(x_0\\) ( \\(F(x_0)=C^*\\) )에 대해, 붕괴된 상태는 다음과 같습니다:\n\\[|\\psi_{C^*}\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{(N/L)-1} |x_0 + kL\\rangle\\]\n\n3단계: “Q.F.T.” (Input 레지스터 변환 및 측정)\n\n이제 우리는 주기가 \\(L\\)인 Input 레지스터의 중첩 상태를 얻었습니다.\n이 상태에 양자 푸리에 변환 (QFT, 또는 DFT)을 적용합니다.\n주기적인 상태를 QFT하면, 그 결과는 “스파이크 트레인(Spike Train)” 형태가 됩니다. 즉, 특정 값들에서만 확률이 높게 나타납니다.\n이 “스파이크”들은 주기의 역수(\\(1/L\\))와 관련된, \\(N/L\\)의 배수가 되는 지점들( \\(k \\cdot \\frac{N}{L}\\) )에서만 나타나게 됩니다.\n이 QFT가 적용된 Input 레지스터를 최종적으로 측정하면, 우리는 \\(N/L\\)의 배수인 어떤 값 \\(s\\)를 얻게 됩니다.\n이 측정값 \\(s\\)는 \\(L\\)에 대한 강력한 “단서(clue)”가 됩니다. (예: \\(s \\approx \\frac{k \\cdot N}{L}\\))\n\n\n\n\n2단계에서 우리는 랜덤한 색상 \\(C^*\\)를 측정했습니다. 이로 인해 Input 레지스터의 상태는 \\(C^*\\)에 의존하는 \\(x_0\\)만큼 무작위로 평행이동(random translation)됩니다.\n질문: 이 “무작위 평행이동”이 우리가 \\(L\\)을 찾는 것을 방해하지 않을까요?\n답변 (Pleasing Fact): 전혀 방해하지 않습니다.\n수학적 원리 (QFT Shift Theorem): 어떤 함수 \\(f(x)\\)를 \\(Y\\)만큼 평행이동시킨 함수 \\(f^Y(x) = f(x+Y)\\)가 있다고 합시다. 이 둘을 각각 QFT(\\(\\mathcal{F}\\))하면, 그 결과는 다음과 같은 관계를 갖습니다:\n\\[\\mathcal{F}(f^Y)(s) = \\mathcal{F}(f)(s) \\cdot \\omega_N^{-sY} \\quad (\\text{단, } \\omega_N = e^{2\\pi i / N})\\]\n즉, 원본(\\(x\\)) 공간에서의 평행이동(\\(+Y\\))은 푸리에(\\(s\\)) 공간에서 위상(phase)의 변화(\\(\\cdot \\omega_N^{-sY}\\))만을 유발합니다.\n우리가 최종적으로 측정하는 것은 확률, 즉 QFT 계수의 크기 제곱(magnitude squared)입니다. 위상 인자 \\(\\omega_N^{-sY}\\)의 크기는 \\(|\\omega_N^{-sY}| = 1\\) 입니다.\n\\[\n|\\mathcal{F}(f^Y)(s)|^2 = |\\mathcal{F}(f)(s) \\cdot \\omega_N^{-sY}|^2 = |\\mathcal{F}(f)(s)|^2 \\cdot |\\omega_N^{-sY}|^2 = |\\mathcal{F}(f)(s)|^2\n\\]\n결론 (The Pleasing Fact): 어떤 랜덤 색상 \\(C^*\\)를 측정하든 (즉, 스파이크 트레인이 \\(x_0\\)만큼 아무리 무작위로 평행이동되든), 우리가 Input 레지스터에서 \\(s\\)를 측정할 최종 확률 분포는 \\(x_0\\)와 관계없이 모두 동일합니다!\n\n\n\n왜 QFT가 “스파이크 트레인”을 만들까요? 3단계에서 \\(x_0=0\\) (평행이동 무시)으로 가정한 Input 상태 \\(g(x)\\)의 QFT \\(\\hat{g}(s)\\)를 계산해 봅시다.\n\nInput 상태: \\(g(x) = \\begin{cases} 1 & \\text{if } x \\in \\{0, L, 2L, \\dots\\} \\\\ 0 & \\text{else} \\end{cases}\\)\nQFT: \\(\\hat{g}(s) = \\sum_{x=0}^{N-1} g(x) \\cdot \\omega_N^{-xs} = \\sum_{j=0}^{(N/L)-1} \\omega_N^{-(jL)s}\\)\n\n경우 1: \\(s\\)가 \\(N/L\\)의 배수인 경우 ( \\(s = k \\cdot (N/L)\\) ) \\(\\omega_N^{-jLs} = \\omega_N^{-jL \\cdot k(N/L)} = \\omega_N^{-jkN} = ( \\omega_N^N )^{-jk} = 1^{-jk} = 1\\). \\(\\hat{g}(s) = \\sum_{j=0}^{(N/L)-1} 1 = N/L\\) \\(\\to\\) (보강 간섭) 모든 항이 \\(1\\)이 되어 합이 최대가 됩니다.\n경우 2: \\(s\\)가 \\(N/L\\)의 배수가 아닌 경우 이때 \\(L \\cdot s\\)는 \\(N\\)의 배수가 아니므로 \\(r = \\omega_N^{-Ls} \\neq 1\\) 입니다. 등비수열의 합은 0이 됩니다. \\(\\hat{g}(s) = \\frac{1 - (\\omega_N^{-Ls})^{N/L}}{1 - \\omega_N^{-Ls}} = \\frac{1 - (\\omega_N^{-N})^s}{1 - \\omega_N^{-Ls}} = \\frac{1 - 1^s}{1 - r} = 0\\) \\(\\to\\) (소멸 간섭) 항들이 복소평면에서 서로를 상쇄하여 합이 \\(0\\)이 됩니다.\n결론: \\(\\hat{g}(s)\\)는 \\(s\\)가 \\(N/L\\)의 배수일 때만 \\(0\\)이 아닌 값을 갖습니다. 이것이 바로 “스파이크 트레인”의 수학적 정체입니다.\n\n\n\nShor 알고리즘이 실제로 풀어야 하는 현실적인 문제입니다.\n\n\\(M = N/L\\) 은 더 이상 정수가 아닙니다.\n각 색상은 \\(\\lfloor M \\rfloor\\) (내림) 또는 \\(\\lceil M \\rceil\\) (올림) 번 나타납니다.\n이 “글리치” 때문에, QFT 결과도 완벽한 “스파이크”가 되지 않고, \\(M=N/L\\)의 배수(이제 정수도 아님)에 “가장 가까운 정수”일 확률이 높습니다.\n\n즉, \\(s \\approx \\lfloor kM \\rceil = \\lfloor k \\cdot (N/L) \\rceil\\)\n\n\n\n\n\n다행히도, “좋은” \\(s\\) (즉, \\(s \\approx \\lfloor kM \\rceil\\))를 측정할 확률은 여전히 매우 높습니다. 이 확률의 하한선(lower bound)을 계산할 수 있습니다.\n\n\\(L \\nmid N\\)일 때 QFT 합계(\\(\\hat{g}(s)\\))는 완벽한 소멸 간섭을 일으키지 못하고 “누수(leakage)”됩니다.\n하지만 “좋은” \\(s\\)의 경우, \\(|\\delta| = |s - k(N/L)| \\le 1/2\\) 로 오차가 매우 작습니다.\n이 경우 QFT 합계 항들(\\(\\omega_N^{-jL\\delta}\\))은 복소평면에서 천천히 회전하며 “대체로” 같은 방향을 가리켜, 부분적인 보강 간섭을 일으킵니다.\n(증명) 이 합계의 크기 제곱, 즉 확률은 \\(\\Pr[\\text{\"좋은\" } s] = |\\hat{g}(s)|^2 \\ge \\left(\\frac{2}{\\pi}\\right)^2 = \\frac{4}{\\pi^2}\\) 임을 보일 수 있습니다.\n결론: \\(L \\nmid N\\)인 현실적인 경우에도, 연분수 알고리즘에 사용할 수 있는 “좋은” \\(s\\)를 측정할 확률이 최소 40.5%로 매우 높다는 것이 보장됩니다."
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html#part-1-쇼어-알고리즘의-핵심---주기-찾기-period-finding-over-z_n",
    "href": "posts/cs/shor-algorithm/index.html#part-1-쇼어-알고리즘의-핵심---주기-찾기-period-finding-over-z_n",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "",
    "text": "Shor 알고리즘은 양자 알고리즘과 정수론을 결합한 것입니다. 이 알고리즘의 양자적 핵심은 “주기 찾기(Period-Finding)”입니다.\n\n\n\n우리는 \\(F: Z_N \\to \\text{COLORS}\\) (여기서 \\(N=2^n\\)이라고 가정)를 구현하는 양자 오라클(Quantum Function, QF)에 접근할 수 있습니다.\n이 함수 \\(F\\)는 “\\(L\\)-주기성”을 갖는다고 약속되어 있습니다.\n\n즉, \\(\\forall x \\in Z_N, F(x) = F(x+L) = F(x+2L) = \\dots\\)\n더 엄밀하게는( \\(L|N\\) 가정 시), \\(F(x) = F(y) \\iff L | (y-x) \\pmod{N}\\) 입니다.\n\n예시: \\(L=4\\) 라면, 함수 \\(F\\)의 출력(색상)은 [R, G, B, Y] | [R, G, B, Y] | \\dots 와 같이 \\(0, 1, 2, 3\\) 이후로 계속 반복됩니다.\n목표: \\(F\\)는 고전적인 입력뿐 아니라 입력의 양자 중첩(superposition) 상태도 처리할 수 있습니다. 우리는 이 오라클을 사용해 \\(L\\)을 효율적으로 찾는 것이 목적입니다.\n\n\n\n\n이 주기 찾기 문제(\\(L\\)-Period Finding Problem)는 다음의 3단계로 해결할 수 있습니다.\n1단계: “Load” (중첩 상태 준비)\n\n두 개의 양자 레지스터(input, output)를 준비합니다.\nInput 레지스터에 Hadamard 게이트를 적용하여 유니폼 중첩(uniform superposition) 상태를 만듭니다.\n그 다음, 양자 오라클(QF)을 적용하여 함수 \\(F\\)의 결과값을 Output 레지스터에 “로드”합니다.\n시스템의 전체 상태는 다음과 같이 됩니다:\n\\[\\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |0\\rangle \\xrightarrow{QF} \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |F(x)\\rangle\\]\n\n2단계: “Measure” (Output 레지스터 측정)\n\n여기서, 우리는 Output 레지스터 (색상, \\(|F(x)\\rangle\\))만 먼저 측정합니다.\n함수 \\(F\\)는 \\(L\\)-주기적이므로, 각 색상(예: \\(C^*\\))은 정확히 \\(N/L\\)번 나타납니다 ( \\(L|N\\) 가정 시).\n따라서 어떤 특정 색상 \\(C^*\\)를 측정할 확률은 \\(\\frac{N/L}{N} = \\frac{1}{L}\\) 입니다.\n(중요) 측정이 일어나는 순간, 양자 상태는 붕괴(collapse)합니다. 만약 \\(C^*\\)가 측정되었다면, Input 레지스터의 상태는 \\(F(x)=C^*\\)를 만족하는 \\(x\\)값들의 균등한 중첩 상태로 붕괴합니다.\n즉, 어떤 \\(x_0\\) ( \\(F(x_0)=C^*\\) )에 대해, 붕괴된 상태는 다음과 같습니다:\n\\[|\\psi_{C^*}\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{(N/L)-1} |x_0 + kL\\rangle\\]\n\n3단계: “Q.F.T.” (Input 레지스터 변환 및 측정)\n\n이제 우리는 주기가 \\(L\\)인 Input 레지스터의 중첩 상태를 얻었습니다.\n이 상태에 양자 푸리에 변환 (QFT, 또는 DFT)을 적용합니다.\n주기적인 상태를 QFT하면, 그 결과는 “스파이크 트레인(Spike Train)” 형태가 됩니다. 즉, 특정 값들에서만 확률이 높게 나타납니다.\n이 “스파이크”들은 주기의 역수(\\(1/L\\))와 관련된, \\(N/L\\)의 배수가 되는 지점들( \\(k \\cdot \\frac{N}{L}\\) )에서만 나타나게 됩니다.\n이 QFT가 적용된 Input 레지스터를 최종적으로 측정하면, 우리는 \\(N/L\\)의 배수인 어떤 값 \\(s\\)를 얻게 됩니다.\n이 측정값 \\(s\\)는 \\(L\\)에 대한 강력한 “단서(clue)”가 됩니다. (예: \\(s \\approx \\frac{k \\cdot N}{L}\\))\n\n\n\n\n2단계에서 우리는 랜덤한 색상 \\(C^*\\)를 측정했습니다. 이로 인해 Input 레지스터의 상태는 \\(C^*\\)에 의존하는 \\(x_0\\)만큼 무작위로 평행이동(random translation)됩니다.\n질문: 이 “무작위 평행이동”이 우리가 \\(L\\)을 찾는 것을 방해하지 않을까요?\n답변 (Pleasing Fact): 전혀 방해하지 않습니다.\n수학적 원리 (QFT Shift Theorem): 어떤 함수 \\(f(x)\\)를 \\(Y\\)만큼 평행이동시킨 함수 \\(f^Y(x) = f(x+Y)\\)가 있다고 합시다. 이 둘을 각각 QFT(\\(\\mathcal{F}\\))하면, 그 결과는 다음과 같은 관계를 갖습니다:\n\\[\\mathcal{F}(f^Y)(s) = \\mathcal{F}(f)(s) \\cdot \\omega_N^{-sY} \\quad (\\text{단, } \\omega_N = e^{2\\pi i / N})\\]\n즉, 원본(\\(x\\)) 공간에서의 평행이동(\\(+Y\\))은 푸리에(\\(s\\)) 공간에서 위상(phase)의 변화(\\(\\cdot \\omega_N^{-sY}\\))만을 유발합니다.\n우리가 최종적으로 측정하는 것은 확률, 즉 QFT 계수의 크기 제곱(magnitude squared)입니다. 위상 인자 \\(\\omega_N^{-sY}\\)의 크기는 \\(|\\omega_N^{-sY}| = 1\\) 입니다.\n\\[\n|\\mathcal{F}(f^Y)(s)|^2 = |\\mathcal{F}(f)(s) \\cdot \\omega_N^{-sY}|^2 = |\\mathcal{F}(f)(s)|^2 \\cdot |\\omega_N^{-sY}|^2 = |\\mathcal{F}(f)(s)|^2\n\\]\n결론 (The Pleasing Fact): 어떤 랜덤 색상 \\(C^*\\)를 측정하든 (즉, 스파이크 트레인이 \\(x_0\\)만큼 아무리 무작위로 평행이동되든), 우리가 Input 레지스터에서 \\(s\\)를 측정할 최종 확률 분포는 \\(x_0\\)와 관계없이 모두 동일합니다!\n\n\n\n왜 QFT가 “스파이크 트레인”을 만들까요? 3단계에서 \\(x_0=0\\) (평행이동 무시)으로 가정한 Input 상태 \\(g(x)\\)의 QFT \\(\\hat{g}(s)\\)를 계산해 봅시다.\n\nInput 상태: \\(g(x) = \\begin{cases} 1 & \\text{if } x \\in \\{0, L, 2L, \\dots\\} \\\\ 0 & \\text{else} \\end{cases}\\)\nQFT: \\(\\hat{g}(s) = \\sum_{x=0}^{N-1} g(x) \\cdot \\omega_N^{-xs} = \\sum_{j=0}^{(N/L)-1} \\omega_N^{-(jL)s}\\)\n\n경우 1: \\(s\\)가 \\(N/L\\)의 배수인 경우 ( \\(s = k \\cdot (N/L)\\) ) \\(\\omega_N^{-jLs} = \\omega_N^{-jL \\cdot k(N/L)} = \\omega_N^{-jkN} = ( \\omega_N^N )^{-jk} = 1^{-jk} = 1\\). \\(\\hat{g}(s) = \\sum_{j=0}^{(N/L)-1} 1 = N/L\\) \\(\\to\\) (보강 간섭) 모든 항이 \\(1\\)이 되어 합이 최대가 됩니다.\n경우 2: \\(s\\)가 \\(N/L\\)의 배수가 아닌 경우 이때 \\(L \\cdot s\\)는 \\(N\\)의 배수가 아니므로 \\(r = \\omega_N^{-Ls} \\neq 1\\) 입니다. 등비수열의 합은 0이 됩니다. \\(\\hat{g}(s) = \\frac{1 - (\\omega_N^{-Ls})^{N/L}}{1 - \\omega_N^{-Ls}} = \\frac{1 - (\\omega_N^{-N})^s}{1 - \\omega_N^{-Ls}} = \\frac{1 - 1^s}{1 - r} = 0\\) \\(\\to\\) (소멸 간섭) 항들이 복소평면에서 서로를 상쇄하여 합이 \\(0\\)이 됩니다.\n결론: \\(\\hat{g}(s)\\)는 \\(s\\)가 \\(N/L\\)의 배수일 때만 \\(0\\)이 아닌 값을 갖습니다. 이것이 바로 “스파이크 트레인”의 수학적 정체입니다.\n\n\n\nShor 알고리즘이 실제로 풀어야 하는 현실적인 문제입니다.\n\n\\(M = N/L\\) 은 더 이상 정수가 아닙니다.\n각 색상은 \\(\\lfloor M \\rfloor\\) (내림) 또는 \\(\\lceil M \\rceil\\) (올림) 번 나타납니다.\n이 “글리치” 때문에, QFT 결과도 완벽한 “스파이크”가 되지 않고, \\(M=N/L\\)의 배수(이제 정수도 아님)에 “가장 가까운 정수”일 확률이 높습니다.\n\n즉, \\(s \\approx \\lfloor kM \\rceil = \\lfloor k \\cdot (N/L) \\rceil\\)\n\n\n\n\n\n다행히도, “좋은” \\(s\\) (즉, \\(s \\approx \\lfloor kM \\rceil\\))를 측정할 확률은 여전히 매우 높습니다. 이 확률의 하한선(lower bound)을 계산할 수 있습니다.\n\n\\(L \\nmid N\\)일 때 QFT 합계(\\(\\hat{g}(s)\\))는 완벽한 소멸 간섭을 일으키지 못하고 “누수(leakage)”됩니다.\n하지만 “좋은” \\(s\\)의 경우, \\(|\\delta| = |s - k(N/L)| \\le 1/2\\) 로 오차가 매우 작습니다.\n이 경우 QFT 합계 항들(\\(\\omega_N^{-jL\\delta}\\))은 복소평면에서 천천히 회전하며 “대체로” 같은 방향을 가리켜, 부분적인 보강 간섭을 일으킵니다.\n(증명) 이 합계의 크기 제곱, 즉 확률은 \\(\\Pr[\\text{\"좋은\" } s] = |\\hat{g}(s)|^2 \\ge \\left(\\frac{2}{\\pi}\\right)^2 = \\frac{4}{\\pi^2}\\) 임을 보일 수 있습니다.\n결론: \\(L \\nmid N\\)인 현실적인 경우에도, 연분수 알고리즘에 사용할 수 있는 “좋은” \\(s\\)를 측정할 확률이 최소 40.5%로 매우 높다는 것이 보장됩니다."
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html#part-2-쇼어의-소인수분해-알고리즘-factoring-algorithm",
    "href": "posts/cs/shor-algorithm/index.html#part-2-쇼어의-소인수분해-알고리즘-factoring-algorithm",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "Part 2: 쇼어의 소인수분해 알고리즘 (Factoring Algorithm)",
    "text": "Part 2: 쇼어의 소인수분해 알고리즘 (Factoring Algorithm)\n이제 Part 1에서 완성한 “주기 찾기” 알고리즘을 무기로 사용하여, 고전적으로 풀기 어려운 소인수분해(Factoring) 문제를 풉니다.\n\n7. 소인수분해 문제를 “주기 찾기”로 환원(Reduction)하기\nShor의 핵심 아이디어는 1970년대에 이미 알려진 고전 정수론을 활용한 것입니다.\n\n문제: \\(m\\)비트의 큰 합성수 \\(B=pq\\)를 소인수분해하라.\n핵심 환원: 이 문제는 \\(Z_B^*\\)에서 “1의 비자명 제곱근 \\(R\\)”을 찾는 것과 같습니다.\n\n비자명 제곱근(Non-trivial Square Root): \\(R^2 \\equiv 1 \\pmod{B}\\) 이지만, \\(R \\not\\equiv \\pm 1 \\pmod{B}\\) 인 \\(R\\).\n\n“열쇠” \\(R\\)이 “자물쇠” \\(B\\)를 여는 방법 (The GCD Trick):\n\n만약 \\(R\\)을 찾는다면, \\(R^2 - 1 \\equiv 0 \\pmod{B}\\) \\(\\implies\\) \\((R-1)(R+1) \\equiv 0 \\pmod{pq}\\) 입니다.\n\\(R\\)이 비자명하므로, \\(p\\)와 \\(q\\)는 두 인수 \\((R-1)\\)과 \\((R+1)\\)에 나누어 들어가야만 합니다. (예: \\(p | (R-1)\\) 이고 \\(q | (R+1)\\))\n[Aha!] 이 상태에서 \\(\\gcd(R-1, B) = \\gcd(R-1, pq)\\) 를 고전적으로 계산하면, 공통 인수 \\(p\\)가 즉시 나옵니다.\n\n\n\n\n8. “열쇠” \\(R\\)을 “주기” \\(L\\)로 찾기\n이제 문제는 “어떻게 \\(R\\)을 찾는가?”로 좁혀졌습니다.\n\n[Random Sampling] \\(B\\)와 서로소인 임의의 수 \\(A\\)를 고릅니다 ( \\(1 &lt; A &lt; B\\) ).\n[The Function] \\(A\\)를 밑(base)으로 하는 다음 함수 \\(F_A(x)\\)를 정의합니다: \\[F_A(x) = A^x \\pmod{B}\\]\n[The Period “L”] 이 함수는 주기적입니다. 이 함수의 주기 \\(L\\)은 \\(A^L \\equiv 1 \\pmod{B}\\) 를 만족하는 가장 작은 양의 정수 \\(L\\) ( \\(A\\)의 “차수(order)”)입니다.\n[The Final Link] Part 1의 양자 알고리즘으로 이 주기 \\(L\\)을 찾았다고 합시다.\n\n만약 \\(L\\)이 짝수라면 (랜덤 \\(A\\)에 대해 그럴 확률이 높음), \\(A^L \\equiv 1 \\pmod{B}\\) 는 \\((A^{L/2})^2 \\equiv 1 \\pmod{B}\\) 로 쓸 수 있습니다.\n“열쇠” \\(R\\)을 찾았습니다! \\(\\implies R = A^{L/2}\\)\n이 \\(R\\)은 \\(L\\)이 최소 주기이므로 \\(R \\not\\equiv 1 \\pmod{B}\\) 임이 보장됩니다.\n\\(R \\not\\equiv -1 \\pmod{B}\\) 일 확률(즉, 비자명할 확률)도 50% 이상임이 알려져 있습니다 (아래 10번 참조).\n\n\n최종 환원: 소인수분해(\\(B\\)) \\(\\to\\) 비자명 제곱근(\\(R\\)) 찾기 \\(\\to\\) \\(A^x \\pmod{B}\\)의 주기(\\(L\\)) 찾기 \\(\\to\\) Part 1의 양자 주기 찾기 알고리즘 사용!\n\n\n9. 양자적 병목 현상 및 \\(n \\ge 2m+1\\) 조건\n\n[병목] 우리가 양자 컴퓨터로 구현할 \\(F_A(x) = A^x \\pmod{B}\\) (모듈러 지수 연산)은 “제곱-곱셈” 알고리즘을 사용하며, 약 \\(O(m^3)\\) (\\(m = \\log B\\)) 개의 게이트를 필요로 합니다. 이것이 Shor 알고리즘의 양자적 병목 현상입니다.\n[정밀도] \\(L\\)을 찾는 주기 찾기 알고리즘(Part 1)이 \\(\\frac{s}{N} \\approx \\frac{k}{L}\\) 라는 근사값을 고전적인 “연분수 알고리즘”으로 풀 수 있으려면, Input 레지스터의 크기 \\(n\\) (\\(N=2^n\\))이 \\(L\\)에 비해 압도적으로 커야 합니다.\n[조건 증명] \\(L\\)은 \\(B \\approx 2^m\\) 보다 작습니다. 정수론에 따르면, 분모가 \\(B\\)보다 작은 두 다른 분수 \\(k/L\\), \\(k'/L'\\)의 차이는 \\(|\\frac{k}{L} - \\frac{k'}{L'}| &gt; \\frac{1}{B^2} \\approx \\frac{1}{2^{2m}}\\) 입니다. 우리의 알고리즘 오차 \\(\\epsilon = |\\frac{S}{N} - \\frac{k}{L}| \\le \\frac{1}{2N} = \\frac{1}{2^{n+1}}\\) 입니다. 연분수 알고리즘이 “가짜 답”과 “진짜 답”을 구별하려면, 오차(\\(\\epsilon\\))가 두 답 사이의 최소 거리(\\(1/B^2\\))보다 작아야 합니다. \\(\\frac{1}{2^{n+1}} &lt; \\frac{1}{2^{2m}} \\implies n+1 &gt; 2m \\implies n \\ge 2m+1\\) \\(\\to\\) \\(m\\)비트 숫자를 소인수분해하려면 최소 \\(n=2m+1\\) 비트의 Input 레지스터가 필요합니다.\n\n\n\n10. 고전적 “운(Luck)”과 성공 확률 (최소 50%)\n양자 컴퓨터가 주기 \\(L\\)을 성공적으로 찾아냈다고 해도, 이 \\(L\\)이 “쓸모없는” 값일 수 있습니다.\n\n실패 1: \\(L\\)이 홀수일 때 ( \\(A^{L/2}\\) 계산 불가)\n실패 2: \\(R = A^{L/2} \\equiv -1 \\pmod{B}\\) 일 때 ( \\(\\gcd(R-1, B)\\)가 \\(B\\)가 되어 실패)\n\n다행히도, 이 두 가지 실패를 모두 피할 확률은 최소 50%입니다.\n\n[증명 (CRT)] 중국인의 나머지 정리(CRT)에 따르면, \\(Z_B^* \\cong Z_p^* \\times Z_q^*\\) 입니다.\n\\(L = \\text{lcm}(L_p, L_q)\\)가 홀수일 경우는 \\(L_p, L_q\\)가 모두 홀수일 때뿐입니다. \\(Z_p^*\\) (짝수 크기의 순환군)에서 \\(L_p\\)가 홀수일 확률은 1/2입니다.\n\\(\\Pr[L\\text{ is odd}] = \\Pr[L_p\\text{ odd}] \\times \\Pr[L_q\\text{ odd}] = (1/2) \\times (1/2) = 1/4\\).\n\\(\\Pr[L\\text{ is even (1차 성공)}] = 1 - 1/4 = 3/4\\).\n\\(L\\)이 짝수일 때 2차 실패(\\(R \\equiv -1\\))가 일어날 확률은 최대 1/2입니다.\n\\(\\Pr[\\text{최종 성공}] = \\Pr[\\text{성공 1}] \\times \\Pr[\\text{성공 2} \\mid \\text{성공 1}] \\ge (3/4) \\times (1/2) = 3/8\\). (더 엄밀한 분석은 \\(\\ge 1/2\\)을 보입니다.)\n결론: 몇 번만 반복하면 “좋은 \\(A\\)”를 뽑을 수 있습니다.\n\n\n\n11. 최종 고전 후처리: 연분수 알고리즘 (Continued Fractions)\nShor 알고리즘의 마지막 단계는 순수하게 고전적입니다.\n\n상황: 우리는 \\(S\\)와 \\(N=2^n\\)을 압니다.\n가정: \\(S\\)가 \\(\\ge 40.5\\%\\) 확률로 “좋은 단서”(\\(|\\frac{S}{N} - \\frac{k}{L}| \\le \\frac{1}{2N}\\))라고 일단 가정합니다.\n알고리즘: \\(\\frac{S}{N}\\) (소수)를 연분수 알고리즘에 입력합니다.\n작동 원리: 이 알고리즘은 유클리드 호제법(GCD)을 사용하여 \\(\\frac{S}{N}\\)를 가장 잘 근사하는 “최적의 분수” \\(\\frac{k'}{L'}\\)를 효율적으로 찾습니다.\n\n(예) \\(\\gcd(N, S)\\) 계산 시: \\(N = q_1 S + r_1 \\implies S = q_2 r_1 + r_2 \\dots\\)\n이 몫(\\(q_i\\))들이 연분수 전개의 계수가 되며, \\(n \\ge 2m+1\\) 조건 덕분에 오차가 누적되어도 \\(\\frac{k'}{L'}\\)는 \\(\\frac{k}{L}\\)와 정확히 일치함이 보장됩니다.\n\n검증 (Verify):\n\n찾아낸 \\(L'\\)를 이용해 \\(A^{L'} \\equiv 1 \\pmod{B}\\) 인지 고전적으로 검증합니다.\n만약 \\(1\\)이 아니면, \\(S\\)가 “Junk”였다는 뜻이므로, 알고리즘을 다른 \\(A\\) (또는 새 \\(S\\))로 다시 시작합니다.\n\\(1\\)이 맞다면, \\(L'\\)는 유효한 주기입니다. 10단계의 “운”을 테스트(홀수/짝수, \\(-1\\) 여부)합니다.\n통과 시, \\(p = \\gcd(A^{L'/2}-1, B)\\) 를 계산하여 소인수를 찾습니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  },
  {
    "objectID": "index.html#분야별-탐구",
    "href": "index.html#분야별-탐구",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  }
]