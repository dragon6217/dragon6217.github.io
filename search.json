[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html",
    "href": "posts/cs/shor-algorithm/index.html",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "",
    "text": "쇼어 알고리즘(Shor’s algorithm)은 양자 컴퓨터를 사용하여 매우 큰 수의 소인수를 찾는 양자 알고리즘입니다. 1994년 피터 쇼어(Peter Shor)에 의해 발견되었으며, 현대 암호학의 근간이 되는 RSA 암호체계를 무너뜨릴 수 있는 잠재력 때문에 큰 주목을 받았습니다.\n이 알고리즘의 핵심은 위상 추정(Phase Estimation)과 양자 푸리에 변환(QFT)을 사용하여 함수의 주기성을 찾는 것입니다.\n\n\n쇼어 알고리즘은 크게 두 부분으로 나뉩니다: 고전적인 부분과 양자적인 부분.\n\n고전적인 사전 단계 (Classical Part)\n\n소인수분해할 숫자 \\(N\\)을 고릅니다.\n\\(N\\)과 서로소인 임의의 숫자 \\(a &lt; N\\)를 선택합니다.\n\\(f(x) = a^x \\mod N\\) 라는 함수의 ‘주기(period)’ \\(r\\)을 찾는 것이 목표입니다.\n\n양자적 핵심 단계 (Quantum Part)\n\n양자 중첩 상태를 준비합니다.\n\\(f(x)\\)를 계산하는 양자 연산을 수행합니다.\n양자 푸리에 변환 (QFT)을 적용하여 주기 \\(r\\)을 높은 확률로 찾아냅니다.\n\n\n\n\n\n만약 \\(r\\)이 \\(f(x) = a^x \\mod N\\)의 주기라면, 다음이 성립합니다:\n\\[ a^r \\equiv 1 \\pmod{N} \\]\n만약 \\(r\\)이 짝수라면, 식을 다음과 같이 변형할 수 있습니다:\n\\[ (a^{r/2} - 1)(a^{r/2} + 1) \\equiv 0 \\pmod{N} \\]\n이는 \\((a^{r/2} - 1)(a^{r/2} + 1)\\)이 \\(N\\)의 배수라는 뜻입니다.\n따라서 \\(\\gcd(a^{r/2} \\pm 1, N)\\)을 계산하면 \\(N\\)의 소인수를 찾을 가능성이 매우 높습니다."
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html#쇼어-알고리즘이란",
    "href": "posts/cs/shor-algorithm/index.html#쇼어-알고리즘이란",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "",
    "text": "쇼어 알고리즘(Shor’s algorithm)은 양자 컴퓨터를 사용하여 매우 큰 수의 소인수를 찾는 양자 알고리즘입니다. 1994년 피터 쇼어(Peter Shor)에 의해 발견되었으며, 현대 암호학의 근간이 되는 RSA 암호체계를 무너뜨릴 수 있는 잠재력 때문에 큰 주목을 받았습니다.\n이 알고리즘의 핵심은 위상 추정(Phase Estimation)과 양자 푸리에 변환(QFT)을 사용하여 함수의 주기성을 찾는 것입니다.\n\n\n쇼어 알고리즘은 크게 두 부분으로 나뉩니다: 고전적인 부분과 양자적인 부분.\n\n고전적인 사전 단계 (Classical Part)\n\n소인수분해할 숫자 \\(N\\)을 고릅니다.\n\\(N\\)과 서로소인 임의의 숫자 \\(a &lt; N\\)를 선택합니다.\n\\(f(x) = a^x \\mod N\\) 라는 함수의 ‘주기(period)’ \\(r\\)을 찾는 것이 목표입니다.\n\n양자적 핵심 단계 (Quantum Part)\n\n양자 중첩 상태를 준비합니다.\n\\(f(x)\\)를 계산하는 양자 연산을 수행합니다.\n양자 푸리에 변환 (QFT)을 적용하여 주기 \\(r\\)을 높은 확률로 찾아냅니다.\n\n\n\n\n\n만약 \\(r\\)이 \\(f(x) = a^x \\mod N\\)의 주기라면, 다음이 성립합니다:\n\\[ a^r \\equiv 1 \\pmod{N} \\]\n만약 \\(r\\)이 짝수라면, 식을 다음과 같이 변형할 수 있습니다:\n\\[ (a^{r/2} - 1)(a^{r/2} + 1) \\equiv 0 \\pmod{N} \\]\n이는 \\((a^{r/2} - 1)(a^{r/2} + 1)\\)이 \\(N\\)의 배수라는 뜻입니다.\n따라서 \\(\\gcd(a^{r/2} \\pm 1, N)\\)을 계산하면 \\(N\\)의 소인수를 찾을 가능성이 매우 높습니다."
  },
  {
    "objectID": "posts/cs/shor-algorithm/index.html#결론",
    "href": "posts/cs/shor-algorithm/index.html#결론",
    "title": "쇼어 알고리즘 (Shor’s Algorithm)",
    "section": "결론",
    "text": "결론\n(여기에 포스트의 결론을 작성합니다.)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  },
  {
    "objectID": "index.html#분야별-탐구",
    "href": "index.html#분야별-탐구",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  }
]