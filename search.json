[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "posts/cs/compiler/1-cfg/index.html",
    "href": "posts/cs/compiler/1-cfg/index.html",
    "title": "컴파일러 백엔드 시리즈 1부: 제어 흐름 그래프(CFG) 구축하기",
    "section": "",
    "text": "컴파일러 백엔드에서 수행하는 모든 분석과 최적화의 첫걸음은 코드를 의미 있는 단위로 나누는 것입니다. 그 가장 기본적인 단위가 바로 기본 블록(Basic Block)입니다.\n\n기본 블록(Basic Block)이란? “단일 진입점(Single Entry), 단일 진출점(Single Exit)” 원칙을 따르는 명령어의 연속된 시퀀스입니다. 1. 단일 진입점: 코드의 맨 위에서부터 실행되거나, 다른 블록에서의 점프(jump) 대상이 되는 ‘리더(leader)’ 명령어로만 진입이 가능합니다. 블록 중간으로 점프해 들어올 수 없습니다. 2. 단일 진출점: 블록의 가장 마지막 명령어를 실행하면, 다음 블록으로 제어가 넘어갑니다. 블록 중간에서 밖으로 점프해 나갈 수 없습니다.\n\nform_blocks.py의 유일한 임무는 Bril의 선형적인 명령어 리스트를 입력받아, 이 기본 블록 원칙에 따라 여러 개의 블록 리스트로 분할하는 것입니다.\n\n\n이 스크립트는 Bril 명령어 리스트(instrs)를 처음부터 끝까지 단 한 번 선형 스캔(linear scan)하면서 블록을 나눕니다. 블록을 나누는 기준은 매우 명확하며, 다음 두 가지 규칙을 따릅니다.\n\nTerminators (종결자): br (분기), jmp (무조건 점프), ret (반환) 명령어는 현재 블록의 마지막 명령어입니다. 이 명령어를 만나면 현재 블록을 닫고 다음 명령어부터 새 블록을 시작합니다.\nLabels (레이블): 레이블은 항상 새로운 블록의 시작입니다. 따라서 레이블을 만나면, (만약 그전까지의 블록에 내용이 있었다면) 그전까지의 블록을 닫고, 이 레이블부터 새로운 블록을 시작합니다.\n\n핵심 로직은 form_blocks 함수에 있으며, Python의 제너레이터(generator)로 구현되어 있어 메모리 효율적입니다.\n# Instructions that terminate a basic block.\nTERMINATORS = 'br', 'jmp', 'ret'\n\n\ndef form_blocks(instrs):\n    \"\"\"Given a list of Bril instructions, generate a sequence of\n    instruction lists representing the basic blocks in the program.\n    \"\"\"\n\n    # Start with an empty block.\n    cur_block = []\n\n    for instr in instrs:\n        if 'op' in instr:  # It's an instruction.\n            # Add the instruction to the currently-being-formed block.\n            cur_block.append(instr)\n\n            # If this is a terminator (branching instruction), it's the\n            # last instruction in the block. Finish this block and\n            # start a new one.\n            if instr['op'] in TERMINATORS:\n                yield cur_block\n                cur_block = []\n\n        else:  # It's a label.\n            # End the block here (if it contains anything).\n            if cur_block:\n                yield cur_block\n\n            # Start a new block with the label.\n            cur_block = [instr]\n\n    # Produce the final block, if any.\n    if cur_block:\n        yield cur_block\n\n\n\n\ncur_block: 현재 구성 중인 기본 블록(명령어 리스트)을 임시로 저장하는 변수입니다.\nif 'op' in instr:: Bril에서 명령어(instruction)는 op 키를 가지고, 레이블(label)은 label 키를 가집니다. 이 라인은 현재 항목이 명령어인지 확인합니다.\n\n명령어라면 cur_block에 추가합니다.\n만약 이 명령어가 TERMINATORS 중 하나라면, 이 명령어는 현재 블록의 마지막이므로 yield 키워드를 사용해 cur_block을 반환하고, cur_block을 비워 새 블록을 준비합니다.\n\nelse:: 레이블을 만난 경우입니다. 레이블은 새로운 블록의 시작입니다.\n\nif cur_block:: 만약 레이블을 만나기 직전까지 cur_block에 명령어가 있었다면 (즉, 이전 블록이 종결자 없이 끝난 경우), 해당 블록을 yield로 반환하여 먼저 종료시킵니다.\ncur_block = [instr]: 이 레이블을 첫 번째 항목으로 하는 새로운 cur_block을 시작합니다.\n\nif cur_block: (루프 종료 후): 마지막 블록이 ret 같은 종결자로 끝나지 않았을 경우, 루프가 끝난 뒤 cur_block에 남아있는 명령어가 있을 수 있습니다. 이를 마지막 블록으로 반환합니다."
  },
  {
    "objectID": "posts/cs/compiler/1-cfg/index.html#기본-블록-basic-block-생성-cfg의-기초",
    "href": "posts/cs/compiler/1-cfg/index.html#기본-블록-basic-block-생성-cfg의-기초",
    "title": "컴파일러 백엔드 시리즈 1부: 제어 흐름 그래프(CFG) 구축하기",
    "section": "",
    "text": "컴파일러 백엔드에서 수행하는 모든 분석과 최적화의 첫걸음은 코드를 의미 있는 단위로 나누는 것입니다. 그 가장 기본적인 단위가 바로 기본 블록(Basic Block)입니다.\n\n기본 블록(Basic Block)이란? “단일 진입점(Single Entry), 단일 진출점(Single Exit)” 원칙을 따르는 명령어의 연속된 시퀀스입니다. 1. 단일 진입점: 코드의 맨 위에서부터 실행되거나, 다른 블록에서의 점프(jump) 대상이 되는 ‘리더(leader)’ 명령어로만 진입이 가능합니다. 블록 중간으로 점프해 들어올 수 없습니다. 2. 단일 진출점: 블록의 가장 마지막 명령어를 실행하면, 다음 블록으로 제어가 넘어갑니다. 블록 중간에서 밖으로 점프해 나갈 수 없습니다.\n\nform_blocks.py의 유일한 임무는 Bril의 선형적인 명령어 리스트를 입력받아, 이 기본 블록 원칙에 따라 여러 개의 블록 리스트로 분할하는 것입니다.\n\n\n이 스크립트는 Bril 명령어 리스트(instrs)를 처음부터 끝까지 단 한 번 선형 스캔(linear scan)하면서 블록을 나눕니다. 블록을 나누는 기준은 매우 명확하며, 다음 두 가지 규칙을 따릅니다.\n\nTerminators (종결자): br (분기), jmp (무조건 점프), ret (반환) 명령어는 현재 블록의 마지막 명령어입니다. 이 명령어를 만나면 현재 블록을 닫고 다음 명령어부터 새 블록을 시작합니다.\nLabels (레이블): 레이블은 항상 새로운 블록의 시작입니다. 따라서 레이블을 만나면, (만약 그전까지의 블록에 내용이 있었다면) 그전까지의 블록을 닫고, 이 레이블부터 새로운 블록을 시작합니다.\n\n핵심 로직은 form_blocks 함수에 있으며, Python의 제너레이터(generator)로 구현되어 있어 메모리 효율적입니다.\n# Instructions that terminate a basic block.\nTERMINATORS = 'br', 'jmp', 'ret'\n\n\ndef form_blocks(instrs):\n    \"\"\"Given a list of Bril instructions, generate a sequence of\n    instruction lists representing the basic blocks in the program.\n    \"\"\"\n\n    # Start with an empty block.\n    cur_block = []\n\n    for instr in instrs:\n        if 'op' in instr:  # It's an instruction.\n            # Add the instruction to the currently-being-formed block.\n            cur_block.append(instr)\n\n            # If this is a terminator (branching instruction), it's the\n            # last instruction in the block. Finish this block and\n            # start a new one.\n            if instr['op'] in TERMINATORS:\n                yield cur_block\n                cur_block = []\n\n        else:  # It's a label.\n            # End the block here (if it contains anything).\n            if cur_block:\n                yield cur_block\n\n            # Start a new block with the label.\n            cur_block = [instr]\n\n    # Produce the final block, if any.\n    if cur_block:\n        yield cur_block\n\n\n\n\ncur_block: 현재 구성 중인 기본 블록(명령어 리스트)을 임시로 저장하는 변수입니다.\nif 'op' in instr:: Bril에서 명령어(instruction)는 op 키를 가지고, 레이블(label)은 label 키를 가집니다. 이 라인은 현재 항목이 명령어인지 확인합니다.\n\n명령어라면 cur_block에 추가합니다.\n만약 이 명령어가 TERMINATORS 중 하나라면, 이 명령어는 현재 블록의 마지막이므로 yield 키워드를 사용해 cur_block을 반환하고, cur_block을 비워 새 블록을 준비합니다.\n\nelse:: 레이블을 만난 경우입니다. 레이블은 새로운 블록의 시작입니다.\n\nif cur_block:: 만약 레이블을 만나기 직전까지 cur_block에 명령어가 있었다면 (즉, 이전 블록이 종결자 없이 끝난 경우), 해당 블록을 yield로 반환하여 먼저 종료시킵니다.\ncur_block = [instr]: 이 레이블을 첫 번째 항목으로 하는 새로운 cur_block을 시작합니다.\n\nif cur_block: (루프 종료 후): 마지막 블록이 ret 같은 종결자로 끝나지 않았을 경우, 루프가 끝난 뒤 cur_block에 남아있는 명령어가 있을 수 있습니다. 이를 마지막 블록으로 반환합니다."
  },
  {
    "objectID": "posts/cs/compiler/1-cfg/index.html#제어-흐름-그래프-cfg-구축",
    "href": "posts/cs/compiler/1-cfg/index.html#제어-흐름-그래프-cfg-구축",
    "title": "컴파일러 백엔드 시리즈 1부: 제어 흐름 그래프(CFG) 구축하기",
    "section": "2. 제어 흐름 그래프 (CFG) 구축",
    "text": "2. 제어 흐름 그래프 (CFG) 구축\n앞선 단계에서 우리는 선형적인 코드를 여러 개의 ‘기본 블록’ 덩어리로 분리했습니다. 하지만 이 블록들은 아직 이름도 없고 서로 어떻게 연결되어 있는지도 모르는, 말 그대로 ’명령어 리스트의 리스트’일 뿐입니다. cfg.py의 역할은 이 블록들에 고유한 이름을 부여하고, 블록 간의 제어 흐름(간선)을 명시적으로 찾아내어 ‘전임자(predecessors)’와 ‘후임자(successors)’ 목록을 가진 완전한 그래프 자료구조를 만드는 것입니다.\n\ncfg.py 핵심 로직 분석\nCFG 구축은 다음 세 가지 주요 단계를 통해 이루어집니다.\n\n1단계: 블록 맵 생성 (block_map) 가장 먼저, 각 기본 블록(노드)을 식별할 고유한 이름이 필요합니다. block_map 함수는 form_blocks에서 생성된 블록 리스트를 순회하며 OrderedDict 자료구조를 생성합니다.\n\n레이블이 있는 블록: block[0](블록의 첫 번째 항목)이 레이블이면, 해당 레이블을 블록의 이름으로 사용하고 명령어 목록에서 레이블을 제거합니다.\n익명 블록(Anonymous Block): 레이블이 없는 블록(예: jmp나 br 바로 다음의 블록)은 fresh('b', ...) 유틸리티 함수를 호출하여 b1, b2와 같이 충돌하지 않는 새 이름을 부여받습니다.\n\n\ndef block_map(blocks):\n    \"\"\"Given a sequence of basic blocks, which are lists of instructions,\n    produce a `OrderedDict` mapping names to blocks.\n    ...\n    \"\"\"\n    by_name = OrderedDict()\n\n    for block in blocks:\n        # Generate a name for the block.\n        if 'label' in block[0]:\n            # The block has a label. Remove the label but use it for the\n            # block's name.\n            name = block[0]['label']\n            block = block[1:]\n        else:\n            # Make up a new name for this anonymous block.\n            name = fresh('b', by_name)\n\n        # Add the block to the mapping.\n        by_name[name] = block\n\n    return by_name\n\n\n2단계: 암묵적 제어 흐름 명시화 (add_terminators)\nform_blocks 단계에서 생성된 블록 중 일부는 br, jmp, ret 같은 종결자(Terminator) 명령어 없이 끝날 수 있습니다. 이는 “실행이 끝나면 코딩된 순서상의 다음 블록으로 암묵적으로 넘어간다(fall-through)”는 의미입니다. 하지만 그래프 분석을 위해서는 모든 제어 흐름이 명시적(explicit)이어야 합니다.\nadd_terminators 함수는 block_map을 순회하며 종결자가 없는 모든 블록을 찾아내어 명시적인 jmp 또는 ret 명령어를 추가합니다.\n\n종결자가 없으면서 마지막 블록이 아니면: 다음 블록으로 가는 jmp를 추가합니다.\n종결자가 없으면서 마지막 블록이면: ret를 추가합니다.\n\ndef add_terminators(blocks):\n    \"\"\"Given an ordered block map, modify the blocks to add terminators\n    to all blocks (avoiding \"fall-through\" control flow transfers).\n    \"\"\"\n    for i, block in enumerate(blocks.values()):\n        # ... (Check for empty blocks removed for brevity) ...\n        if block[-1]['op'] not in TERMINATORS:\n            if i == len(blocks) - 1:\n                block.append({'op': 'ret', 'args': []})\n            else:\n                # Otherwise, jump to the next block.\n                dest = list(blocks.keys())[i + 1]\n                block.append({'op': 'jmp', 'labels': [dest]})\n\n💡 중요: 이 add_terminators 단계가 완료된 시점에서, 각 블록의 마지막 명령어는 반드시 br, jmp, ret 중 하나가 되며, 이 명령어가 해당 블록에서 나가는 모든 간선(edge) 정보를 담고 있게 됩니다.\n\n\n\n3단계: 간선 생성 (edges)\n이제 모든 블록이 이름과 명시적인 종결자를 가졌으므로, 실제 그래프(간선)를 만들 수 있습니다. edges 함수는 blocks 맵을 순회하며 각 블록의 종결자(block[-1])를 검사합니다.\n\nsuccessors 헬퍼 함수를 통해 종결자에 포함된 labels (대상 레이블) 목록을 가져옵니다.\nsuccs[name].append(succ): 현재 블록(name)의 후임자(successor) 목록에 대상 레이블(succ)을 추가합니다.\npreds[succ].append(name): 대상 레이블 블록(succ)의 전임자(predecessor) 목록에 현재 블록(name)을 추가합니다.\n\ndef successors(instr):\n    \"\"\"Get the list of jump target labels for an instruction.\n    ...\n    \"\"\"\n    if instr['op'] in ('jmp', 'br'):\n        return instr['labels']\n    elif instr['op'] == 'ret':\n        return []  # No successors to an exit block.\n    # ...\n\ndef edges(blocks):\n    \"\"\"Given a block map containing blocks complete with terminators,\n    generate two mappings: predecessors and successors. Both map block\n    names to lists of block names.\n    \"\"\"\n    preds = {name: [] for name in blocks}\n    succs = {name: [] for name in blocks}\n    for name, block in blocks.items():\n        for succ in successors(block[-1]):\n            succs[name].append(succ)\n            preds[succ].append(name)\n    return preds, succs"
  },
  {
    "objectID": "posts/cs/compiler/1-cfg/index.html#cfg-시각화-graphviz",
    "href": "posts/cs/compiler/1-cfg/index.html#cfg-시각화-graphviz",
    "title": "컴파일러 백엔드 시리즈 1부: 제어 흐름 그래프(CFG) 구축하기",
    "section": "3. CFG 시각화 (Graphviz)",
    "text": "3. CFG 시각화 (Graphviz)\nCFG는 그래프 자료구조이므로, 텍스트로만 파악하기는 매우 어렵습니다. 특히 복잡한 분기문(if/else)이나 루프(loop)가 포함된 경우, 그래프를 시각화하는 것은 필수적입니다.\ncfg_dot.py 스크립트는 cfg.py에서 만든 CFG(블록 맵)를 입력받아, Graphviz라는 그래프 시각화 도구가 읽을 수 있는 DOT 언어 스크립트를 생성합니다.\n\ncfg_dot.py 핵심 로직 분석\n이 스크립트의 cfg_dot 함수는 이전에 우리가 정의한 함수들을 순서대로 호출합니다.\n\nblocks = block_map(form_blocks(func['instrs'])): Bril 함수로부터 기본 블록을 만들고, block_map을 호출하여 이름이 부여된 블록 맵을 생성합니다.\nadd_terminators(blocks): cfg.py에서 봤던 함수를 호출하여 모든 블록이 명시적인 종결자(간선 정보)를 갖도록 보장합니다.\n정점(Vertices) 출력: blocks.items()를 순회하며 DOT 파일에 노드(정점)를 정의합니다.\n\n-v (verbose) 옵션이 켜져 있으면, 노드를 사각형(shape=box)으로 그리고 label 속성에 해당 블록의 모든 Bril 명령어를 \\l (왼쪽 정렬 줄바꿈)로 엮어 함께 출력합니다.\n\n간선(Edges) 출력: blocks.items()를 다시 순회하며 각 블록의 마지막 명령어(block[-1])에 대해 successors 함수를 호출하여 현재블록 -&gt; 후임자블록; 형태의 DOT 간선(화살표)을 출력합니다.\n\ndef cfg_dot(bril, verbose):\n    \"\"\"Generate a GraphViz \"dot\" file showing the control flow graph for\n    a Bril program.\n    ...\n    \"\"\"\n    for func in bril['functions']:\n        print('digraph {} {{'.format(func['name']))\n\n        # 1. Get named blocks\n        blocks = block_map(form_blocks(func['instrs']))\n\n        # 2. Make edges explicit\n        add_terminators(blocks)\n\n        # 3. Add the vertices (nodes)\n        for name, block in blocks.items():\n            if verbose:\n                import briltxt\n                print(r'  {} [shape=box, xlabel=\"{}\", label=\"{}\\l\"];'.format(\n                    quote_if_needed(name),\n                    name,\n                    r'\\l'.join(briltxt.instr_to_string(i) for i in block),\n                ))\n            else:\n                print('  {};'.format(name))\n\n        # 4. Add the control-flow edges (arrows)\n        for i, (name, block) in enumerate(blocks.items()):\n            succ = successors(block[-1])\n            for label in succ:\n                print('  {} -&gt; {};'.format(quote_if_needed(name), \n                                        quote_if_needed(label)))\n\n        print('}')"
  },
  {
    "objectID": "posts/cs/compiler/1-cfg/index.html#quarto에서-cfg-시각화하기",
    "href": "posts/cs/compiler/1-cfg/index.html#quarto에서-cfg-시각화하기",
    "title": "컴파일러 백엔드 시리즈 1부: 제어 흐름 그래프(CFG) 구축하기",
    "section": "Quarto에서 CFG 시각화하기",
    "text": "Quarto에서 CFG 시각화하기\ncfg_dot.py가 생성한 DOT 코드를 .qmd 파일에 내장하면, 독자에게 실제 CFG를 인터랙티브하게 보여줄 수 있습니다.\n예를 들어, 간단한 if문 Bril 코드를 이 스크립트로 처리하면 다음과 유사한 DOT 출력을 생성합니다.\n\n\n\n\n\n\n\nmy_function\n\n\n\nentry\n\nv: int = const 4\nbr cond if.then if.else\nentry\n\n\n\nif.then\n\nv: int = add v v\njmp if.end\nif.then\n\n\n\nentry-&gt;if.then\n\n\n\n\n\nif.else\n\nv: int = const 0\njmp if.end\nif.else\n\n\n\nentry-&gt;if.else\n\n\n\n\n\nif.end\n\nprint v\nret\nif.end\n\n\n\nif.then-&gt;if.end\n\n\n\n\n\nif.else-&gt;if.end"
  },
  {
    "objectID": "posts/cs/compiler/index.html",
    "href": "posts/cs/compiler/index.html",
    "title": "컴파일러 백엔드 시리즈",
    "section": "",
    "text": "컴파일러 최적화의 기반이 되는 CFG, SSA, 데이터 흐름 분석 등을 단계별로 구현합니다."
  },
  {
    "objectID": "posts/cs/compiler/index.html#컴파일러-백엔드-시리즈",
    "href": "posts/cs/compiler/index.html#컴파일러-백엔드-시리즈",
    "title": "컴파일러 백엔드 시리즈",
    "section": "",
    "text": "컴파일러 최적화의 기반이 되는 CFG, SSA, 데이터 흐름 분석 등을 단계별로 구현합니다."
  },
  {
    "objectID": "posts/cs/compiler/3-optimization/index.html",
    "href": "posts/cs/compiler/3-optimization/index.html",
    "title": "컴파일러 백엔드 시리즈 3부: SSA를 활용한 최적화와 해제",
    "section": "",
    "text": "2부에서 우리는 복잡한 과정을 거쳐 Bril 코드를 SSA (Static Single Assignment) 폼으로 변환하고 검증했습니다. 이 모든 작업을 수행한 이유는 SSA 폼이 컴파일러 최적화(Optimization)를 매우 단순하고 강력하게 만들어주기 때문입니다.\n3부에서는 SSA 폼(혹은 일반 IR)을 활용하는 두 가지 대표적인 최적화(lvn.py, tdce.py)를 살펴보고, 최적화가 끝난 코드를 다시 실행 가능한 형태로 되돌리는 from_ssa.py를 분석합니다."
  },
  {
    "objectID": "posts/cs/compiler/3-optimization/index.html#최적화-1-lvn-local-value-numbering",
    "href": "posts/cs/compiler/3-optimization/index.html#최적화-1-lvn-local-value-numbering",
    "title": "컴파일러 백엔드 시리즈 3부: SSA를 활용한 최적화와 해제",
    "section": "7. 최적화 1: LVN (Local Value Numbering)",
    "text": "7. 최적화 1: LVN (Local Value Numbering)\nlvn.py는 가장 고전적이고 효과적인 국소 최적화(Local Optimization) 기법인 Local Value Numbering(LVN)을 구현합니다. LVN은 하나의 기본 블록 내에서 작동하며, 핵심 아이디어는 간단합니다.\n\n“이전에 똑같은 연산을 똑같은 값으로 수행한 적이 있다면, 다시 계산하지 말고 이전 결과를 재사용하자.”\n\nLVN은 한 기본 블록 내에서 다음과 같은 최적화를 동시에 수행합니다.\n\n공통 부분 표현식 제거 (Common Subexpression Elimination, CSE):\n\na = b + c;\nd = b + c; \\(\\rightarrow\\) d = id a; (d는 a와 같음)\n\n상수 폴딩 (Constant Folding):\n\na = 5 + 2; \\(\\rightarrow\\) a = const 7;\n\n복사 전파 (Copy Propagation):\n\na = b;\nc = a + 1; \\(\\rightarrow\\) c = b + 1;\n\n\n\nlvn.py 핵심 로직 분석\nLVN은 기본 블록을 스캔하면서 “값(Value)”을 식별하는 여러 개의 맵(테이블)을 유지 관리합니다.\n\nvar2num: Map&lt;VarName, ValueNumber&gt;\n\n현재 시점에 각 변수가 어떤 값 번호를 갖고 있는지 추적합니다.\n\nvalue2num: Map&lt;ValueTuple, ValueNumber&gt;\n\n특정 연산(Value(op, args))이 어떤 값 번호와 매핑되는지 저장하는 ’캐시’입니다.\n\nnum2vars: Map&lt;ValueNumber, VarName&gt;\n\n특정 값 번호를 저장하고 있는 대표 변수가 무엇인지 저장합니다. (CSE용)\n\nnum2const: Map&lt;ValueNumber, Literal&gt;\n\n특정 값 번호가 상수임을 저장합니다. (상수 폴딩용)\n\n\nlvn_block의 메인 루프는 명령어를 순회하며 다음을 수행합니다.\n\n인자(Args) 번호 조회: 명령어의 인자(argvars)가 var2num 테이블을 참조하여 어떤 값 번호(argnums)를 갖는지 확인합니다.\n값(Value) 생성: val = Value(instr['op'], argnums) 튜플을 생성합니다. (예: Value('add', (1, 2)))\n캐시 조회(CSE): num = lookup(value2num, val)\n캐시 히트 (Hit) - 중복 연산 발견!\n\n이전에 계산된 값 번호(num)를 가져옵니다.\n현재 명령어를 op: 'const' (상수 폴딩) 또는 op: 'id' (CSE/복사 전파)로 덮어씁니다.\n\n캐시 미스 (Miss) - 새로운 연산!\n\n새로운 값 번호(newnum)를 생성합니다.\nvalue2num[val] = newnum: value2num 캐시에 이 새로운 Value와 newnum을 저장합니다.\n\n\n\n💡 LVN과 SSA의 관계\n이 lvn.py 구현은 국소적(Local)입니다. 즉, 기본 블록이 끝나면 모든 테이블 정보가 사라집니다.\n반면, 2부에서 수행한 SSA 변환은 그 자체로 전역적(Global)인 ‘값 번호 매기기’(Global Value Numbering, GVN)의 한 형태입니다. SSA 폼에서는 x.0, x.1 같은 변수 이름 자체가 그 값의 고유한 ‘번호’ 역할을 하기 때문입니다."
  },
  {
    "objectID": "posts/cs/compiler/3-optimization/index.html#최적화-2-tdce-trivial-dead-code-elimination",
    "href": "posts/cs/compiler/3-optimization/index.html#최적화-2-tdce-trivial-dead-code-elimination",
    "title": "컴파일러 백엔드 시리즈 3부: SSA를 활용한 최적화와 해제",
    "section": "8. 최적화 2: TDCE (Trivial Dead Code Elimination)",
    "text": "8. 최적화 2: TDCE (Trivial Dead Code Elimination)\n최적화의 또 다른 큰 축은 “불필요한 코드”를 제거하는 것입니다. 죽은 코드(Dead Code)란, 그 코드를 실행한 결과(정의된 변수)가 프로그램의 나머지 부분 어디에서도 전혀 사용되지 않는 코드를 말합니다.\ntdce.py의 “Trivial” (간단한)이라는 이름은 이 최적화가 복잡한 데이터 흐름 분석 없이, 매우 간단한 스캔만으로 죽은 코드를 찾아낸다는 의미입니다.\n이 간단한 접근 방식은 SSA 폼에서 특히 강력합니다.\n\n일반 IR: x = 1; x = 2; print(x);\n\nx = 1은 죽은 코드가 맞지만, x라는 변수 자체는 print(x)에서 ’사용’됩니다. 이 코드가 죽었는지 판별하기 까다롭습니다.\n\nSSA 폼: x.0 = 1; x.1 = 2; print(x.1);\n\nx.0이라는 변수는 단 한 번 정의됩니다.\n프로그램 전체를 스캔해서 x.0을 args로 사용하는 명령어가 단 하나도 없다면, x.0 = 1 명령어는 명백하게(Trivially) 죽은 코드입니다.\n\n\n\ntrivial_dce_pass 핵심 로직 분석\ntrivial_dce_pass 함수는 간단한 2-Pass 알고리즘으로 동작합니다.\n\n1. Pass 1: 사용된 변수 마킹 (Mark)\n먼저, 함수 전체를 한 번 스캔하여 “단 한 번이라도 args로 사용된” 변수들의 전역 집합(global set) used를 만듭니다.\n    used = set()\n    for block in blocks:\n        for instr in block:\n            # Mark all the variable arguments as used.\n            used.update(instr.get('args', []))"
  },
  {
    "objectID": "posts/cs/compiler/3-optimization/index.html#pass-2-죽은-코드-제거-sweep",
    "href": "posts/cs/compiler/3-optimization/index.html#pass-2-죽은-코드-제거-sweep",
    "title": "컴파일러 백엔드 시리즈 3부: SSA를 활용한 최적화와 해제",
    "section": "2. Pass 2: 죽은 코드 제거 (Sweep)",
    "text": "2. Pass 2: 죽은 코드 제거 (Sweep)\nused 집합이 완성되면, 함수 전체를 다시 스캔하며 각 명령어를 필터링합니다.\n\n’dest’가 없는 명령어 (예: print, br): 절대 제거하지 않습니다 (Keep).\n’dest’가 있는 명령어: if i['dest'] in used:\n\n목적지 변수가 used 집합에 있다면: 유지합니다 (Keep).\n목적지 변수가 used 집합에 없다면: 제거합니다 (Sweep).\n\n\nnew_block = [i for i in block\n                   if 'dest' not in i or i['dest'] in used]\n// 변환 전\n.pred1:\n  v.0 = const 1;\n  br cond .after .pred2;\n.pred2:\n  v.1 = const 2;\n  jmp .after;\n.after:\n  v.2 = phi v.0 v.1; // .pred1에서 오면 v.0, .pred2에서 오면 v.1\n// 변환 후 (Phi-Lowering)\n.pred1:\n  v.0 = const 1;\n  v.2 = id v.0;      // &lt;--- .after를 위해 미리 v.2에 v.0 복사\n  br cond .after .pred2;\n.pred2:\n  v.1 = const 2;\n  v.2 = id v.1;      // &lt;--- .after를 위해 미리 v.2에 v.1 복사\n  jmp .after;\n.after:\n  // phi 함수 제거됨.\n  // 이 시점에 v.2는 항상 올바른 값을 가짐.\n\nfrom_ssa.py 핵심 로직 분석\nfunc_from_ssa 함수는 이 알고리즘을 두 단계로 구현합니다.\n\n1단계: \\(\\phi\\) 함수를 찾아 전임자에 복사본 삽입\n\n모든 블록을 순회하며 op: 'phi'인 명령어를 찾습니다.\n\\(\\phi\\) 명령어를 찾으면, instr['labels'] (전임자 블록 리스트)와 instr['args'] (가져올 변수 리스트)를 순회합니다.\n각 (label, var) 쌍에 대해:\n\npred = blocks[label]: label 이름으로 전임자 블록(pred)을 찾습니다.\npred.insert(-1, ...): pred 블록의 마지막 명령어(종결자) 바로 앞(-1 위치)에 id (복사) 명령어를 삽입합니다. ( {'op': 'id', 'args': [var], 'dest': dest} )\n\n\n2단계: \\(\\phi\\) 함수 제거\n\n모든 \\(\\phi\\) 함수에 대한 복사본 삽입이 완료된 후, 다시 블록들을 순회하며 op: 'phi'인 모든 명령어를 제거(filter out)합니다.\n\n\ndef func_from_ssa(func):\n    blocks = block_map(form_blocks(func['instrs']))\n    # ... (add_entry, add_terminators) ...\n\n    # 1단계: 전임자 블록에 'id' (복사) 명령어 삽입\n    for block in blocks.values():\n        for instr in block:\n            if instr.get('op') == 'phi':\n                dest = instr['dest']\n                for i, label in enumerate(instr['labels']):\n                    var = instr['args'][i]\n                    pred = blocks[label]\n                    pred.insert(-1, { # 종결자(-1) 앞에 복사본 삽입\n                        'op': 'id',\n                        'type': instr['type'],\n                        'args': [var],\n                        'dest': dest,\n                    })\n\n        # 2단계: 현재 블록에서 모든 phi 명령어 제거\n        new_block = [i for i in block if i.get('op') != 'phi']\n        block[:] = new_block\n\n    func['instrs'] = reassemble(blocks)"
  },
  {
    "objectID": "posts/cs/quantum/l18 - grover/index.html",
    "href": "posts/cs/quantum/l18 - grover/index.html",
    "title": "L18. Grover’s Algorithm",
    "section": "",
    "text": "Shor의 알고리즘(L16)에 이어 두 번째로 유명한 양자 알고리즘이지만, Shor와는 근본적으로 다른 프레임워크에 기반합니다.\n\nShor (HSP 패러다임):\n\n프레임워크: 양자 푸리에 샘플링 (Quantum Fourier Sampling) (L11-L17)\n문제: “주기성”이라는 구조적 패턴(structured pattern)을 찾습니다.\n속도 향상: 지수적 (Exponential) (고전 \\(\\exp(n)\\) vs 양자 \\(poly(n)\\))\n\nGrover (본 강의):\n\n프레임워크: 진폭 증폭 (Amplitude Amplification)\n문제: “구조가 없는(unstructured)” 순수 검색 문제를 다룹니다.\n속도 향상: “단지(merely)” 이차적 (Quadratic) (고전 \\(O(N)\\) vs 양자 \\(O(\\sqrt{N})\\))\n\n\n\n\n\n작업 (Task): \\(N=2^n\\)개의 항목(bit)으로 구성된 거대한 “데이터베이스”가 있습니다. 이 데이터베이스는 불리언 함수(Boolean function) \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\)의 “암시적(implicit)” 진리표로 주어집니다.\n목표 (Goal): 이 “데이터베이스”에서 \\(F(x)=1\\)을 만족하는 “표시된(marked)” 항목 \\(x\\)를 찾는(find) 것입니다. * (만약 “1”이 하나도 없다면, \\(K=0\\)임을 확신하고 “0”을 반환해야 합니다.) * 핵심: \\(F\\)에는 Shor의 문제와 같은 어떠한 “패턴”이나 “주기성”도 없습니다.\n\n\n\n\n이 문제를 분석하기 위해, 우리는 Shor/Simon과 동일한 “블랙박스 쿼리 모델”을 가정합니다.\n\n가정: 우리는 \\(F\\)를 구현하는 회로(circuit) \\(C\\) (오라클)를 받지만, 그 내부 코드나 게이트를 들여다볼 수 없습니다(not allowed to look).\n허용된 연산: 우리는 오직 \\(C\\)에 입력을 넣고 출력을 받는 “쿼리(query)” (사용)만 할 수 있습니다.\n복잡도 척도: 알고리즘의 효율성은 “오라클 \\(C\\)를 몇 번 호출(query)했는가?”로 측정됩니다.\n\n\n\n\n\n문제: \\(N=2^n\\)개의 항목 중 \\(F(x)=1\\)인 “표시된” 항목 \\(x\\) ( \\(K\\)개가 있다고 가정)를 찾는 데 필요한 오라클 \\(F\\)의 호출(query) 횟수는 몇 번인가?\n\n고전적 (Deterministic): 최악의 경우 \\(O(N)\\)번.\n고전적 (Randomized): \\(F(x)=1\\)인 것을 찾을 기대 횟수는 \\(O(N/K)\\)번입니다.\n\n\\(K=1\\) (가장 어려운 경우) \\(\\implies\\) \\(O(N)\\) 쿼리.\n\n양자 (Grover ’96):\n\n\\(K\\)개의 “1”이 있을 때, \\(K\\)개의 항목 중 하나를 높은 확률로 찾습니다.\n쿼리 횟수: \\(O(\\sqrt{N/K})\\)\n\n\n\n\n\nShor: 고전 \\(O(2^n)\\) \\(\\to\\) 양자 \\(O(n^3)\\) (지수적 향상)\nGrover (K=1): 고전 \\(O(N) = O(2^n)\\) \\(\\to\\) 양자 \\(O(\\sqrt{N}) = O(\\sqrt{2^n}) \\approx O(1.414^n)\\)\n\n이는 \\(N\\) (총 항목 수)의 관점에서는 “이차적(quadratic) 속도 향상”입니다.\n(사용자 노트: Bigger K, faster Grover does it.) 표시된 항목 \\(K\\)가 많을수록 \\(\\sqrt{K}\\)배 더 빨라집니다.\n\n\n\n\n\n\n\n질문: \\(O(\\sqrt{N})\\)보다 더 빠를 수는 없는가? (예: Shor처럼 \\(O(poly(n))\\) 시간에?) 답: 불가능하다.\n\n[정리] (BBBV ’94) “블랙박스 쿼리 모델”에서, 비구조화된 데이터베이스(\\(N\\)개 항목)의 “표시된” 항목을 높은 확률로 찾기 위해서는, 어떤 양자 알고리즘이라도 최소한 \\(\\Omega(\\sqrt{N})\\)번의 쿼리가 필요하다.\n\n결론: Grover의 \\(O(\\sqrt{N})\\) 알고리즘은 이 \\(\\Omega(\\sqrt{N})\\) 하한(lower bound)과 일치하므로, (이차적 속도 향상이) 최선(optimal)입니다.\n\n\n\n\n이 “최적성” 증명(BBBV ’94)은 “양자 컴퓨터가 NP-Complete 문제를 효율적으로 풀 수 있는가?”라는 질문(NP \\(\\subseteq\\) BQP?)에 대한 강력한 “증거(evidence)”를 제공합니다.\n\nCircuit-SAT (NP-Complete 문제): “회로 \\(C\\)의 명세서(게이트 목록)를 보고 \\(F(x)=1\\)인 \\(x\\)를 찾으시오.”\nGrover (블랙박스 문제): “회로 \\(C\\)를 보지 못하고 \\(F(x)=1\\)인 \\(x\\)를 찾으시오.”\n\nBBBV ’94는 “보지 못하는” (더 쉬운) 문제조차 \\(\\Omega(\\sqrt{N})\\) (지수적 시간)이 필요함을 증명했습니다. 이는 “보고 푸는” (더 어려운) NP-Complete 문제가 \\(poly(n)\\) 시간에 풀릴 수 없을 것(즉, NP \\(\\not\\subseteq\\) BQP)이라는 강력한 정황 증거입니다. (이는 Shor의 알고리즘이 P \\(\\neq\\) BQP (아마도)를 시사하는 것과 대조됩니다.)\n\n\n\n\nShor의 \\(H-V_F-H\\) (Rotate-Compute-Rotate) 패러다임을 \\(K=1\\) (표시된 항목이 1개, \\(x^*\\))인 검색 문제에 적용해 보겠습니다.\n\n[Rotate 1 (\\(H^{\\otimes n}\\))]: \\(|+\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x |x\\rangle\\)\n[Compute (\\(V_F\\))]: \\(|f\\rangle = V_F |+\\rangle = \\frac{1}{\\sqrt{N}} \\left( \\sum_{x \\neq x^*} |x\\rangle - |x^*\\rangle \\right)\\)\n[Rotate 2 (\\(H^{\\otimes n}\\))]: \\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |f\\rangle = \\sum_s \\tilde{f}(s) |s\\rangle\\)\n\n결과 (실패): * L12에서 배웠듯이, \\(\\tilde{f}(0)\\) (푸리에 계수 \\(s=0\\))은 데이터의 평균(average) \\(\\mu\\)입니다. * \\(\\mu = \\text{avg}(f(x)) = \\frac{(N-1) \\cdot (+1) + 1 \\cdot (-1)}{N} = \\frac{N-2}{N} \\approx 1\\) * 거의 모든( \\(\\approx 100\\%\\) ) 확률이 \\(s=0...0\\)에 쏠려 있습니다. * 이 상태를 측정하면 거의 100% 확률로 \\(s=0...0\\) (평균값)이 나오며, 이는 \\(x^*\\)의 위치에 대한 아무런 정보도 주지 않습니다.\n\n\n\n\nShor의 패러다임이 \\(x^*\\)의 “위치” 정보를 “주파수” 공간으로 변환하는 데 실패했기 때문에, Grover는 “진폭”을 직접 증폭하는 “진폭 증폭(Amplitude Amplification)”이라는 완전히 다른 접근을 사용합니다.\n\nGrover의 아이디어: \\(U_f\\) (오라클 반사)와 \\(U_s\\) (평균 반사)라는 두 개의 “반사(reflection)” 연산을 \\(T = O(\\sqrt{N})\\)번 반복(iterate)하여 \\(|x^*\\rangle\\)의 진폭을 “펌핑”합니다.\n\n\\[|\\psi_{\\text{final}}\\rangle = (U_s \\cdot U_f)^T |+\\rangle\\]\n\n\n\n\n\n\n\n목적: “표시된” 항목 \\(x^*\\)의 위상만 뒤집습니다(flip). (L11의 “부호 오라클”)\n정의: \\(U_f: |x\\rangle \\mapsto (-1)^{F(x)} |x\\rangle\\)\n비용: \\(Q_F\\) 오라클 1회 호출.\n\n\n\n\n\n목적: 모든 \\(x\\)의 진폭을 전체 진폭의 평균(\\(\\mu\\))에 대해 “반사(reflect)”시킵니다.\n구현: \\(U_s = H^{\\otimes n} \\cdot U_0 \\cdot H^{\\otimes n}\\)\n\n\\(H^{\\otimes n}\\): 계산 기저(\\(x\\))에서 푸리에 기저(\\(s\\))로 회전.\n\\(U_0 = 2|0\\rangle\\langle 0| - I\\): \\(|0...0\\rangle\\) 상태를 제외한 다른 모든 상태(\\(s \\neq 0\\))의 위상을 -1로 뒤집습니다. (\\(Q_{OR}\\) 회로로 구현)\n\\(H^{\\otimes n}\\): 다시 계산 기저(\\(x\\))로 회전.\n\n\n\n\n\n(사용자 노트의 (1/sqrtN) -&gt; (3/sqrtN) -&gt; (5/sqrtN) 분석)\n\n[시작] \\(T=0\\): \\(\\text{Amp}(x^*) = 1/\\sqrt{N}\\). (평균 \\(\\mu \\approx 1/\\sqrt{N}\\))\n[Iter. 1]:\n\n(a) \\(U_f\\) 적용 (Oracle): \\(\\text{Amp}(x^*) \\to -1/\\sqrt{N}\\). (평균 \\(\\mu'\\)가 약간 낮아짐)\n(b) \\(U_s\\) 적용 (Reflect across mean \\(\\mu'\\)): \\(x^*\\)의 진폭(\\(-1/\\sqrt{N}\\))은 평균 \\(\\mu'\\)보다 훨씬 아래에 있으므로, 반사되어 \\(\\approx \\mathbf{3/\\sqrt{N}}\\)로 솟구칩니다.\n\n[Iter. 2]:\n\n(a) \\(U_f\\) 적용 (Oracle): \\(\\text{Amp}(x^*) \\to -3/\\sqrt{N}\\).\n(b) \\(U_s\\) 적용 (Reflect across mean \\(\\mu''\\)): \\(\\text{Amp}(x^*) \\approx \\mathbf{5/\\sqrt{N}}\\)로 증폭됩니다.\n\n[Iter. T]: \\(T\\)회 반복 후, \\(\\text{Amp}(x^*) \\approx \\frac{2T+1}{\\sqrt{N}}\\) 입니다.\n\n\n\n\n\n\n\n최적 반복 (Optimal Iterations): \\(\\text{Amp}(x^*)\\)가 \\(1\\)에 가까워질 때 중단해야 합니다. \\[T_{\\text{opt}} \\approx \\frac{\\pi}{4}\\sqrt{N/K}\\] (\\(K=1\\)일 때 \\(T_{\\text{opt}} \\approx \\frac{\\pi}{4}\\sqrt{N} \\approx 0.78 \\sqrt{N}\\))\n측정: \\(T_{\\text{opt}}\\)번 반복 후, 상태를 측정(Measure)하면 \\(x^*\\) (또는 “1” 중 하나)를 매우 높은 확률로 얻습니다.\n경고: “과회전” (Overshooting): (사용자 노트: If you are not careful, the ampl. can actually start going down.) Grover의 알고리즘은 \\(T_{\\text{opt}}\\)보다 더 많이 반복하면, 진폭이 \\(1\\)을 “지나쳐” 다시 \\(0\\)을 향해 줄어들어 성공 확률이 낮아집니다.\n최종 확인: \\(O(\\sqrt{N/K})\\)번의 쿼리로 찾은 \\(x'\\)가 정말 \\(F(x')=1\\)인지 확인하기 위해, 고전적으로 1번의 쿼리를 추가로 수행하여 검증(verify)합니다."
  },
  {
    "objectID": "posts/cs/quantum/l18 - grover/index.html#l18.-grovers-algorithm",
    "href": "posts/cs/quantum/l18 - grover/index.html#l18.-grovers-algorithm",
    "title": "L18. Grover’s Algorithm",
    "section": "",
    "text": "Shor의 알고리즘(L16)에 이어 두 번째로 유명한 양자 알고리즘이지만, Shor와는 근본적으로 다른 프레임워크에 기반합니다.\n\nShor (HSP 패러다임):\n\n프레임워크: 양자 푸리에 샘플링 (Quantum Fourier Sampling) (L11-L17)\n문제: “주기성”이라는 구조적 패턴(structured pattern)을 찾습니다.\n속도 향상: 지수적 (Exponential) (고전 \\(\\exp(n)\\) vs 양자 \\(poly(n)\\))\n\nGrover (본 강의):\n\n프레임워크: 진폭 증폭 (Amplitude Amplification)\n문제: “구조가 없는(unstructured)” 순수 검색 문제를 다룹니다.\n속도 향상: “단지(merely)” 이차적 (Quadratic) (고전 \\(O(N)\\) vs 양자 \\(O(\\sqrt{N})\\))\n\n\n\n\n\n작업 (Task): \\(N=2^n\\)개의 항목(bit)으로 구성된 거대한 “데이터베이스”가 있습니다. 이 데이터베이스는 불리언 함수(Boolean function) \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\)의 “암시적(implicit)” 진리표로 주어집니다.\n목표 (Goal): 이 “데이터베이스”에서 \\(F(x)=1\\)을 만족하는 “표시된(marked)” 항목 \\(x\\)를 찾는(find) 것입니다. * (만약 “1”이 하나도 없다면, \\(K=0\\)임을 확신하고 “0”을 반환해야 합니다.) * 핵심: \\(F\\)에는 Shor의 문제와 같은 어떠한 “패턴”이나 “주기성”도 없습니다.\n\n\n\n\n이 문제를 분석하기 위해, 우리는 Shor/Simon과 동일한 “블랙박스 쿼리 모델”을 가정합니다.\n\n가정: 우리는 \\(F\\)를 구현하는 회로(circuit) \\(C\\) (오라클)를 받지만, 그 내부 코드나 게이트를 들여다볼 수 없습니다(not allowed to look).\n허용된 연산: 우리는 오직 \\(C\\)에 입력을 넣고 출력을 받는 “쿼리(query)” (사용)만 할 수 있습니다.\n복잡도 척도: 알고리즘의 효율성은 “오라클 \\(C\\)를 몇 번 호출(query)했는가?”로 측정됩니다.\n\n\n\n\n\n문제: \\(N=2^n\\)개의 항목 중 \\(F(x)=1\\)인 “표시된” 항목 \\(x\\) ( \\(K\\)개가 있다고 가정)를 찾는 데 필요한 오라클 \\(F\\)의 호출(query) 횟수는 몇 번인가?\n\n고전적 (Deterministic): 최악의 경우 \\(O(N)\\)번.\n고전적 (Randomized): \\(F(x)=1\\)인 것을 찾을 기대 횟수는 \\(O(N/K)\\)번입니다.\n\n\\(K=1\\) (가장 어려운 경우) \\(\\implies\\) \\(O(N)\\) 쿼리.\n\n양자 (Grover ’96):\n\n\\(K\\)개의 “1”이 있을 때, \\(K\\)개의 항목 중 하나를 높은 확률로 찾습니다.\n쿼리 횟수: \\(O(\\sqrt{N/K})\\)\n\n\n\n\n\nShor: 고전 \\(O(2^n)\\) \\(\\to\\) 양자 \\(O(n^3)\\) (지수적 향상)\nGrover (K=1): 고전 \\(O(N) = O(2^n)\\) \\(\\to\\) 양자 \\(O(\\sqrt{N}) = O(\\sqrt{2^n}) \\approx O(1.414^n)\\)\n\n이는 \\(N\\) (총 항목 수)의 관점에서는 “이차적(quadratic) 속도 향상”입니다.\n(사용자 노트: Bigger K, faster Grover does it.) 표시된 항목 \\(K\\)가 많을수록 \\(\\sqrt{K}\\)배 더 빨라집니다.\n\n\n\n\n\n\n\n질문: \\(O(\\sqrt{N})\\)보다 더 빠를 수는 없는가? (예: Shor처럼 \\(O(poly(n))\\) 시간에?) 답: 불가능하다.\n\n[정리] (BBBV ’94) “블랙박스 쿼리 모델”에서, 비구조화된 데이터베이스(\\(N\\)개 항목)의 “표시된” 항목을 높은 확률로 찾기 위해서는, 어떤 양자 알고리즘이라도 최소한 \\(\\Omega(\\sqrt{N})\\)번의 쿼리가 필요하다.\n\n결론: Grover의 \\(O(\\sqrt{N})\\) 알고리즘은 이 \\(\\Omega(\\sqrt{N})\\) 하한(lower bound)과 일치하므로, (이차적 속도 향상이) 최선(optimal)입니다.\n\n\n\n\n이 “최적성” 증명(BBBV ’94)은 “양자 컴퓨터가 NP-Complete 문제를 효율적으로 풀 수 있는가?”라는 질문(NP \\(\\subseteq\\) BQP?)에 대한 강력한 “증거(evidence)”를 제공합니다.\n\nCircuit-SAT (NP-Complete 문제): “회로 \\(C\\)의 명세서(게이트 목록)를 보고 \\(F(x)=1\\)인 \\(x\\)를 찾으시오.”\nGrover (블랙박스 문제): “회로 \\(C\\)를 보지 못하고 \\(F(x)=1\\)인 \\(x\\)를 찾으시오.”\n\nBBBV ’94는 “보지 못하는” (더 쉬운) 문제조차 \\(\\Omega(\\sqrt{N})\\) (지수적 시간)이 필요함을 증명했습니다. 이는 “보고 푸는” (더 어려운) NP-Complete 문제가 \\(poly(n)\\) 시간에 풀릴 수 없을 것(즉, NP \\(\\not\\subseteq\\) BQP)이라는 강력한 정황 증거입니다. (이는 Shor의 알고리즘이 P \\(\\neq\\) BQP (아마도)를 시사하는 것과 대조됩니다.)\n\n\n\n\nShor의 \\(H-V_F-H\\) (Rotate-Compute-Rotate) 패러다임을 \\(K=1\\) (표시된 항목이 1개, \\(x^*\\))인 검색 문제에 적용해 보겠습니다.\n\n[Rotate 1 (\\(H^{\\otimes n}\\))]: \\(|+\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x |x\\rangle\\)\n[Compute (\\(V_F\\))]: \\(|f\\rangle = V_F |+\\rangle = \\frac{1}{\\sqrt{N}} \\left( \\sum_{x \\neq x^*} |x\\rangle - |x^*\\rangle \\right)\\)\n[Rotate 2 (\\(H^{\\otimes n}\\))]: \\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |f\\rangle = \\sum_s \\tilde{f}(s) |s\\rangle\\)\n\n결과 (실패): * L12에서 배웠듯이, \\(\\tilde{f}(0)\\) (푸리에 계수 \\(s=0\\))은 데이터의 평균(average) \\(\\mu\\)입니다. * \\(\\mu = \\text{avg}(f(x)) = \\frac{(N-1) \\cdot (+1) + 1 \\cdot (-1)}{N} = \\frac{N-2}{N} \\approx 1\\) * 거의 모든( \\(\\approx 100\\%\\) ) 확률이 \\(s=0...0\\)에 쏠려 있습니다. * 이 상태를 측정하면 거의 100% 확률로 \\(s=0...0\\) (평균값)이 나오며, 이는 \\(x^*\\)의 위치에 대한 아무런 정보도 주지 않습니다.\n\n\n\n\nShor의 패러다임이 \\(x^*\\)의 “위치” 정보를 “주파수” 공간으로 변환하는 데 실패했기 때문에, Grover는 “진폭”을 직접 증폭하는 “진폭 증폭(Amplitude Amplification)”이라는 완전히 다른 접근을 사용합니다.\n\nGrover의 아이디어: \\(U_f\\) (오라클 반사)와 \\(U_s\\) (평균 반사)라는 두 개의 “반사(reflection)” 연산을 \\(T = O(\\sqrt{N})\\)번 반복(iterate)하여 \\(|x^*\\rangle\\)의 진폭을 “펌핑”합니다.\n\n\\[|\\psi_{\\text{final}}\\rangle = (U_s \\cdot U_f)^T |+\\rangle\\]\n\n\n\n\n\n\n\n목적: “표시된” 항목 \\(x^*\\)의 위상만 뒤집습니다(flip). (L11의 “부호 오라클”)\n정의: \\(U_f: |x\\rangle \\mapsto (-1)^{F(x)} |x\\rangle\\)\n비용: \\(Q_F\\) 오라클 1회 호출.\n\n\n\n\n\n목적: 모든 \\(x\\)의 진폭을 전체 진폭의 평균(\\(\\mu\\))에 대해 “반사(reflect)”시킵니다.\n구현: \\(U_s = H^{\\otimes n} \\cdot U_0 \\cdot H^{\\otimes n}\\)\n\n\\(H^{\\otimes n}\\): 계산 기저(\\(x\\))에서 푸리에 기저(\\(s\\))로 회전.\n\\(U_0 = 2|0\\rangle\\langle 0| - I\\): \\(|0...0\\rangle\\) 상태를 제외한 다른 모든 상태(\\(s \\neq 0\\))의 위상을 -1로 뒤집습니다. (\\(Q_{OR}\\) 회로로 구현)\n\\(H^{\\otimes n}\\): 다시 계산 기저(\\(x\\))로 회전.\n\n\n\n\n\n(사용자 노트의 (1/sqrtN) -&gt; (3/sqrtN) -&gt; (5/sqrtN) 분석)\n\n[시작] \\(T=0\\): \\(\\text{Amp}(x^*) = 1/\\sqrt{N}\\). (평균 \\(\\mu \\approx 1/\\sqrt{N}\\))\n[Iter. 1]:\n\n(a) \\(U_f\\) 적용 (Oracle): \\(\\text{Amp}(x^*) \\to -1/\\sqrt{N}\\). (평균 \\(\\mu'\\)가 약간 낮아짐)\n(b) \\(U_s\\) 적용 (Reflect across mean \\(\\mu'\\)): \\(x^*\\)의 진폭(\\(-1/\\sqrt{N}\\))은 평균 \\(\\mu'\\)보다 훨씬 아래에 있으므로, 반사되어 \\(\\approx \\mathbf{3/\\sqrt{N}}\\)로 솟구칩니다.\n\n[Iter. 2]:\n\n(a) \\(U_f\\) 적용 (Oracle): \\(\\text{Amp}(x^*) \\to -3/\\sqrt{N}\\).\n(b) \\(U_s\\) 적용 (Reflect across mean \\(\\mu''\\)): \\(\\text{Amp}(x^*) \\approx \\mathbf{5/\\sqrt{N}}\\)로 증폭됩니다.\n\n[Iter. T]: \\(T\\)회 반복 후, \\(\\text{Amp}(x^*) \\approx \\frac{2T+1}{\\sqrt{N}}\\) 입니다.\n\n\n\n\n\n\n\n최적 반복 (Optimal Iterations): \\(\\text{Amp}(x^*)\\)가 \\(1\\)에 가까워질 때 중단해야 합니다. \\[T_{\\text{opt}} \\approx \\frac{\\pi}{4}\\sqrt{N/K}\\] (\\(K=1\\)일 때 \\(T_{\\text{opt}} \\approx \\frac{\\pi}{4}\\sqrt{N} \\approx 0.78 \\sqrt{N}\\))\n측정: \\(T_{\\text{opt}}\\)번 반복 후, 상태를 측정(Measure)하면 \\(x^*\\) (또는 “1” 중 하나)를 매우 높은 확률로 얻습니다.\n경고: “과회전” (Overshooting): (사용자 노트: If you are not careful, the ampl. can actually start going down.) Grover의 알고리즘은 \\(T_{\\text{opt}}\\)보다 더 많이 반복하면, 진폭이 \\(1\\)을 “지나쳐” 다시 \\(0\\)을 향해 줄어들어 성공 확률이 낮아집니다.\n최종 확인: \\(O(\\sqrt{N/K})\\)번의 쿼리로 찾은 \\(x'\\)가 정말 \\(F(x')=1\\)인지 확인하기 위해, 고전적으로 1번의 쿼리를 추가로 수행하여 검증(verify)합니다."
  },
  {
    "objectID": "posts/cs/quantum/l13 - simon/index.html",
    "href": "posts/cs/quantum/l13 - simon/index.html",
    "title": "L13. Simon’s Algorithm",
    "section": "",
    "text": "Simon의 알고리즘은 Shor의 인수분해 알고리즘(Shor’s factoring algorithm)의 직접적인 전조(direct precursor)로 간주됩니다. (Shor의 알고리즘 \\(\\approx\\) Simon의 알고리즘 + (Boolean FT 대신) Discrete FT 사용)\n이 알고리즘은 양자 컴퓨터가 고전/확률적 컴퓨터보다 지수적으로(exponentially) 빠를 수 있음을 보여준 최초의 핵심 예제 중 하나입니다.\n\n\nL12에서 우리는 “푸리에 샘플링” 패러다임을 확립했습니다. (\\(N=2^n\\))\n\n[LOAD DATA]: \\(H^{\\otimes n}\\)와 부호 오라클 \\(V_F\\) (단일 비트 \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\))를 사용하여 “데이터” \\(g(x) = (-1)^{F(x)}\\)를 진폭에 로드합니다. \\[|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} g(x) |x\\rangle\\]\n[BFT]: \\(H^{\\otimes n}\\)을 적용하여 “푸리에 상태” \\(|\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\)를 만듭니다.\n[MEASURE]: 측정하면, 데이터 \\(g\\)와 패턴 \\(\\chi_s\\)의 상관관계(correlation) \\(\\tilde{g}(s)\\)의 제곱(\\(P(s) = |\\tilde{g}(s)|^2\\))에 비례하는 확률로 패턴 \\(s\\)를 샘플링합니다.\n\n\n\n\n\nBernstein-Vazirani(BV)와 달리, Simon의 알고리즘은 출력이 다중 비트인 함수를 다룹니다.\n\nBV (L11/L12): \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\) (1 비트 출력). “위상 반동”(\\((-1)^{F(x)}\\)) 트릭 사용 가능.\nSimon (L13): \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\) ( \\(m \\ge n-1\\) 비트 출력). “위상 반동” 트릭 사용 불가.\n\n\\(F\\)의 출력이 \\(m\\) 비트 문자열이므로, 직관적으로 “문자열” 대신 “색깔(Color)”로 생각하는 것이 유용합니다. (\\(F: \\{0,1\\}^n \\to \\text{COLORS}\\))\n\\(F\\)가 다중 비트를 출력하므로, “부호 오라클(\\(V_F\\))” 대신 L10의 표준 “XOR 오라클(\\(Q_F\\))”을 사용해야 합니다. \\[Q_F: |x\\rangle_n |y\\rangle_m \\mapsto |x\\rangle_n |y \\oplus F(x)\\rangle_m\\]\n\n\n\nSimon의 문제는 이 \\(Q_F\\) 오라클(블랙박스)에 대한 “약속(promise)”을 전제로 합니다.\n\n[Simon의 약속] \\(0\\)이 아닌(\\(L \\neq 00\\dots0\\)) “비밀 문자열” \\(L \\in \\{0,1\\}^n\\)이 단 하나 존재하여, 모든 입력 \\(x, y \\in \\{0,1\\}^n\\)에 대해 다음이 성립한다:\n\\[F(x) = F(y) \\iff (x = y \\text{ or } x \\oplus y = L)\\]\n\n함의: * 이 약속은 \\(N=2^n\\)개의 모든 입력 공간(Boolean Cube)이 \\(L\\)에 의해 \\(2^{n-1}\\)개의 쌍(pair) \\(\\{x, x \\oplus L\\}\\)으로 완벽하게 분할(partition)됨을 의미합니다. * 함수 \\(F\\)는 각 쌍(pair)의 두 입력에 대해 항상 동일한 “색깔”(출력)을 부여합니다. 즉, \\(F\\)는 정확히 2-to-1 함수입니다.\n\nSimon’s Problem: 이 “2-to-1” 약속을 만족하는 “블랙박스(black box)” 오라클 \\(Q_F\\)가 주어졌을 때, 비밀 문자열 \\(L\\)을 찾으시오.\n\n\n\n\n\n주장 (Claim): 고전 컴퓨터(결정론적이든 확률적이든)는 \\(L\\)을 찾기 위해 지수적인(\\(\\Omega(\\sqrt{N})\\)) 횟수의 오라클 호출이 필요합니다.\n이유 (Sketch): 1. 정보 획득: \\(L\\)에 대한 정보를 얻는 유일한 방법은 \\(x^{(i)} \\neq x^{(j)}\\)인데 \\(F(x^{(i)}) = F(x^{(j)})\\)가 되는, 즉 “충돌(collision)”을 찾는 것입니다. (이때 \\(L = x^{(i)} \\oplus x^{(j)}\\) 입니다.) 2. 생일 문제 (Birthday Problem): \\(F\\)는 \\(N/2 = 2^{n-1}\\)개의 “색깔” 중 하나를 반환하는 것과 유사합니다. \\(N/2\\)개의 항목 중에서 충돌을 찾으려면 생일 문제에 따라 약 \\(T \\approx \\sqrt{N/2} \\approx \\Omega(2^{n/2}) \\approx \\Omega((1.414)^n)\\) 번의 샘플링(호출)이 필요합니다. 3. 결론: \\(L\\)을 찾는 데 필요한 고전적 호출 횟수는 \\(n\\)에 대해 지수적(exponential)입니다.\n\n\n\n\n정리 (Simon): 양자 컴퓨터는 \\(L\\)을 높은 확률로 결정하기 위해 \\(O(n)\\) (즉, \\(n\\)에 대한 다항식(polynomial)) 횟수의 오라클 \\(Q_F\\) 호출만 필요합니다.\n이는 \\(\\Omega((1.4)^n)\\) (고전) vs \\(O(n)\\) (양자)이라는 지수적 분리(Exponential Separation)를 의미하며, (오라클 모델 하에서) 양자 컴퓨터가 고전 컴퓨터보다 근본적으로 강력함을 보여줍니다.\n(참고: 이는 BQP \\(\\neq\\) BPP와 같은 표준 복잡도 클래스의 분리를 증명한 것은 아니며, “오라클”이라는 특수 모델 하에서의 분리를 의미합니다.)\n\n\n\n\n알고리즘은 “Rotate - Compute - Rotate” 구조를 따르지만, L11/L12와는 방식이 다릅니다.\n\n\n\n두 레지스터 \\(|0\\rangle^{\\otimes n} |0\\rangle^{\\otimes m}\\)에서 시작합니다.\n[Rotate]: 입력 레지스터에 \\(H^{\\otimes n}\\)을 적용합니다. \\[\\left( \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\right) |0\\rangle^{\\otimes m}\\]\n[Compute]: \\(Q_F\\) 오라클을 적용합니다. \\[|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle |F(x)\\rangle\\]\n\n결과물 \\(|\\psi_1\\rangle\\)은 모든 입력 \\(|x\\rangle\\)와 그에 해당하는 “색깔” \\(|F(x)\\rangle\\)가 거대하게 얽힌(entangled) 상태입니다.\n\nquantee 코드 스니펫 (Simon’s Algorithm - Part 1):\n::: {quantee}\nqcircuit:\n  qubits:\n    - name: 'Input (n)'\n      size: n\n    - name: 'Output (m)'\n      size: m\n  circuit:\n    # 1. Rotate\n    - H: 0\n    # 2. Compute\n    - gate: Q_F\n      qubits: [0, 1]\n      props:\n        name: 'Q_F'\n        label: 'U_f'\n:::\n\n\n\n\n이 얽힌 상태 \\(|\\psi_1\\rangle\\)를 분석하기 위해, 출력 레지스터(\\(m\\) 큐비트)를 측정(Measure)한다고 “가정”해봅니다. (이는 지연된 측정의 원리에 따라 분석의 편의를 위한 것이며, 실제로 중간에 측정할 필요는 없습니다.)\n\n측정 시, \\(F\\)의 “색깔” 중 하나인 \\(C^*\\)를 고전적 결과로 얻습니다.\nSimon의 약속에 따라, \\(F(x) = C^*\\)를 만족하는 \\(x\\) 값은 정확히 두 개(\\(x_0\\)와 \\(x_0 \\oplus L\\))가 존재합니다.\n측정 순간, \\(|\\psi_1\\rangle\\)의 거대한 중첩은 이 두 항만 남기고 붕괴(collapse)합니다.\n측정된 출력 레지스터 \\(|C^*\\rangle\\)를 무시하고 나면, \\(n\\) 큐비트의 입력 레지스터는 다음 상태가 됩니다. \\[|\\psi_2\\rangle = \\frac{1}{\\sqrt{2}} \\left( |x_0\\rangle + |x_0 \\oplus L\\rangle \\right)\\]\n\n\n\n\n이제 이 \\(|\\psi_2\\rangle\\) 상태(입력 레지스터)에 \\(H^{\\otimes n}\\) (Boolean Fourier Transform)을 적용합니다.\n\\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_2\\rangle = H^{\\otimes n} \\left[ \\frac{1}{\\sqrt{2}} \\left( |x_0\\rangle + |x_0 \\oplus L\\rangle \\right) \\right]\\] \\[= \\frac{1}{\\sqrt{2}} \\left[ H^{\\otimes n}|x_0\\rangle + H^{\\otimes n}|x_0 \\oplus L\\rangle \\right]\\] L12의 BFT 정의(\\(H^{\\otimes n}|x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_s (-1)^{s \\cdot x} |s\\rangle\\))를 대입합니다. \\[= \\frac{1}{\\sqrt{2N}} \\sum_s \\left[ (-1)^{s \\cdot x_0} + (-1)^{s \\cdot (x_0 \\oplus L)} \\right] |s\\rangle\\] \\(s \\cdot (x_0 \\oplus L) = (s \\cdot x_0) \\oplus (s \\cdot L)\\)을 이용해 정리하면, \\[= \\frac{1}{\\sqrt{2N}} \\sum_s (-1)^{s \\cdot x_0} \\left[ 1 + (-1)^{s \\cdot L} \\right] |s\\rangle\\]\n이제 \\(\\left[ 1 + (-1)^{s \\cdot L} \\right]\\) 항에서 간섭이 발생합니다. * Case 1: \\(s \\cdot L = 1 \\pmod 2\\) * \\(\\left[ 1 + (-1)^1 \\right] = 0\\). 해당 \\(|s\\rangle\\)의 진폭은 0이 됩니다. (상쇄 간섭) * Case 2: \\(s \\cdot L = 0 \\pmod 2\\) * \\(\\left[ 1 + (-1)^0 \\right] = 2\\). 해당 \\(|s\\rangle\\)의 진폭은 0이 아닙니다. (결맞는 간섭)\n측정 결과: 최종 상태를 측정하면, \\(x_0\\)나 \\(C^*\\) 값에 관계없이 \\(s \\cdot L = 0 \\pmod 2\\) 라는 조건을 만족하는 문자열 \\(s\\)를 100% 확률로 얻게 됩니다. (정확히는 \\(s \\cdot L = 0\\)을 만족하는 \\(N/2\\)개의 \\(s\\) 중 하나를 균일한 확률(\\(2/N\\))로 샘플링합니다.)\n\n\n\n“한 방에(one-shot)” 끝나지 않습니다. 1회 실행으로 \\(L\\)에 대한 하나의 선형 방정식 \\(s^{(1)} \\cdot L = 0\\) 만 얻습니다.\n\\(L\\)을 유일하게 결정하기 위해서는 \\(n-1\\)개의 서로 독립인(linearly independent) 선형 방정식이 필요합니다.\n전체 알고리즘: 1. \\(T = O(n)\\) 번 (예: \\(T=4n\\)번) \\(H-Q_F-H \\to \\text{Measure}\\) 회로를 반복 실행합니다. 2. \\(T\\)개의 (독립이 아닐 수도 있는) 방정식 \\(s^{(i)} \\cdot L = 0\\) 을 얻습니다. 3. (고전적 후처리): 이 \\(T\\)개의 방정식으로 \\(n \\times n\\) 선형 시스템(linear system)을 만듭니다. 4. 가우시안 소거법(Gaussian elimination) (고전 \\(O(n^3)\\))을 \\(\\mathbb{F}_2\\) 상에서 수행하여 이 연립방정식을 풉니다. 5. \\(n-1\\)개의 독립 방정식을 높은 확률로 얻게 되며, 해 공간(solution space)은 \\(\\{0, L\\}\\) (1차원)이 됩니다. 6. \\(L \\neq 0\\) 약속에 따라, 유일한 비-영(non-zero) 해 \\(L\\)을 찾습니다.\n최종 결론: 고전적으로는 \\(\\Omega(2^{n/2})\\) (지수적) 시간이 걸리는 Simon의 문제를, 양자 컴퓨터는 \\(O(n)\\)번의 오라클 호출과 \\(O(n^3)\\)의 고전적 후처리, 즉 총 다항식(Polynomial) 시간에 해결했습니다.\n\n\n\n\n\nSimon의 알고리즘은 Shor 알고리즘의 핵심 원형(prototype)입니다.\n\n\n\n\n\n\n\n\n\nSimon’s Algorithm (L13)\nShor’s Algorithm (L16)\n\n\n\n\nGroup\n\\(\\mathbb{Z}_2^n\\) (n-bit 문자열과 \\(\\oplus\\))\n\\(\\mathbb{Z}_N\\) (정수와 \\(+ \\pmod N\\))\n\n\nPeriodicity\n\\(F(x) = F(x \\oplus L)\\)\n\\(F(x) = F(x + L) \\pmod N\\)\n\n\nFT\nBoolean FT (\\(H^{\\otimes n}\\))\nDiscrete FT (QFT)"
  },
  {
    "objectID": "posts/cs/quantum/l13 - simon/index.html#l13.-simons-algorithm",
    "href": "posts/cs/quantum/l13 - simon/index.html#l13.-simons-algorithm",
    "title": "L13. Simon’s Algorithm",
    "section": "",
    "text": "Simon의 알고리즘은 Shor의 인수분해 알고리즘(Shor’s factoring algorithm)의 직접적인 전조(direct precursor)로 간주됩니다. (Shor의 알고리즘 \\(\\approx\\) Simon의 알고리즘 + (Boolean FT 대신) Discrete FT 사용)\n이 알고리즘은 양자 컴퓨터가 고전/확률적 컴퓨터보다 지수적으로(exponentially) 빠를 수 있음을 보여준 최초의 핵심 예제 중 하나입니다.\n\n\nL12에서 우리는 “푸리에 샘플링” 패러다임을 확립했습니다. (\\(N=2^n\\))\n\n[LOAD DATA]: \\(H^{\\otimes n}\\)와 부호 오라클 \\(V_F\\) (단일 비트 \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\))를 사용하여 “데이터” \\(g(x) = (-1)^{F(x)}\\)를 진폭에 로드합니다. \\[|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} g(x) |x\\rangle\\]\n[BFT]: \\(H^{\\otimes n}\\)을 적용하여 “푸리에 상태” \\(|\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\)를 만듭니다.\n[MEASURE]: 측정하면, 데이터 \\(g\\)와 패턴 \\(\\chi_s\\)의 상관관계(correlation) \\(\\tilde{g}(s)\\)의 제곱(\\(P(s) = |\\tilde{g}(s)|^2\\))에 비례하는 확률로 패턴 \\(s\\)를 샘플링합니다.\n\n\n\n\n\nBernstein-Vazirani(BV)와 달리, Simon의 알고리즘은 출력이 다중 비트인 함수를 다룹니다.\n\nBV (L11/L12): \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\) (1 비트 출력). “위상 반동”(\\((-1)^{F(x)}\\)) 트릭 사용 가능.\nSimon (L13): \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\) ( \\(m \\ge n-1\\) 비트 출력). “위상 반동” 트릭 사용 불가.\n\n\\(F\\)의 출력이 \\(m\\) 비트 문자열이므로, 직관적으로 “문자열” 대신 “색깔(Color)”로 생각하는 것이 유용합니다. (\\(F: \\{0,1\\}^n \\to \\text{COLORS}\\))\n\\(F\\)가 다중 비트를 출력하므로, “부호 오라클(\\(V_F\\))” 대신 L10의 표준 “XOR 오라클(\\(Q_F\\))”을 사용해야 합니다. \\[Q_F: |x\\rangle_n |y\\rangle_m \\mapsto |x\\rangle_n |y \\oplus F(x)\\rangle_m\\]\n\n\n\nSimon의 문제는 이 \\(Q_F\\) 오라클(블랙박스)에 대한 “약속(promise)”을 전제로 합니다.\n\n[Simon의 약속] \\(0\\)이 아닌(\\(L \\neq 00\\dots0\\)) “비밀 문자열” \\(L \\in \\{0,1\\}^n\\)이 단 하나 존재하여, 모든 입력 \\(x, y \\in \\{0,1\\}^n\\)에 대해 다음이 성립한다:\n\\[F(x) = F(y) \\iff (x = y \\text{ or } x \\oplus y = L)\\]\n\n함의: * 이 약속은 \\(N=2^n\\)개의 모든 입력 공간(Boolean Cube)이 \\(L\\)에 의해 \\(2^{n-1}\\)개의 쌍(pair) \\(\\{x, x \\oplus L\\}\\)으로 완벽하게 분할(partition)됨을 의미합니다. * 함수 \\(F\\)는 각 쌍(pair)의 두 입력에 대해 항상 동일한 “색깔”(출력)을 부여합니다. 즉, \\(F\\)는 정확히 2-to-1 함수입니다.\n\nSimon’s Problem: 이 “2-to-1” 약속을 만족하는 “블랙박스(black box)” 오라클 \\(Q_F\\)가 주어졌을 때, 비밀 문자열 \\(L\\)을 찾으시오.\n\n\n\n\n\n주장 (Claim): 고전 컴퓨터(결정론적이든 확률적이든)는 \\(L\\)을 찾기 위해 지수적인(\\(\\Omega(\\sqrt{N})\\)) 횟수의 오라클 호출이 필요합니다.\n이유 (Sketch): 1. 정보 획득: \\(L\\)에 대한 정보를 얻는 유일한 방법은 \\(x^{(i)} \\neq x^{(j)}\\)인데 \\(F(x^{(i)}) = F(x^{(j)})\\)가 되는, 즉 “충돌(collision)”을 찾는 것입니다. (이때 \\(L = x^{(i)} \\oplus x^{(j)}\\) 입니다.) 2. 생일 문제 (Birthday Problem): \\(F\\)는 \\(N/2 = 2^{n-1}\\)개의 “색깔” 중 하나를 반환하는 것과 유사합니다. \\(N/2\\)개의 항목 중에서 충돌을 찾으려면 생일 문제에 따라 약 \\(T \\approx \\sqrt{N/2} \\approx \\Omega(2^{n/2}) \\approx \\Omega((1.414)^n)\\) 번의 샘플링(호출)이 필요합니다. 3. 결론: \\(L\\)을 찾는 데 필요한 고전적 호출 횟수는 \\(n\\)에 대해 지수적(exponential)입니다.\n\n\n\n\n정리 (Simon): 양자 컴퓨터는 \\(L\\)을 높은 확률로 결정하기 위해 \\(O(n)\\) (즉, \\(n\\)에 대한 다항식(polynomial)) 횟수의 오라클 \\(Q_F\\) 호출만 필요합니다.\n이는 \\(\\Omega((1.4)^n)\\) (고전) vs \\(O(n)\\) (양자)이라는 지수적 분리(Exponential Separation)를 의미하며, (오라클 모델 하에서) 양자 컴퓨터가 고전 컴퓨터보다 근본적으로 강력함을 보여줍니다.\n(참고: 이는 BQP \\(\\neq\\) BPP와 같은 표준 복잡도 클래스의 분리를 증명한 것은 아니며, “오라클”이라는 특수 모델 하에서의 분리를 의미합니다.)\n\n\n\n\n알고리즘은 “Rotate - Compute - Rotate” 구조를 따르지만, L11/L12와는 방식이 다릅니다.\n\n\n\n두 레지스터 \\(|0\\rangle^{\\otimes n} |0\\rangle^{\\otimes m}\\)에서 시작합니다.\n[Rotate]: 입력 레지스터에 \\(H^{\\otimes n}\\)을 적용합니다. \\[\\left( \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\right) |0\\rangle^{\\otimes m}\\]\n[Compute]: \\(Q_F\\) 오라클을 적용합니다. \\[|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle |F(x)\\rangle\\]\n\n결과물 \\(|\\psi_1\\rangle\\)은 모든 입력 \\(|x\\rangle\\)와 그에 해당하는 “색깔” \\(|F(x)\\rangle\\)가 거대하게 얽힌(entangled) 상태입니다.\n\nquantee 코드 스니펫 (Simon’s Algorithm - Part 1):\n::: {quantee}\nqcircuit:\n  qubits:\n    - name: 'Input (n)'\n      size: n\n    - name: 'Output (m)'\n      size: m\n  circuit:\n    # 1. Rotate\n    - H: 0\n    # 2. Compute\n    - gate: Q_F\n      qubits: [0, 1]\n      props:\n        name: 'Q_F'\n        label: 'U_f'\n:::\n\n\n\n\n이 얽힌 상태 \\(|\\psi_1\\rangle\\)를 분석하기 위해, 출력 레지스터(\\(m\\) 큐비트)를 측정(Measure)한다고 “가정”해봅니다. (이는 지연된 측정의 원리에 따라 분석의 편의를 위한 것이며, 실제로 중간에 측정할 필요는 없습니다.)\n\n측정 시, \\(F\\)의 “색깔” 중 하나인 \\(C^*\\)를 고전적 결과로 얻습니다.\nSimon의 약속에 따라, \\(F(x) = C^*\\)를 만족하는 \\(x\\) 값은 정확히 두 개(\\(x_0\\)와 \\(x_0 \\oplus L\\))가 존재합니다.\n측정 순간, \\(|\\psi_1\\rangle\\)의 거대한 중첩은 이 두 항만 남기고 붕괴(collapse)합니다.\n측정된 출력 레지스터 \\(|C^*\\rangle\\)를 무시하고 나면, \\(n\\) 큐비트의 입력 레지스터는 다음 상태가 됩니다. \\[|\\psi_2\\rangle = \\frac{1}{\\sqrt{2}} \\left( |x_0\\rangle + |x_0 \\oplus L\\rangle \\right)\\]\n\n\n\n\n이제 이 \\(|\\psi_2\\rangle\\) 상태(입력 레지스터)에 \\(H^{\\otimes n}\\) (Boolean Fourier Transform)을 적용합니다.\n\\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_2\\rangle = H^{\\otimes n} \\left[ \\frac{1}{\\sqrt{2}} \\left( |x_0\\rangle + |x_0 \\oplus L\\rangle \\right) \\right]\\] \\[= \\frac{1}{\\sqrt{2}} \\left[ H^{\\otimes n}|x_0\\rangle + H^{\\otimes n}|x_0 \\oplus L\\rangle \\right]\\] L12의 BFT 정의(\\(H^{\\otimes n}|x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_s (-1)^{s \\cdot x} |s\\rangle\\))를 대입합니다. \\[= \\frac{1}{\\sqrt{2N}} \\sum_s \\left[ (-1)^{s \\cdot x_0} + (-1)^{s \\cdot (x_0 \\oplus L)} \\right] |s\\rangle\\] \\(s \\cdot (x_0 \\oplus L) = (s \\cdot x_0) \\oplus (s \\cdot L)\\)을 이용해 정리하면, \\[= \\frac{1}{\\sqrt{2N}} \\sum_s (-1)^{s \\cdot x_0} \\left[ 1 + (-1)^{s \\cdot L} \\right] |s\\rangle\\]\n이제 \\(\\left[ 1 + (-1)^{s \\cdot L} \\right]\\) 항에서 간섭이 발생합니다. * Case 1: \\(s \\cdot L = 1 \\pmod 2\\) * \\(\\left[ 1 + (-1)^1 \\right] = 0\\). 해당 \\(|s\\rangle\\)의 진폭은 0이 됩니다. (상쇄 간섭) * Case 2: \\(s \\cdot L = 0 \\pmod 2\\) * \\(\\left[ 1 + (-1)^0 \\right] = 2\\). 해당 \\(|s\\rangle\\)의 진폭은 0이 아닙니다. (결맞는 간섭)\n측정 결과: 최종 상태를 측정하면, \\(x_0\\)나 \\(C^*\\) 값에 관계없이 \\(s \\cdot L = 0 \\pmod 2\\) 라는 조건을 만족하는 문자열 \\(s\\)를 100% 확률로 얻게 됩니다. (정확히는 \\(s \\cdot L = 0\\)을 만족하는 \\(N/2\\)개의 \\(s\\) 중 하나를 균일한 확률(\\(2/N\\))로 샘플링합니다.)\n\n\n\n“한 방에(one-shot)” 끝나지 않습니다. 1회 실행으로 \\(L\\)에 대한 하나의 선형 방정식 \\(s^{(1)} \\cdot L = 0\\) 만 얻습니다.\n\\(L\\)을 유일하게 결정하기 위해서는 \\(n-1\\)개의 서로 독립인(linearly independent) 선형 방정식이 필요합니다.\n전체 알고리즘: 1. \\(T = O(n)\\) 번 (예: \\(T=4n\\)번) \\(H-Q_F-H \\to \\text{Measure}\\) 회로를 반복 실행합니다. 2. \\(T\\)개의 (독립이 아닐 수도 있는) 방정식 \\(s^{(i)} \\cdot L = 0\\) 을 얻습니다. 3. (고전적 후처리): 이 \\(T\\)개의 방정식으로 \\(n \\times n\\) 선형 시스템(linear system)을 만듭니다. 4. 가우시안 소거법(Gaussian elimination) (고전 \\(O(n^3)\\))을 \\(\\mathbb{F}_2\\) 상에서 수행하여 이 연립방정식을 풉니다. 5. \\(n-1\\)개의 독립 방정식을 높은 확률로 얻게 되며, 해 공간(solution space)은 \\(\\{0, L\\}\\) (1차원)이 됩니다. 6. \\(L \\neq 0\\) 약속에 따라, 유일한 비-영(non-zero) 해 \\(L\\)을 찾습니다.\n최종 결론: 고전적으로는 \\(\\Omega(2^{n/2})\\) (지수적) 시간이 걸리는 Simon의 문제를, 양자 컴퓨터는 \\(O(n)\\)번의 오라클 호출과 \\(O(n^3)\\)의 고전적 후처리, 즉 총 다항식(Polynomial) 시간에 해결했습니다.\n\n\n\n\n\nSimon의 알고리즘은 Shor 알고리즘의 핵심 원형(prototype)입니다.\n\n\n\n\n\n\n\n\n\nSimon’s Algorithm (L13)\nShor’s Algorithm (L16)\n\n\n\n\nGroup\n\\(\\mathbb{Z}_2^n\\) (n-bit 문자열과 \\(\\oplus\\))\n\\(\\mathbb{Z}_N\\) (정수와 \\(+ \\pmod N\\))\n\n\nPeriodicity\n\\(F(x) = F(x \\oplus L)\\)\n\\(F(x) = F(x + L) \\pmod N\\)\n\n\nFT\nBoolean FT (\\(H^{\\otimes n}\\))\nDiscrete FT (QFT)"
  },
  {
    "objectID": "posts/cs/quantum/l11 - xor-patterns-1/index.html",
    "href": "posts/cs/quantum/l11 - xor-patterns-1/index.html",
    "title": "L11. Revealing XOR-patterns I (Bernstein-Vazirani)",
    "section": "",
    "text": "L10에서 우리는 \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\) 형태의 모든 고전 함수를 “쓰레기(garbage)” 비트 없이 효율적인 양자 회로 \\(Q_F\\)로 변환할 수 있음을 배웠습니다. 이 \\(Q_F\\)는 고전 입력뿐만 아니라 중첩(superposition) 상태의 입력도 받을 수 있습니다.\n\n\n“양자 회로 \\(Q_F\\)가 \\(F\\)를 구현한다”는 것의 표준 정의는 다음과 같습니다.\n\\[Q_F: |x\\rangle |b\\rangle |0 \\dots 0\\rangle \\mapsto |x\\rangle |b \\oplus F(x)\\rangle |0 \\dots 0\\rangle\\]\n\n\\(|x\\rangle \\in \\{0,1\\}^n\\): 입력 레지스터 (input register)\n\\(|b\\rangle \\in \\{0,1\\}^m\\): 출력 레지스터 (output register) (보통 \\(|0\\rangle^{\\otimes m}\\)으로 초기화됨)\n\\(|0 \\dots 0\\rangle\\): 보조 큐비트 (ancillas) (연산 후 \\(|0\\rangle\\)으로 되돌아오는 “촉매”)\n\n(표기 편의상, ancilla 레지스터는 \\(Q_F: |x\\rangle |b\\rangle \\mapsto |x\\rangle |b \\oplus F(x)\\rangle\\)로 생략하고 쓸 수 있습니다.)\n\n\n\n\n\n가장 중요하고 빈번하게 사용되는 경우는 \\(m=1\\) (즉, \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\))일 때, 출력 레지스터를 \\(|-\\rangle\\) 상태로 초기화하는 것입니다.\n\nCase 3: \\(|b\\rangle = |-\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)\\)\n\n\\(Q_F\\)는 선형(linear) 연산자이므로, 중첩 상태의 각 항에 개별적으로 작용합니다.\n\\(Q_F \\left( |x\\rangle |-\\rangle \\right) = |x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |F(x)\\rangle - |\\neg F(x)\\rangle \\right) \\right]\\)\n\n\n이제 \\(F(x)\\)의 결과(0 또는 1)에 따라 이 상태가 어떻게 변하는지 살펴봅니다.\n\n만약 \\(F(x) = 0\\) 이라면:\n\n\\(|x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle - |1\\rangle \\right) \\right] = |x\\rangle |-\\rangle\\) (변화 없음)\n\n만약 \\(F(x) = 1\\) 이라면:\n\n\\(|x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |1\\rangle - |0\\rangle \\right) \\right] = -|x\\rangle |-\\rangle\\) (전체 위상에 -1이 붙음)\n\n\n\n\n이 두 경우를 하나로 합치면 “위상 반동(Phase Kickback)” (혹은 “부호 구현”) 트릭을 얻습니다.\n\\[Q_F \\left( |x\\rangle |-\\rangle \\right) = (-1)^{F(x)} |x\\rangle |-\\rangle\\]\n\\(F(x)\\)의 계산 결과(0 또는 1)가 출력 레지스터 \\(|-\\rangle\\)를 바꾸는 대신, 입력 레지스터 \\(|x\\rangle\\)에 \\(1\\) 또는 \\(-1\\)의 위상(부호)으로 “반동”되었습니다.\n\n중요성: 출력 레지스터 \\(|-\\rangle\\)는 연산 후에도 전혀 변하지 않고 입력 레지스터와 얽히지(entangled) 않습니다.\n이는 입력 레지스터가 \\(\\sum_x \\alpha_x |x\\rangle\\)와 같은 중첩 상태일 때, \\(F(x)\\)의 정보를 각 \\(|x\\rangle\\) 항의 위상에만 깨끗하게(entanglement 없이) 저장할 수 있게 해줍니다.\n\n\\(Q_F \\left( \\left( \\sum_x \\alpha_x |x\\rangle \\right) |-\\rangle \\right) = \\left( \\sum_x \\alpha_x (-1)^{F(x)} |x\\rangle \\right) |-\\rangle\\)\n\n\n\n\n\n\n이 트릭을 사용해, \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\) 함수를 위한 “부호 오라클 (Sign Oracle)” \\(V_F\\)를 정의할 수 있습니다.\n\n[정의] 부호 구현 (Sign Implementation) \\(V_F\\)는 입력 레지스터 \\(|x\\rangle\\)에만 작용하며, \\(F(x)\\)의 값을 위상에 인코딩하는 연산이다. \\[V_F: |x\\rangle \\mapsto (-1)^{F(x)} |x\\rangle\\]\n\n\n\n\n\n\\(n=2\\)인 함수 \\(F(x_1, x_2) = x_1 \\oplus x_2\\) (NEQ 함수)를 살펴봅시다.\nNEQ 함수의 진리표 (Truth Table): * \\(F(00) = 0 \\implies (-1)^{F(00)} = +1\\) * \\(F(01) = 1 \\implies (-1)^{F(01)} = -1\\) * \\(F(10) = 1 \\implies (-1)^{F(10)} = -1\\) * \\(F(11) = 0 \\implies (-1)^{F(11)} = +1\\)\n\n\n\n\\(F(x)\\)의 패턴을 추출하기 위해, “Compute” 단계(Oracle) 앞뒤로 “Rotate” 단계(Hadamard)를 추가합니다. 이것이 양자 알고리즘의 표준적인 H-V-H 구조입니다.\n\nquantee 코드 스니펫 (H-V_F-H Structure):\n::: {quantee}\nqcircuit:\n  qubits: 3\n  circuit:\n    # 1. Rotate (Prepare input superposition)\n    - H: [0, 1]\n    # Prepare ancilla for Phase Kickback\n    - X: 2\n    - H: 2\n    - barrier: true\n    # 2. Compute (Oracle V_F implementation)\n    - gate: Q_F\n      qubits: [0, 1, 2]\n      props:\n        name: 'V_F(NEQ)'\n        label: 'U_f'\n    - barrier: true\n    # 3. Rotate (Extract information)\n    - H: [0, 1]\n    - barrier: true\n    - measure: [0, 1]\n:::\n\n\n\n\n[Rotate 1] 준비 (\\(H^{\\otimes 2}\\)):\n\n\\(H^{\\otimes 2} |00\\rangle = |++\\rangle = \\frac{1}{2} \\left( |00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle \\right)\\)\n\n[Compute] 계산 (\\(V_F\\)): \\(V_F\\)를 적용하여 위상에 NEQ 진리표를 인코딩합니다.\n\n\\(|\\psi_1\\rangle = V_F \\left[ \\frac{1}{2} \\left( |00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle \\right) \\right]\\)\n\\(|\\psi_1\\rangle = \\frac{1}{2} \\left( (+1)|00\\rangle + (-1)|01\\rangle + (-1)|10\\rangle + (+1)|11\\rangle \\right)\\)\n\n[Rotate 2] 추출 (\\(H^{\\otimes 2}\\)): \\(|\\psi_1\\rangle\\)에 \\(H^{\\otimes 2}\\)를 다시 적용합니다. 이 과정에서 \\(F(x)\\)의 패턴 정보가 “간섭(Interference)”을 통해 추출됩니다.\n\n\\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes 2} |\\psi_1\\rangle\\)\n\\(|11\\rangle\\) 상태로 결맞는 간섭(constructive interference)이 일어나고,\n다른 모든 상태(\\(|00\\rangle, |01\\rangle, |10\\rangle\\))는 상쇄 간섭(destructive interference)으로 진폭이 0이 됩니다.\n(계산 결과) \\(\\implies |\\psi_{\\text{final}}\\rangle = |11\\rangle\\)\n\n\n결과: \\(H-V_F-H\\) 회로를 실행한 후 입력 레지스터를 측정하면, 100% 확률로 \\(|11\\rangle\\)을 얻습니다. 이 \\(|11\\rangle\\)은 \\(F(x_1, x_2) = x_1 \\oplus x_2 = (\\mathbf{1} \\cdot x_1) \\oplus (\\mathbf{1} \\cdot x_2)\\)의 숨겨진 XOR-패턴인 \\(s^*=(1,1)\\)을 드러냅니다.\n\n\n\n\n\nL10에서 배운 “쓰레기 되돌리기(Uncomputing)”가 왜 필수적인지 다시 확인합니다. 만약 “Compute” 단계(\\(V_F\\))가 각 입력 \\(x\\)마다 다른 쓰레기 \\(|g_x\\rangle\\)를 생성한다면:\n\n\\(|\\psi_1\\rangle = \\frac{1}{2} \\left( (+1)|00\\rangle|g_0\\rangle + (-1)|01\\rangle|g_1\\rangle + (-1)|10\\rangle|g_2\\rangle + (+1)|11\\rangle|g_3\\rangle \\right)\\)\n\\(H^{\\otimes 2}\\) 적용 후 \\(|11\\rangle\\)의 최종 진폭은 \\(\\frac{1}{4} |11\\rangle \\otimes \\left( |g_0\\rangle + |g_1\\rangle + |g_2\\rangle + |g_3\\rangle \\right)\\)가 됩니다.\n만약 모든 쓰레기가 \\(|0\\rangle\\)으로 동일하면(\\(g_0=g_1=g_2=g_3=|0\\rangle\\)), 진폭은 \\(1 \\cdot |11\\rangle|0\\rangle\\)이 되어 완벽한 결맞는 간섭이 일어납니다.\n하지만 \\(g_x\\)들이 모두 다르다면, \\(\\left( \\dots \\right)\\) 항은 상쇄되지 않아 간섭 패턴이 망가지고 100% 확률을 얻지 못합니다.\n\n결론: 쓰레기 되돌리기(Uncomputing the garbage)는 간섭 패턴이 올바르게 나타나도록(interference patterns to emerge) 하는 데 매우 중요합니다.\n\n\n\n\n이 알고리즘을 \\(n\\)-qubit으로 일반화하여 수학적으로 분석합니다. ( \\(N = 2^n\\) )\n\n\n\\[\n|\\psi_0\\rangle = H^{\\otimes n} |0\\rangle^{\\otimes n} = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle\n\\]\n\n\n\n\\(\\hat{F}(x) = (-1)^{F(x)}\\)라고 정의하면, \\[\n|\\psi_1\\rangle = V_F |\\psi_0\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} \\hat{F}(x) |x\\rangle\n\\]\n\n\n\n\\(H^{\\otimes n}\\) 변환의 수학적 정의는 \\(s \\cdot x \\equiv \\sum_i s_i x_i \\pmod 2\\) (비트별 내적)을 사용하여 다음과 같이 표현됩니다.\n\n[정리] Hadamard Transform (BFT) \\[H^{\\otimes n} |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{s \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |s\\rangle\\]\n\n\\(H^{\\otimes n}\\)은 그 자체가 역변환이므로(\\(H^{\\otimes n} H^{\\otimes n} = I\\)), \\(x\\)와 \\(s\\)를 바꿔도 성립합니다.\n\n[따름정리 1] Inverse Hadamard Transform \\[H^{\\otimes n} |s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |x\\rangle\\]\n\n\n\n\n\n\n이제, 우리가 찾고자 하는 함수 \\(F(x)\\)가 실제로 숨겨진 문자열 \\(s^* \\in \\{0,1\\}^n\\) 와의 XOR-pattern이라고 가정합니다.\n가정: \\(F(x) = s^* \\cdot x\\) (NEQ 예제에서는 \\(s^*=(1,1)\\) 이었습니다.)\n\n[Rotate 1]: \\(|\\psi_0\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x |x\\rangle\\)\n[Compute]: \\(|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{F(x)} |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{s^* \\cdot x} |x\\rangle\\)\n[Rotate 2] (간섭): \\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_1\\rangle = H^{\\otimes n} \\left( \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{s^* \\cdot x} |x\\rangle \\right)\\)\n[따름정리 1]에 의해, 괄호 안의 식은 \\(H^{\\otimes n} |s^*\\rangle\\)와 정확히 같습니다.\n따라서, \\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} \\left( H^{\\otimes n} |s^*\\rangle \\right) = (H^{\\otimes n} H^{\\otimes n}) |s^*\\rangle = I |s^*\\rangle = |s^*\\rangle\\]\n\n최종 결론 (증명 완료): 만약 함수 \\(F(x)\\)가 \\(F(x) = s^* \\cdot x\\) 형태의 XOR-pattern이라면, \\(H-V-H\\) 알고리즘을 단 한 번 실행한 뒤 최종 상태를 측정하면, 우리는 100% 확률로 숨겨진 패턴 문자열 \\(|s^*\\rangle\\)를 얻습니다.\n\n\n\n\n이 결과는 Bernstein-Vazirani 알고리즘으로 알려져 있습니다.\n\n문제: \\(F(x) = s^* \\cdot x\\)를 계산하는 미스터리 오라클 \\(V_F\\)가 주어졌을 때, \\(s^*\\)를 찾으시오.\n양자 해법 (QC): \\(H-V_F-H\\) 회로를 통해 단 1번의 오라클 호출로 \\(s^*\\)를 100% 확률로 찾습니다. (중첩을 사용하여 \\(2^n\\)개의 모든 정보를 한 번에 처리)\n고전 해법 (CC): \\(s^*\\)의 \\(n\\)개 비트를 알아내기 위해, 최소 \\(n\\)번의 오라클 호출이 필요합니다. (예: \\(x=(1,0..0), x=(0,1..0)\\) 등을 차례로 입력)\n\nBernstein-Vazirani 알고리즘은 (오라클 모델에서) 1 (QC) vs \\(n\\) (CC)이라는, 양자 컴퓨팅과 고전 컴퓨팅의 능력에 “진정한 차이(genuine difference)”가 있음을 증명한 매우 중요한 사례입니다."
  },
  {
    "objectID": "posts/cs/quantum/l11 - xor-patterns-1/index.html#l11.-revealing-xor-patterns-i",
    "href": "posts/cs/quantum/l11 - xor-patterns-1/index.html#l11.-revealing-xor-patterns-i",
    "title": "L11. Revealing XOR-patterns I (Bernstein-Vazirani)",
    "section": "",
    "text": "L10에서 우리는 \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\) 형태의 모든 고전 함수를 “쓰레기(garbage)” 비트 없이 효율적인 양자 회로 \\(Q_F\\)로 변환할 수 있음을 배웠습니다. 이 \\(Q_F\\)는 고전 입력뿐만 아니라 중첩(superposition) 상태의 입력도 받을 수 있습니다.\n\n\n“양자 회로 \\(Q_F\\)가 \\(F\\)를 구현한다”는 것의 표준 정의는 다음과 같습니다.\n\\[Q_F: |x\\rangle |b\\rangle |0 \\dots 0\\rangle \\mapsto |x\\rangle |b \\oplus F(x)\\rangle |0 \\dots 0\\rangle\\]\n\n\\(|x\\rangle \\in \\{0,1\\}^n\\): 입력 레지스터 (input register)\n\\(|b\\rangle \\in \\{0,1\\}^m\\): 출력 레지스터 (output register) (보통 \\(|0\\rangle^{\\otimes m}\\)으로 초기화됨)\n\\(|0 \\dots 0\\rangle\\): 보조 큐비트 (ancillas) (연산 후 \\(|0\\rangle\\)으로 되돌아오는 “촉매”)\n\n(표기 편의상, ancilla 레지스터는 \\(Q_F: |x\\rangle |b\\rangle \\mapsto |x\\rangle |b \\oplus F(x)\\rangle\\)로 생략하고 쓸 수 있습니다.)\n\n\n\n\n\n가장 중요하고 빈번하게 사용되는 경우는 \\(m=1\\) (즉, \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\))일 때, 출력 레지스터를 \\(|-\\rangle\\) 상태로 초기화하는 것입니다.\n\nCase 3: \\(|b\\rangle = |-\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle - |1\\rangle)\\)\n\n\\(Q_F\\)는 선형(linear) 연산자이므로, 중첩 상태의 각 항에 개별적으로 작용합니다.\n\\(Q_F \\left( |x\\rangle |-\\rangle \\right) = |x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |F(x)\\rangle - |\\neg F(x)\\rangle \\right) \\right]\\)\n\n\n이제 \\(F(x)\\)의 결과(0 또는 1)에 따라 이 상태가 어떻게 변하는지 살펴봅니다.\n\n만약 \\(F(x) = 0\\) 이라면:\n\n\\(|x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle - |1\\rangle \\right) \\right] = |x\\rangle |-\\rangle\\) (변화 없음)\n\n만약 \\(F(x) = 1\\) 이라면:\n\n\\(|x\\rangle \\otimes \\left[ \\frac{1}{\\sqrt{2}} \\left( |1\\rangle - |0\\rangle \\right) \\right] = -|x\\rangle |-\\rangle\\) (전체 위상에 -1이 붙음)\n\n\n\n\n이 두 경우를 하나로 합치면 “위상 반동(Phase Kickback)” (혹은 “부호 구현”) 트릭을 얻습니다.\n\\[Q_F \\left( |x\\rangle |-\\rangle \\right) = (-1)^{F(x)} |x\\rangle |-\\rangle\\]\n\\(F(x)\\)의 계산 결과(0 또는 1)가 출력 레지스터 \\(|-\\rangle\\)를 바꾸는 대신, 입력 레지스터 \\(|x\\rangle\\)에 \\(1\\) 또는 \\(-1\\)의 위상(부호)으로 “반동”되었습니다.\n\n중요성: 출력 레지스터 \\(|-\\rangle\\)는 연산 후에도 전혀 변하지 않고 입력 레지스터와 얽히지(entangled) 않습니다.\n이는 입력 레지스터가 \\(\\sum_x \\alpha_x |x\\rangle\\)와 같은 중첩 상태일 때, \\(F(x)\\)의 정보를 각 \\(|x\\rangle\\) 항의 위상에만 깨끗하게(entanglement 없이) 저장할 수 있게 해줍니다.\n\n\\(Q_F \\left( \\left( \\sum_x \\alpha_x |x\\rangle \\right) |-\\rangle \\right) = \\left( \\sum_x \\alpha_x (-1)^{F(x)} |x\\rangle \\right) |-\\rangle\\)\n\n\n\n\n\n\n이 트릭을 사용해, \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\) 함수를 위한 “부호 오라클 (Sign Oracle)” \\(V_F\\)를 정의할 수 있습니다.\n\n[정의] 부호 구현 (Sign Implementation) \\(V_F\\)는 입력 레지스터 \\(|x\\rangle\\)에만 작용하며, \\(F(x)\\)의 값을 위상에 인코딩하는 연산이다. \\[V_F: |x\\rangle \\mapsto (-1)^{F(x)} |x\\rangle\\]\n\n\n\n\n\n\\(n=2\\)인 함수 \\(F(x_1, x_2) = x_1 \\oplus x_2\\) (NEQ 함수)를 살펴봅시다.\nNEQ 함수의 진리표 (Truth Table): * \\(F(00) = 0 \\implies (-1)^{F(00)} = +1\\) * \\(F(01) = 1 \\implies (-1)^{F(01)} = -1\\) * \\(F(10) = 1 \\implies (-1)^{F(10)} = -1\\) * \\(F(11) = 0 \\implies (-1)^{F(11)} = +1\\)\n\n\n\n\\(F(x)\\)의 패턴을 추출하기 위해, “Compute” 단계(Oracle) 앞뒤로 “Rotate” 단계(Hadamard)를 추가합니다. 이것이 양자 알고리즘의 표준적인 H-V-H 구조입니다.\n\nquantee 코드 스니펫 (H-V_F-H Structure):\n::: {quantee}\nqcircuit:\n  qubits: 3\n  circuit:\n    # 1. Rotate (Prepare input superposition)\n    - H: [0, 1]\n    # Prepare ancilla for Phase Kickback\n    - X: 2\n    - H: 2\n    - barrier: true\n    # 2. Compute (Oracle V_F implementation)\n    - gate: Q_F\n      qubits: [0, 1, 2]\n      props:\n        name: 'V_F(NEQ)'\n        label: 'U_f'\n    - barrier: true\n    # 3. Rotate (Extract information)\n    - H: [0, 1]\n    - barrier: true\n    - measure: [0, 1]\n:::\n\n\n\n\n[Rotate 1] 준비 (\\(H^{\\otimes 2}\\)):\n\n\\(H^{\\otimes 2} |00\\rangle = |++\\rangle = \\frac{1}{2} \\left( |00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle \\right)\\)\n\n[Compute] 계산 (\\(V_F\\)): \\(V_F\\)를 적용하여 위상에 NEQ 진리표를 인코딩합니다.\n\n\\(|\\psi_1\\rangle = V_F \\left[ \\frac{1}{2} \\left( |00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle \\right) \\right]\\)\n\\(|\\psi_1\\rangle = \\frac{1}{2} \\left( (+1)|00\\rangle + (-1)|01\\rangle + (-1)|10\\rangle + (+1)|11\\rangle \\right)\\)\n\n[Rotate 2] 추출 (\\(H^{\\otimes 2}\\)): \\(|\\psi_1\\rangle\\)에 \\(H^{\\otimes 2}\\)를 다시 적용합니다. 이 과정에서 \\(F(x)\\)의 패턴 정보가 “간섭(Interference)”을 통해 추출됩니다.\n\n\\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes 2} |\\psi_1\\rangle\\)\n\\(|11\\rangle\\) 상태로 결맞는 간섭(constructive interference)이 일어나고,\n다른 모든 상태(\\(|00\\rangle, |01\\rangle, |10\\rangle\\))는 상쇄 간섭(destructive interference)으로 진폭이 0이 됩니다.\n(계산 결과) \\(\\implies |\\psi_{\\text{final}}\\rangle = |11\\rangle\\)\n\n\n결과: \\(H-V_F-H\\) 회로를 실행한 후 입력 레지스터를 측정하면, 100% 확률로 \\(|11\\rangle\\)을 얻습니다. 이 \\(|11\\rangle\\)은 \\(F(x_1, x_2) = x_1 \\oplus x_2 = (\\mathbf{1} \\cdot x_1) \\oplus (\\mathbf{1} \\cdot x_2)\\)의 숨겨진 XOR-패턴인 \\(s^*=(1,1)\\)을 드러냅니다.\n\n\n\n\n\nL10에서 배운 “쓰레기 되돌리기(Uncomputing)”가 왜 필수적인지 다시 확인합니다. 만약 “Compute” 단계(\\(V_F\\))가 각 입력 \\(x\\)마다 다른 쓰레기 \\(|g_x\\rangle\\)를 생성한다면:\n\n\\(|\\psi_1\\rangle = \\frac{1}{2} \\left( (+1)|00\\rangle|g_0\\rangle + (-1)|01\\rangle|g_1\\rangle + (-1)|10\\rangle|g_2\\rangle + (+1)|11\\rangle|g_3\\rangle \\right)\\)\n\\(H^{\\otimes 2}\\) 적용 후 \\(|11\\rangle\\)의 최종 진폭은 \\(\\frac{1}{4} |11\\rangle \\otimes \\left( |g_0\\rangle + |g_1\\rangle + |g_2\\rangle + |g_3\\rangle \\right)\\)가 됩니다.\n만약 모든 쓰레기가 \\(|0\\rangle\\)으로 동일하면(\\(g_0=g_1=g_2=g_3=|0\\rangle\\)), 진폭은 \\(1 \\cdot |11\\rangle|0\\rangle\\)이 되어 완벽한 결맞는 간섭이 일어납니다.\n하지만 \\(g_x\\)들이 모두 다르다면, \\(\\left( \\dots \\right)\\) 항은 상쇄되지 않아 간섭 패턴이 망가지고 100% 확률을 얻지 못합니다.\n\n결론: 쓰레기 되돌리기(Uncomputing the garbage)는 간섭 패턴이 올바르게 나타나도록(interference patterns to emerge) 하는 데 매우 중요합니다.\n\n\n\n\n이 알고리즘을 \\(n\\)-qubit으로 일반화하여 수학적으로 분석합니다. ( \\(N = 2^n\\) )\n\n\n\\[\n|\\psi_0\\rangle = H^{\\otimes n} |0\\rangle^{\\otimes n} = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle\n\\]\n\n\n\n\\(\\hat{F}(x) = (-1)^{F(x)}\\)라고 정의하면, \\[\n|\\psi_1\\rangle = V_F |\\psi_0\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} \\hat{F}(x) |x\\rangle\n\\]\n\n\n\n\\(H^{\\otimes n}\\) 변환의 수학적 정의는 \\(s \\cdot x \\equiv \\sum_i s_i x_i \\pmod 2\\) (비트별 내적)을 사용하여 다음과 같이 표현됩니다.\n\n[정리] Hadamard Transform (BFT) \\[H^{\\otimes n} |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{s \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |s\\rangle\\]\n\n\\(H^{\\otimes n}\\)은 그 자체가 역변환이므로(\\(H^{\\otimes n} H^{\\otimes n} = I\\)), \\(x\\)와 \\(s\\)를 바꿔도 성립합니다.\n\n[따름정리 1] Inverse Hadamard Transform \\[H^{\\otimes n} |s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |x\\rangle\\]\n\n\n\n\n\n\n이제, 우리가 찾고자 하는 함수 \\(F(x)\\)가 실제로 숨겨진 문자열 \\(s^* \\in \\{0,1\\}^n\\) 와의 XOR-pattern이라고 가정합니다.\n가정: \\(F(x) = s^* \\cdot x\\) (NEQ 예제에서는 \\(s^*=(1,1)\\) 이었습니다.)\n\n[Rotate 1]: \\(|\\psi_0\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x |x\\rangle\\)\n[Compute]: \\(|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{F(x)} |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{s^* \\cdot x} |x\\rangle\\)\n[Rotate 2] (간섭): \\(|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_1\\rangle = H^{\\otimes n} \\left( \\frac{1}{\\sqrt{N}} \\sum_x (-1)^{s^* \\cdot x} |x\\rangle \\right)\\)\n[따름정리 1]에 의해, 괄호 안의 식은 \\(H^{\\otimes n} |s^*\\rangle\\)와 정확히 같습니다.\n따라서, \\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} \\left( H^{\\otimes n} |s^*\\rangle \\right) = (H^{\\otimes n} H^{\\otimes n}) |s^*\\rangle = I |s^*\\rangle = |s^*\\rangle\\]\n\n최종 결론 (증명 완료): 만약 함수 \\(F(x)\\)가 \\(F(x) = s^* \\cdot x\\) 형태의 XOR-pattern이라면, \\(H-V-H\\) 알고리즘을 단 한 번 실행한 뒤 최종 상태를 측정하면, 우리는 100% 확률로 숨겨진 패턴 문자열 \\(|s^*\\rangle\\)를 얻습니다.\n\n\n\n\n이 결과는 Bernstein-Vazirani 알고리즘으로 알려져 있습니다.\n\n문제: \\(F(x) = s^* \\cdot x\\)를 계산하는 미스터리 오라클 \\(V_F\\)가 주어졌을 때, \\(s^*\\)를 찾으시오.\n양자 해법 (QC): \\(H-V_F-H\\) 회로를 통해 단 1번의 오라클 호출로 \\(s^*\\)를 100% 확률로 찾습니다. (중첩을 사용하여 \\(2^n\\)개의 모든 정보를 한 번에 처리)\n고전 해법 (CC): \\(s^*\\)의 \\(n\\)개 비트를 알아내기 위해, 최소 \\(n\\)번의 오라클 호출이 필요합니다. (예: \\(x=(1,0..0), x=(0,1..0)\\) 등을 차례로 입력)\n\nBernstein-Vazirani 알고리즘은 (오라클 모델에서) 1 (QC) vs \\(n\\) (CC)이라는, 양자 컴퓨팅과 고전 컴퓨팅의 능력에 “진정한 차이(genuine difference)”가 있음을 증명한 매우 중요한 사례입니다."
  },
  {
    "objectID": "posts/cs/quantum/l17 - hsp/index.html",
    "href": "posts/cs/quantum/l17 - hsp/index.html",
    "title": "L17. The Hidden Subgroup Problem (HSP)",
    "section": "",
    "text": "숨겨진 부분군 문제(Hidden Subgroup Problem, HSP)는 우리가 지금까지 배운 모든 주요 양자 알고리즘(Bernstein-Vazirani, Simon, Shor/Period-Finding)을 아우르는 매우 강력하고 일반적인 통합 프레임워크(generalization)입니다.\n이 문제들은 모두 “어떤 함수 \\(F\\)의 숨겨진 대칭성(패턴)”을 찾는 문제이며, “양자 푸리에 샘플링(Quantum Fourier Sampling)”이라는 동일한 패러다임을 사용하여 효율적으로 해결됩니다.\n우리가 배운 알고리즘들은 모두 “어떤 그룹(Group) \\(G\\)의 숨겨진 부분군(Subgroup) \\(H\\)를 찾는 문제”로 일반화될 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n알고리즘 (Lec.)\n그룹 (Group \\(G\\))\n함수 \\(F: G \\to \\text{COLORS}\\)\n약속 (Promise) / 구조\n목표 (Find)\n\n\n\n\nBernstein-Vazirani (L11-12)\n\\(\\mathbb{Z}_2^n\\) (XOR)\n\\(F: \\mathbb{Z}_2^n \\to \\{0,1\\}\\)\n\\(F(x) = s \\cdot x\\)\n\\(s\\) 찾기 (Dual group)\n\n\nSimon’s (L13)\n\\(\\mathbb{Z}_2^n\\) (XOR)\n\\(F: \\mathbb{Z}_2^n \\to \\text{COLORS}\\)\n\\(F(x) = F(x \\oplus L)\\) (2-to-1)\n\\(H = \\{0, L\\}\\)\n\n\nPeriod-Finding (L15)\n\\(\\mathbb{Z}_N\\) (Arithmetic)\n\\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\)\n\\(F(x) = F(x+L \\pmod N)\\)\n\\(H = \\langle L \\rangle\\)\n\n\nShor’s (현실) (L16)\n\\(\\mathbb{Z}\\) (Integers)\n\\(F: \\mathbb{Z} \\to \\text{COLORS}\\)\n\\(F(x) = F(x+L)\\)\n\\(H = \\langle L \\rangle\\)\n\n\n\n\n\n\n\nHSP를 정의하기 위해, “그룹”, “부분군”, “잉여류”라는 세 가지 수학적 용어가 필요합니다.\n\n\n그룹 \\((G, *)\\)는 집합 \\(G\\)와 결합법칙/항등원/역원을 만족하는 이항 연산 \\(* **\\)의 쌍입니다. * 아벨 그룹 (Abelian):** \\(x * y = y * x\\) (교환법칙 성립). (HSP가 쉬운 경우) * 예: \\((\\mathbb{Z}_2^n, \\oplus)\\), \\((\\mathbb{Z}_N, +)\\), \\((\\mathbb{Z}_M^*, \\times)\\) * 비-아벨 그룹 (Non-Abelian): \\(x * y \\neq y * x\\) (교환법칙 성립 안 함). (HSP가 어려운 경우) * 예: \\(S_n\\) (대칭 그룹, 순열 합성), \\(D_N\\) (이명박 그룹, 도형 대칭)\n\n\n\n부분군 \\(H \\le G\\)는 \\(G\\)의 부분집합이면서, \\(G\\)의 연산 \\(*\\)에 대해 그 자체로도 그룹을 이루는 집합입니다. * (L13) \\(G = \\mathbb{Z}_2^n\\), \\(H = \\langle L \\rangle = \\{0, L\\}\\) * (L15) \\(G = \\mathbb{Z}_{24}\\), \\(H = \\langle 4 \\rangle = \\{0, 4, 8, 12, 16, 20\\}\\)\n\n\n\n잉여류 \\(x * H\\)는 부분군 \\(H\\)를 그룹 \\(G\\)의 다른 원소 \\(x\\)를 이용해 “이동(translate)”시킨 “복사본”입니다. (\\(x * H = \\{x * h \\mid h \\in H\\}\\)) * 그룹 \\(G\\)는 \\(H\\)의 서로소인(disjoint) 잉여류들로 완벽하게 분할(partition)됩니다. * (L15) \\(G = \\mathbb{Z}_{24}, H = \\langle 4 \\rangle\\)일 때, 잉여류는 \\(0+H, 1+H, 2+H, 3+H\\) 4개입니다.\n\n\n[정의] 숨겨진 부분군 문제 (HSP) for \\(G\\)\n\n입력 (Given): 그룹 \\(G\\)와, “\\(H\\)-주기” 함수 \\(F: G \\to \\text{COLORS}\\)를 구현하는 양자 오라클 \\(Q_F\\).\n약속 (Promise): \\(F\\)는 \\(G\\)의 “숨겨진 부분군” \\(H \\le G\\)에 대해 다음을 만족합니다. \\(F(x) = F(y) \\iff y \\in x*H\\) (즉, \\(F\\)는 \\(H\\)의 각 잉여류(coset) 내에서 상수이며, 잉여류 간에는 값이 다릅니다.)\n목표 (Goal): \\(Q_F\\)를 다항식 횟수만큼 호출하여, \\(H\\)의 생성자 집합(generating set)을 찾으시오.\n\n\n\n\n\n\n\n\n\n네, 매우 유용합니다. 많은 중요 문제들이 HSP로 환원될 수 있습니다.\n\n\n\n\n\n\n\n\nHSP over Group (G)\nG가 아벨 (Abelian)?\n“실제” 응용 문제 (HSP로 환원 가능)\n\n\n\n\n\\(\\mathbb{Z}_N\\) / \\(\\mathbb{Z}\\) (덧셈)\n예\n인수분해 (Factoring) (RSA 암호)\n\n\n\\(\\mathbb{Z}_{P-1} \\times \\mathbb{Z}_{P-1}\\) (덧셈)\n예\n이산 로그 (Discrete Log) (Diffie-Hellman, El Gamal 암호)\n\n\n\\(S_n\\) (Symmetric Group)\n아니오 (Non-Abelian)\n그래프 동형 (Graph Isomorphism) (고전적 “회색지대” 난제)\n\n\n\\(D_N\\) (Dihedral Group)\n아니오 (Non-Abelian)\n최단 벡터 문제 (SVP) (격자 기반 암호, PQC)\n\n\n\n\n\n\n고전 컴퓨터 과학의 “회색지대”(P도 아니고 NP-Complete도 아닐 것으로 추정되는) 3대 난제는 (1) 인수분해, (2) 이산 로그, (3) 그래프 동형입니다.\n놀랍게도 양자 컴퓨터(HSP)가 공격하는 대상은 정확히 이 “회색지대” 문제들입니다. 아벨 HSP는 (1), (2)를 다항식 시간에 해결했으며, 비-아벨 HSP는 (3)을 표적으로 삼고 있습니다.\n\n\n\n이것이 L17의 가장 중요한 핵심입니다.\n\nCase 1: \\(G\\)가 아벨 그룹(Abelian)일 때 ( \\(\\mathbb{Z}_N, \\mathbb{Z}_2^n\\) 등)\n\n답: 예 (YES).\n이유: “양자 푸리에 샘플링” 레시피가 완벽하게 작동합니다.\n\n[QFT] (효율적): \\(U_{\\text{QFT}_G}\\) (즉, \\(H^{\\otimes n}\\) 또는 QFT)가 \\(O(poly(n))\\) 게이트로 효율적이었습니다.\n[Clues \\(\\to\\) H] (효율적): QFT 측정 “단서”(\\(s \\cdot L=0\\) 또는 \\(s/N \\approx k/L\\))로부터 \\(H\\) (즉, \\(L\\))를 복원하는 고전적 후처리(선형대수, 연분수)가 \\(O(poly(n))\\)으로 효율적이었습니다.\n\n\nCase 2: \\(G\\)가 비-아벨 그룹(Non-Abelian)일 때 ( \\(S_n, D_N\\) 등)\n\n답: 모른다 (No, we don’t know how).\n이것이 현재 양자 알고리즘 연구의 가장 큰 난제(open problem)입니다.\n\n\n\n\n\n\n\n질문: 왜 비-아벨 HSP는 풀기 어려운가? QFT가 없어서? 답: 아닙니다. QFT는 있습니다. 하지만 “단서”를 해석할 방법(고전 후처리)을 모릅니다.\n1. [QFT]는 효율적이다: (Ettinger-Høyer-Knill ’04) 놀랍게도, \\(S_n\\)과 \\(D_N\\) 같은 복잡한 비-아벨 그룹에 대한 QFT조차 다항식(\\(poly(n)\\)) 시간의 양자 회로로 구현할 수 있음이 알려져 있습니다.\n2. [Clues \\(\\to\\) H] (진짜 병목): * 아벨 그룹에서는 \\(s \\cdot L = 0\\) 이나 \\(s/N \\approx j/L\\) 처럼 “단서” \\(s\\)와 “목표” \\(L\\)의 관계가 단순하여, GCD나 선형대수로 \\(L\\)을 쉽게 풀 수 있었습니다. * 비-아벨 그룹에서 나오는 “단서”는 훨씬 복잡한 수학적 객체(예: 그룹 표현의 라벨)이며, 이 “단서”들로부터 숨겨진 부분군 \\(H\\)의 생성자(generator)를 효율적으로 재구성(reconstruct)하는 고전적 후처리 알고리즘을 (대부분의 “흥미로운” 그룹에 대해) 아직 모릅니다.\n\n\n\n\n“QFT 패러다임”이 막혔으므로, HSP 문제를 다른 관점에서 바라볼 수 있습니다.\nHSP = 혼합 상태 구별 문제 1. [LOAD DATA]: \\(H-Q_F\\) 회로는 \\(H\\)의 임의의 잉여류(random coset)에 대한 균등 중첩 상태를 생성합니다. (L13, L15와 동일) * \\(|\\psi_1\\rangle = \\frac{1}{\\sqrt{|G|}} \\sum_{x \\in G} |x\\rangle |F(x)\\rangle\\) 2. [측정 무시]: 출력 레지스터(“색깔”)를 측정하지 않고 무시(trace out)하면, 3. [혼합 상태]: 입력 레지스터는 \\(H\\)의 모든 잉여류가 섞여 있는 “코셋 혼합 상태” \\(\\rho_H\\)가 됩니다. * \\(\\rho_H = \\frac{|H|}{|G|} \\sum_{\\text{cosets } x*H} |x*H\\rangle \\langle x*H|\\)\n문제 재정의: 우리는 \\(H\\)에 따라 달라지는 혼합 상태 \\(\\rho_H\\)를 생성하는 기계를 가지고 있습니다. 이 상태의 샘플(복사본)을 \\(k\\)개 받아서, 이 상태가 가능한 가설(\\(\\rho_{H_1}, \\rho_{H_2}, \\dots\\)) 중 어느 것인지 구별(distinguish)할 수 있습니까?\nEHK ’04의 반전: 1. 정보는 충분하다: \\(k = O(poly(n))\\)개의 샘플만 있으면, 정보 이론적으로(information-theoretically) \\(H\\)를 구별하기에 충분한 정보가 됩니다. 2. 계산이 불가능하다: 하지만, \\(H\\)를 “읽어내기” 위해 이 \\(k\\)개의 샘플에 어떤 효율적인 양자 측정(algorithmic measurement)을 수행해야 하는지는 아직 모릅니다.\n최종 결론: 비-아벨 HSP는 (QFT든 EHK든) “양자 상태에 숨겨진 \\(H\\) 정보를 효율적으로 추출하는 알고리즘적 측정/후처리 방법”을 모르기 때문에 풀리지 않고 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l17 - hsp/index.html#l17.-the-hidden-subgroup-problem-hsp",
    "href": "posts/cs/quantum/l17 - hsp/index.html#l17.-the-hidden-subgroup-problem-hsp",
    "title": "L17. The Hidden Subgroup Problem (HSP)",
    "section": "",
    "text": "숨겨진 부분군 문제(Hidden Subgroup Problem, HSP)는 우리가 지금까지 배운 모든 주요 양자 알고리즘(Bernstein-Vazirani, Simon, Shor/Period-Finding)을 아우르는 매우 강력하고 일반적인 통합 프레임워크(generalization)입니다.\n이 문제들은 모두 “어떤 함수 \\(F\\)의 숨겨진 대칭성(패턴)”을 찾는 문제이며, “양자 푸리에 샘플링(Quantum Fourier Sampling)”이라는 동일한 패러다임을 사용하여 효율적으로 해결됩니다.\n우리가 배운 알고리즘들은 모두 “어떤 그룹(Group) \\(G\\)의 숨겨진 부분군(Subgroup) \\(H\\)를 찾는 문제”로 일반화될 수 있습니다.\n\n\n\n\n\n\n\n\n\n\n알고리즘 (Lec.)\n그룹 (Group \\(G\\))\n함수 \\(F: G \\to \\text{COLORS}\\)\n약속 (Promise) / 구조\n목표 (Find)\n\n\n\n\nBernstein-Vazirani (L11-12)\n\\(\\mathbb{Z}_2^n\\) (XOR)\n\\(F: \\mathbb{Z}_2^n \\to \\{0,1\\}\\)\n\\(F(x) = s \\cdot x\\)\n\\(s\\) 찾기 (Dual group)\n\n\nSimon’s (L13)\n\\(\\mathbb{Z}_2^n\\) (XOR)\n\\(F: \\mathbb{Z}_2^n \\to \\text{COLORS}\\)\n\\(F(x) = F(x \\oplus L)\\) (2-to-1)\n\\(H = \\{0, L\\}\\)\n\n\nPeriod-Finding (L15)\n\\(\\mathbb{Z}_N\\) (Arithmetic)\n\\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\)\n\\(F(x) = F(x+L \\pmod N)\\)\n\\(H = \\langle L \\rangle\\)\n\n\nShor’s (현실) (L16)\n\\(\\mathbb{Z}\\) (Integers)\n\\(F: \\mathbb{Z} \\to \\text{COLORS}\\)\n\\(F(x) = F(x+L)\\)\n\\(H = \\langle L \\rangle\\)\n\n\n\n\n\n\n\nHSP를 정의하기 위해, “그룹”, “부분군”, “잉여류”라는 세 가지 수학적 용어가 필요합니다.\n\n\n그룹 \\((G, *)\\)는 집합 \\(G\\)와 결합법칙/항등원/역원을 만족하는 이항 연산 \\(* **\\)의 쌍입니다. * 아벨 그룹 (Abelian):** \\(x * y = y * x\\) (교환법칙 성립). (HSP가 쉬운 경우) * 예: \\((\\mathbb{Z}_2^n, \\oplus)\\), \\((\\mathbb{Z}_N, +)\\), \\((\\mathbb{Z}_M^*, \\times)\\) * 비-아벨 그룹 (Non-Abelian): \\(x * y \\neq y * x\\) (교환법칙 성립 안 함). (HSP가 어려운 경우) * 예: \\(S_n\\) (대칭 그룹, 순열 합성), \\(D_N\\) (이명박 그룹, 도형 대칭)\n\n\n\n부분군 \\(H \\le G\\)는 \\(G\\)의 부분집합이면서, \\(G\\)의 연산 \\(*\\)에 대해 그 자체로도 그룹을 이루는 집합입니다. * (L13) \\(G = \\mathbb{Z}_2^n\\), \\(H = \\langle L \\rangle = \\{0, L\\}\\) * (L15) \\(G = \\mathbb{Z}_{24}\\), \\(H = \\langle 4 \\rangle = \\{0, 4, 8, 12, 16, 20\\}\\)\n\n\n\n잉여류 \\(x * H\\)는 부분군 \\(H\\)를 그룹 \\(G\\)의 다른 원소 \\(x\\)를 이용해 “이동(translate)”시킨 “복사본”입니다. (\\(x * H = \\{x * h \\mid h \\in H\\}\\)) * 그룹 \\(G\\)는 \\(H\\)의 서로소인(disjoint) 잉여류들로 완벽하게 분할(partition)됩니다. * (L15) \\(G = \\mathbb{Z}_{24}, H = \\langle 4 \\rangle\\)일 때, 잉여류는 \\(0+H, 1+H, 2+H, 3+H\\) 4개입니다.\n\n\n[정의] 숨겨진 부분군 문제 (HSP) for \\(G\\)\n\n입력 (Given): 그룹 \\(G\\)와, “\\(H\\)-주기” 함수 \\(F: G \\to \\text{COLORS}\\)를 구현하는 양자 오라클 \\(Q_F\\).\n약속 (Promise): \\(F\\)는 \\(G\\)의 “숨겨진 부분군” \\(H \\le G\\)에 대해 다음을 만족합니다. \\(F(x) = F(y) \\iff y \\in x*H\\) (즉, \\(F\\)는 \\(H\\)의 각 잉여류(coset) 내에서 상수이며, 잉여류 간에는 값이 다릅니다.)\n목표 (Goal): \\(Q_F\\)를 다항식 횟수만큼 호출하여, \\(H\\)의 생성자 집합(generating set)을 찾으시오.\n\n\n\n\n\n\n\n\n\n네, 매우 유용합니다. 많은 중요 문제들이 HSP로 환원될 수 있습니다.\n\n\n\n\n\n\n\n\nHSP over Group (G)\nG가 아벨 (Abelian)?\n“실제” 응용 문제 (HSP로 환원 가능)\n\n\n\n\n\\(\\mathbb{Z}_N\\) / \\(\\mathbb{Z}\\) (덧셈)\n예\n인수분해 (Factoring) (RSA 암호)\n\n\n\\(\\mathbb{Z}_{P-1} \\times \\mathbb{Z}_{P-1}\\) (덧셈)\n예\n이산 로그 (Discrete Log) (Diffie-Hellman, El Gamal 암호)\n\n\n\\(S_n\\) (Symmetric Group)\n아니오 (Non-Abelian)\n그래프 동형 (Graph Isomorphism) (고전적 “회색지대” 난제)\n\n\n\\(D_N\\) (Dihedral Group)\n아니오 (Non-Abelian)\n최단 벡터 문제 (SVP) (격자 기반 암호, PQC)\n\n\n\n\n\n\n고전 컴퓨터 과학의 “회색지대”(P도 아니고 NP-Complete도 아닐 것으로 추정되는) 3대 난제는 (1) 인수분해, (2) 이산 로그, (3) 그래프 동형입니다.\n놀랍게도 양자 컴퓨터(HSP)가 공격하는 대상은 정확히 이 “회색지대” 문제들입니다. 아벨 HSP는 (1), (2)를 다항식 시간에 해결했으며, 비-아벨 HSP는 (3)을 표적으로 삼고 있습니다.\n\n\n\n이것이 L17의 가장 중요한 핵심입니다.\n\nCase 1: \\(G\\)가 아벨 그룹(Abelian)일 때 ( \\(\\mathbb{Z}_N, \\mathbb{Z}_2^n\\) 등)\n\n답: 예 (YES).\n이유: “양자 푸리에 샘플링” 레시피가 완벽하게 작동합니다.\n\n[QFT] (효율적): \\(U_{\\text{QFT}_G}\\) (즉, \\(H^{\\otimes n}\\) 또는 QFT)가 \\(O(poly(n))\\) 게이트로 효율적이었습니다.\n[Clues \\(\\to\\) H] (효율적): QFT 측정 “단서”(\\(s \\cdot L=0\\) 또는 \\(s/N \\approx k/L\\))로부터 \\(H\\) (즉, \\(L\\))를 복원하는 고전적 후처리(선형대수, 연분수)가 \\(O(poly(n))\\)으로 효율적이었습니다.\n\n\nCase 2: \\(G\\)가 비-아벨 그룹(Non-Abelian)일 때 ( \\(S_n, D_N\\) 등)\n\n답: 모른다 (No, we don’t know how).\n이것이 현재 양자 알고리즘 연구의 가장 큰 난제(open problem)입니다.\n\n\n\n\n\n\n\n질문: 왜 비-아벨 HSP는 풀기 어려운가? QFT가 없어서? 답: 아닙니다. QFT는 있습니다. 하지만 “단서”를 해석할 방법(고전 후처리)을 모릅니다.\n1. [QFT]는 효율적이다: (Ettinger-Høyer-Knill ’04) 놀랍게도, \\(S_n\\)과 \\(D_N\\) 같은 복잡한 비-아벨 그룹에 대한 QFT조차 다항식(\\(poly(n)\\)) 시간의 양자 회로로 구현할 수 있음이 알려져 있습니다.\n2. [Clues \\(\\to\\) H] (진짜 병목): * 아벨 그룹에서는 \\(s \\cdot L = 0\\) 이나 \\(s/N \\approx j/L\\) 처럼 “단서” \\(s\\)와 “목표” \\(L\\)의 관계가 단순하여, GCD나 선형대수로 \\(L\\)을 쉽게 풀 수 있었습니다. * 비-아벨 그룹에서 나오는 “단서”는 훨씬 복잡한 수학적 객체(예: 그룹 표현의 라벨)이며, 이 “단서”들로부터 숨겨진 부분군 \\(H\\)의 생성자(generator)를 효율적으로 재구성(reconstruct)하는 고전적 후처리 알고리즘을 (대부분의 “흥미로운” 그룹에 대해) 아직 모릅니다.\n\n\n\n\n“QFT 패러다임”이 막혔으므로, HSP 문제를 다른 관점에서 바라볼 수 있습니다.\nHSP = 혼합 상태 구별 문제 1. [LOAD DATA]: \\(H-Q_F\\) 회로는 \\(H\\)의 임의의 잉여류(random coset)에 대한 균등 중첩 상태를 생성합니다. (L13, L15와 동일) * \\(|\\psi_1\\rangle = \\frac{1}{\\sqrt{|G|}} \\sum_{x \\in G} |x\\rangle |F(x)\\rangle\\) 2. [측정 무시]: 출력 레지스터(“색깔”)를 측정하지 않고 무시(trace out)하면, 3. [혼합 상태]: 입력 레지스터는 \\(H\\)의 모든 잉여류가 섞여 있는 “코셋 혼합 상태” \\(\\rho_H\\)가 됩니다. * \\(\\rho_H = \\frac{|H|}{|G|} \\sum_{\\text{cosets } x*H} |x*H\\rangle \\langle x*H|\\)\n문제 재정의: 우리는 \\(H\\)에 따라 달라지는 혼합 상태 \\(\\rho_H\\)를 생성하는 기계를 가지고 있습니다. 이 상태의 샘플(복사본)을 \\(k\\)개 받아서, 이 상태가 가능한 가설(\\(\\rho_{H_1}, \\rho_{H_2}, \\dots\\)) 중 어느 것인지 구별(distinguish)할 수 있습니까?\nEHK ’04의 반전: 1. 정보는 충분하다: \\(k = O(poly(n))\\)개의 샘플만 있으면, 정보 이론적으로(information-theoretically) \\(H\\)를 구별하기에 충분한 정보가 됩니다. 2. 계산이 불가능하다: 하지만, \\(H\\)를 “읽어내기” 위해 이 \\(k\\)개의 샘플에 어떤 효율적인 양자 측정(algorithmic measurement)을 수행해야 하는지는 아직 모릅니다.\n최종 결론: 비-아벨 HSP는 (QFT든 EHK든) “양자 상태에 숨겨진 \\(H\\) 정보를 효율적으로 추출하는 알고리즘적 측정/후처리 방법”을 모르기 때문에 풀리지 않고 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l16 - shor/index.html",
    "href": "posts/cs/quantum/l16 - shor/index.html",
    "title": "L16. Shor’s Factoring Algorithm",
    "section": "",
    "text": "Shor의 인수분해 알고리즘은 100% 양자 알고리즘이 아닙니다. 이 알고리즘은 “양자 컴퓨터가 매우 잘하는 핵심 서브루틴” (L15: 주기 찾기)과, 이를 활용하는 “영리한 고전 정수론”의 조합입니다.\nShor의 천재성은 고전적으로 지수적 시간이 걸렸던 “주기 찾기(Order-Finding)”라는 단 하나의 병목 단계를 양자 컴퓨터로 대체한 데 있습니다.\n\n\nL15에서 우리는 다음과 같은 강력한 양자 서브루틴(Subroutine)을 완성했습니다.\n\n입력 (Input): 주기 \\(L\\)을 가진 함수 \\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\)를 구현하는 양자 오라클 \\(Q_F\\).\n알고리즘: \\(H-Q_F-QFT \\to \\text{Measure}\\) (L15의 푸리에 샘플링)\n비용 (Cost): \\(O(n^2)\\) 또는 (근사) \\(O(n \\log n)\\) 게이트. (\\(n = \\log N\\))\n출력 (The “Clue”): 알고리즘을 1회 실행하면, 고전적인 정수 \\(s\\)를 측정합니다.\n\n“Good” (확률 \\(\\ge 40.5\\%\\)): \\(s\\)는 \\(L\\)에 대한 “좋은 단서”입니다. \\[s = \\text{Nearest Integer}\\left(k \\cdot \\frac{N}{L}\\right) \\quad (\\text{for a random } k \\in \\{0, \\dots, L-1\\})\\]\n“Junk” (확률 \\(\\le 59.5\\%\\)): \\(s\\)는 \\(L\\)과 관계없는 “쓰레기” 값입니다.\n\n\n\n\n\n\n우리의 목표는 \\(n\\)비트 정수 \\(M = P \\cdot Q\\) (\\(P, Q\\)는 소수)를 인수분해하는 것입니다. 이 문제는 1970년대(Gary Miller)부터 “위수 찾기(Order-Finding)” 문제로 (고전적으로) 환원될 수 있음이 알려져 있었습니다.\n핵심 정수론 트릭: 1의 비자명한 제곱근 * \\(M=PQ\\)일 때, \\(R \\not\\equiv \\pm 1 \\pmod M\\) 이면서 \\(R^2 \\equiv 1 \\pmod M\\)을 만족하는 “비자명한(nontrivial)” 해 \\(R\\)을 찾으면, * \\((R-1)(R+1) \\equiv 0 \\pmod M\\) 이고, \\(M\\)은 두 항 중 어느 쪽도 나누지 못하므로, * \\(\\text{gcd}(R-1, M) = P\\) (또는 \\(Q\\))가 되어 인수분해에 성공합니다. * Shor의 전략: 임의의 \\(A\\)의 “위수(order)” \\(L\\)을 찾아서, \\(R = A^{L/2}\\)로 이 “비자명한” \\(R\\)을 만듭니다.\n\n\n\n[1] (고전) \\(A\\) 선택: \\(1 &lt; A &lt; M-1\\) 범위에서 임의의 정수 \\(A\\)를 고릅니다.\n[2] (고전) GCD 확인: \\(\\text{gcd}(A, M)\\)을 계산(\\(O(n^3)\\))합니다.\n\n\\(G &gt; 1\\)이면, \\(G\\)가 \\(M\\)의 소인수(\\(P\\) 또는 \\(Q\\))입니다. (성공, 종료)\n\\(G = 1\\) (즉, \\(A \\in \\mathbb{Z}_M^*\\))이라고 가정합니다.\n\n[3] (양자) 주기 찾기:\n\n함수 \\(F_A(x) = A^x \\pmod M\\) 를 정의합니다.\n\\(F_A(x)\\)의 주기 \\(L\\) (즉, \\(A^L \\equiv 1 \\pmod M\\)을 만족하는 최소 \\(L\\))을 L15의 양자 서브루틴을 이용해 찾습니다. (이것이 유일한 양자 단계입니다.)\n\n[4] (고전) “행운” 확인 1: \\(L\\)이 짝수(even)인지 확인합니다. (홀수이면 1단계로 돌아가 \\(A\\)를 다시 선택)\n[5] (고전) \\(R\\) 계산: \\(R = A^{L/2} \\pmod M\\) 을 계산(\\(O(n^3)\\))합니다.\n[6] (고전) “행운” 확인 2: \\(R \\not\\equiv -1 \\pmod M\\) 인지 확인합니다. ( \\(-1\\) 이면 “사소한” 해이므로 1단계로 돌아가 \\(A\\)를 다시 선택)\n[7] (고전) 인수분해:\n\n우리는 \\(R \\not\\equiv \\pm 1 \\pmod M\\) 이면서 \\(R^2 \\equiv 1 \\pmod M\\) 인 “비자명한” \\(R\\)을 찾았습니다.\n\\(P = \\text{gcd}(R-1, M)\\) (\\(O(n^3)\\))\n\\(Q = \\text{gcd}(R+1, M)\\) (\\(O(n^3)\\))\n\n\n\n\n\n\n\n\n\nShor 알고리즘의 진정한 병목(bottleneck)은 QFT(\\(O(n^2)\\))가 아니라, 3단계에서 \\(F_A(x) = A^x \\pmod M\\) 함수를 구현하는 양자 오라클 \\(Q_F\\)입니다.\n\n\\(F_A(x)\\)는 “반복 제곱(repeated squaring)”을 통해 고전적으로 \\(O(n^3)\\) (또는 \\(O(n^2 \\log n \\dots)\\)) 시간에 계산할 수 있습니다.\nL10에 따라, 이 고전 회로는 \\(O(n^3)\\) 게이트를 사용하는 가역 양자 회로 \\(Q_F\\)로 효율적으로 변환될 수 있습니다.\n총 복잡도: ( \\(O(1)\\)번 반복 \\(\\times\\) [ \\(O(n^3)\\) 오라클 + \\(O(n^2)\\) QFT ] ) + \\(O(n^3)\\) 고전 후처리 \\(\\implies\\) \\(O(n^3)\\) (다항식 시간)\n\n\n\n\n4, 6단계에서 실패(L이 홀수이거나 \\(R \\equiv -1\\))하고 1단계로 돌아갈 확률은 얼마일까요?\n\n[핵심 보조정리 (Shor)] \\(M=PQ\\) (서로 다른 두 홀수 소수의 곱)일 때, \\(A \\in \\mathbb{Z}_M^*\\)를 무작위로 선택하면, “성공”할 확률 (즉, \\(L\\)이 짝수이고 \\(A^{L/2} \\not\\equiv -1 \\pmod M\\) 일 확률)은\n\\(\\text{Pr}[\\text{Success}] \\ge \\frac{1}{2}\\)\n\n\n증명 (Sketch): 중국인의 나머지 정리(CRT)에 의해 \\(\\mathbb{Z}_M^* \\cong \\mathbb{Z}_P^* \\times \\mathbb{Z}_Q^*\\) 입니다. \\(A \\leftrightarrow (A_P, A_Q)\\) 이고 \\(L = \\text{lcm}(L_P, L_Q)\\) 입니다.\n(운 1) \\(\\text{Pr}[L \\text{ is even}] = 1 - \\text{Pr}[L_P \\text{ odd}]\\text{Pr}[L_Q \\text{ odd}] = 1 - (1/2)(1/2) = \\mathbf{3/4}\\) 입니다.\n(운 2) “실패”(\\(A^{L/2} \\equiv -1\\))는 \\(A \\leftrightarrow (-1, -1)\\) 쌍에 해당하며, 이는 \\(L_P, L_Q\\)의 \\(2\\)-adic power가 같을 때만 발생하여 확률을 \\(1/2\\) 이하로 낮춥니다.\n결론: \\(O(1)\\) (상수) 횟수만 알고리즘을 반복하면 1에 가까운 확률로 성공합니다.\n\n\n\n\n\n\n알고리즘의 마지막 퍼즐은 3단계에서 얻은 “양자 단서” \\(s \\approx k(N/L)\\)로부터 \\(L\\)을 고전적으로 복원하는 것입니다.\n\n문제: \\(\\frac{s}{N} \\approx \\frac{k}{L}\\) ( \\(s, N\\)은 알고 \\(k, L\\)은 모름)\n해법: 연분수 알고리즘 (Continued Fractions Algorithm, CFA)\nCFA는 \\(O(n^3)\\)의 고전적 시간 안에, “나쁜” 근사 분수 \\(\\frac{s}{N}\\)를 “최상의” 기약분수(lowest terms) \\(\\frac{k'}{L'}\\)로 변환합니다.\n\n\n\nCFA가 우리가 원하는 \\(k, L\\)을 정확히(혹은 \\(L\\)의 약수를) 찾는다는 것을 어떻게 보장할까요? 답: \\(N\\)을 \\(L^2\\)보다 훨씬 크게 설정했기 때문입니다.\n\nShor의 설정: \\(M\\)이 \\(m\\)비트일 때 \\(L &lt; M \\approx 2^m\\) 입니다. 우리는 \\(n=2m\\) (즉 \\(N=2^{2m} \\approx M^2\\)) 또는 \\(n=10m\\) 등으로 \\(N\\)을 설정합니다.\n보장된 근사: “좋은” \\(s\\)는 다음을 만족합니다: \\[\\left| \\frac{s}{N} - \\frac{k}{L} \\right| \\le \\frac{1}{2N}\\]\n정수론 정리 (Legendre): \\(\\left| x - \\frac{k}{L} \\right| \\le \\frac{1}{2L^2}\\)를 만족하면, CFA는 반드시 \\(\\frac{k}{L}\\) (혹은 그 약분)를 찾습니다.\nShor의 적용: 우리는 \\(N \\ge M^2 &gt; L^2\\) (즉, \\(\\frac{1}{2N} \\le \\frac{1}{2M^2} &lt; \\frac{1}{2L^2}\\)) 로 \\(N\\)을 설정했습니다.\n결론: 우리의 근사(\\(\\frac{1}{2N}\\))는 CFA가 작동하기 위한 조건(\\(\\frac{1}{2L^2}\\))보다 훨씬 더 정밀하므로, CFA는 반드시 \\(L\\)의 (약수) 후보 \\(L'\\)를 찾아냅니다.\n\n\n\n\n\n[1] (양자) \\(H-Q_F-QFT \\to \\text{Measure}\\)를 1회 실행하여 \\(s\\)를 얻습니다. (확률 \\(\\ge 40\\%\\)로 “좋음”)\n[2] (고전 \\(O(n^3)\\)) CFA를 \\(\\frac{s}{N}\\)에 적용하여 기약분수 후보 \\(\\frac{k'}{L'}\\)를 찾습니다.\n[3] (고전 \\(O(n^3)\\)) 검증 (Verification): \\(L'\\)가 “진짜” 주기의 약수인지 확인합니다. \\(\\implies A^{L'} \\pmod M\\)을 계산합니다.\n[4] 판정 (Decision):\n\n(실패) \\(A^{L'} \\not\\equiv 1 \\pmod M\\) 이면, \\(s\\)가 “Junk”였거나 \\(k\\)가 \\(L\\)과 서로소가 아니어서(예: \\(k/L = 2/6 \\to 1/3\\)) \\(L'\\)가 \\(L\\)이 아닌 \\(L\\)의 약수(3)로 나온 경우입니다. \\(\\implies\\) 1단계로 돌아가 양자 알고리즘을 다시 실행합니다. (LCM 방식 등으로 보완 가능)\n(성공) \\(A^{L'} \\equiv 1 \\pmod M\\) 이면, \\(L'=L\\) (또는 \\(L\\)의 약수)을 찾은 것입니다. \\(\\implies\\) 2.1절의 4~8단계(L이 짝수인지, \\(R\\)이 비자명한지 확인 후 \\(\\text{gcd}\\))를 진행합니다."
  },
  {
    "objectID": "posts/cs/quantum/l16 - shor/index.html#l16.-shors-factoring-algorithm",
    "href": "posts/cs/quantum/l16 - shor/index.html#l16.-shors-factoring-algorithm",
    "title": "L16. Shor’s Factoring Algorithm",
    "section": "",
    "text": "Shor의 인수분해 알고리즘은 100% 양자 알고리즘이 아닙니다. 이 알고리즘은 “양자 컴퓨터가 매우 잘하는 핵심 서브루틴” (L15: 주기 찾기)과, 이를 활용하는 “영리한 고전 정수론”의 조합입니다.\nShor의 천재성은 고전적으로 지수적 시간이 걸렸던 “주기 찾기(Order-Finding)”라는 단 하나의 병목 단계를 양자 컴퓨터로 대체한 데 있습니다.\n\n\nL15에서 우리는 다음과 같은 강력한 양자 서브루틴(Subroutine)을 완성했습니다.\n\n입력 (Input): 주기 \\(L\\)을 가진 함수 \\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\)를 구현하는 양자 오라클 \\(Q_F\\).\n알고리즘: \\(H-Q_F-QFT \\to \\text{Measure}\\) (L15의 푸리에 샘플링)\n비용 (Cost): \\(O(n^2)\\) 또는 (근사) \\(O(n \\log n)\\) 게이트. (\\(n = \\log N\\))\n출력 (The “Clue”): 알고리즘을 1회 실행하면, 고전적인 정수 \\(s\\)를 측정합니다.\n\n“Good” (확률 \\(\\ge 40.5\\%\\)): \\(s\\)는 \\(L\\)에 대한 “좋은 단서”입니다. \\[s = \\text{Nearest Integer}\\left(k \\cdot \\frac{N}{L}\\right) \\quad (\\text{for a random } k \\in \\{0, \\dots, L-1\\})\\]\n“Junk” (확률 \\(\\le 59.5\\%\\)): \\(s\\)는 \\(L\\)과 관계없는 “쓰레기” 값입니다.\n\n\n\n\n\n\n우리의 목표는 \\(n\\)비트 정수 \\(M = P \\cdot Q\\) (\\(P, Q\\)는 소수)를 인수분해하는 것입니다. 이 문제는 1970년대(Gary Miller)부터 “위수 찾기(Order-Finding)” 문제로 (고전적으로) 환원될 수 있음이 알려져 있었습니다.\n핵심 정수론 트릭: 1의 비자명한 제곱근 * \\(M=PQ\\)일 때, \\(R \\not\\equiv \\pm 1 \\pmod M\\) 이면서 \\(R^2 \\equiv 1 \\pmod M\\)을 만족하는 “비자명한(nontrivial)” 해 \\(R\\)을 찾으면, * \\((R-1)(R+1) \\equiv 0 \\pmod M\\) 이고, \\(M\\)은 두 항 중 어느 쪽도 나누지 못하므로, * \\(\\text{gcd}(R-1, M) = P\\) (또는 \\(Q\\))가 되어 인수분해에 성공합니다. * Shor의 전략: 임의의 \\(A\\)의 “위수(order)” \\(L\\)을 찾아서, \\(R = A^{L/2}\\)로 이 “비자명한” \\(R\\)을 만듭니다.\n\n\n\n[1] (고전) \\(A\\) 선택: \\(1 &lt; A &lt; M-1\\) 범위에서 임의의 정수 \\(A\\)를 고릅니다.\n[2] (고전) GCD 확인: \\(\\text{gcd}(A, M)\\)을 계산(\\(O(n^3)\\))합니다.\n\n\\(G &gt; 1\\)이면, \\(G\\)가 \\(M\\)의 소인수(\\(P\\) 또는 \\(Q\\))입니다. (성공, 종료)\n\\(G = 1\\) (즉, \\(A \\in \\mathbb{Z}_M^*\\))이라고 가정합니다.\n\n[3] (양자) 주기 찾기:\n\n함수 \\(F_A(x) = A^x \\pmod M\\) 를 정의합니다.\n\\(F_A(x)\\)의 주기 \\(L\\) (즉, \\(A^L \\equiv 1 \\pmod M\\)을 만족하는 최소 \\(L\\))을 L15의 양자 서브루틴을 이용해 찾습니다. (이것이 유일한 양자 단계입니다.)\n\n[4] (고전) “행운” 확인 1: \\(L\\)이 짝수(even)인지 확인합니다. (홀수이면 1단계로 돌아가 \\(A\\)를 다시 선택)\n[5] (고전) \\(R\\) 계산: \\(R = A^{L/2} \\pmod M\\) 을 계산(\\(O(n^3)\\))합니다.\n[6] (고전) “행운” 확인 2: \\(R \\not\\equiv -1 \\pmod M\\) 인지 확인합니다. ( \\(-1\\) 이면 “사소한” 해이므로 1단계로 돌아가 \\(A\\)를 다시 선택)\n[7] (고전) 인수분해:\n\n우리는 \\(R \\not\\equiv \\pm 1 \\pmod M\\) 이면서 \\(R^2 \\equiv 1 \\pmod M\\) 인 “비자명한” \\(R\\)을 찾았습니다.\n\\(P = \\text{gcd}(R-1, M)\\) (\\(O(n^3)\\))\n\\(Q = \\text{gcd}(R+1, M)\\) (\\(O(n^3)\\))\n\n\n\n\n\n\n\n\n\nShor 알고리즘의 진정한 병목(bottleneck)은 QFT(\\(O(n^2)\\))가 아니라, 3단계에서 \\(F_A(x) = A^x \\pmod M\\) 함수를 구현하는 양자 오라클 \\(Q_F\\)입니다.\n\n\\(F_A(x)\\)는 “반복 제곱(repeated squaring)”을 통해 고전적으로 \\(O(n^3)\\) (또는 \\(O(n^2 \\log n \\dots)\\)) 시간에 계산할 수 있습니다.\nL10에 따라, 이 고전 회로는 \\(O(n^3)\\) 게이트를 사용하는 가역 양자 회로 \\(Q_F\\)로 효율적으로 변환될 수 있습니다.\n총 복잡도: ( \\(O(1)\\)번 반복 \\(\\times\\) [ \\(O(n^3)\\) 오라클 + \\(O(n^2)\\) QFT ] ) + \\(O(n^3)\\) 고전 후처리 \\(\\implies\\) \\(O(n^3)\\) (다항식 시간)\n\n\n\n\n4, 6단계에서 실패(L이 홀수이거나 \\(R \\equiv -1\\))하고 1단계로 돌아갈 확률은 얼마일까요?\n\n[핵심 보조정리 (Shor)] \\(M=PQ\\) (서로 다른 두 홀수 소수의 곱)일 때, \\(A \\in \\mathbb{Z}_M^*\\)를 무작위로 선택하면, “성공”할 확률 (즉, \\(L\\)이 짝수이고 \\(A^{L/2} \\not\\equiv -1 \\pmod M\\) 일 확률)은\n\\(\\text{Pr}[\\text{Success}] \\ge \\frac{1}{2}\\)\n\n\n증명 (Sketch): 중국인의 나머지 정리(CRT)에 의해 \\(\\mathbb{Z}_M^* \\cong \\mathbb{Z}_P^* \\times \\mathbb{Z}_Q^*\\) 입니다. \\(A \\leftrightarrow (A_P, A_Q)\\) 이고 \\(L = \\text{lcm}(L_P, L_Q)\\) 입니다.\n(운 1) \\(\\text{Pr}[L \\text{ is even}] = 1 - \\text{Pr}[L_P \\text{ odd}]\\text{Pr}[L_Q \\text{ odd}] = 1 - (1/2)(1/2) = \\mathbf{3/4}\\) 입니다.\n(운 2) “실패”(\\(A^{L/2} \\equiv -1\\))는 \\(A \\leftrightarrow (-1, -1)\\) 쌍에 해당하며, 이는 \\(L_P, L_Q\\)의 \\(2\\)-adic power가 같을 때만 발생하여 확률을 \\(1/2\\) 이하로 낮춥니다.\n결론: \\(O(1)\\) (상수) 횟수만 알고리즘을 반복하면 1에 가까운 확률로 성공합니다.\n\n\n\n\n\n\n알고리즘의 마지막 퍼즐은 3단계에서 얻은 “양자 단서” \\(s \\approx k(N/L)\\)로부터 \\(L\\)을 고전적으로 복원하는 것입니다.\n\n문제: \\(\\frac{s}{N} \\approx \\frac{k}{L}\\) ( \\(s, N\\)은 알고 \\(k, L\\)은 모름)\n해법: 연분수 알고리즘 (Continued Fractions Algorithm, CFA)\nCFA는 \\(O(n^3)\\)의 고전적 시간 안에, “나쁜” 근사 분수 \\(\\frac{s}{N}\\)를 “최상의” 기약분수(lowest terms) \\(\\frac{k'}{L'}\\)로 변환합니다.\n\n\n\nCFA가 우리가 원하는 \\(k, L\\)을 정확히(혹은 \\(L\\)의 약수를) 찾는다는 것을 어떻게 보장할까요? 답: \\(N\\)을 \\(L^2\\)보다 훨씬 크게 설정했기 때문입니다.\n\nShor의 설정: \\(M\\)이 \\(m\\)비트일 때 \\(L &lt; M \\approx 2^m\\) 입니다. 우리는 \\(n=2m\\) (즉 \\(N=2^{2m} \\approx M^2\\)) 또는 \\(n=10m\\) 등으로 \\(N\\)을 설정합니다.\n보장된 근사: “좋은” \\(s\\)는 다음을 만족합니다: \\[\\left| \\frac{s}{N} - \\frac{k}{L} \\right| \\le \\frac{1}{2N}\\]\n정수론 정리 (Legendre): \\(\\left| x - \\frac{k}{L} \\right| \\le \\frac{1}{2L^2}\\)를 만족하면, CFA는 반드시 \\(\\frac{k}{L}\\) (혹은 그 약분)를 찾습니다.\nShor의 적용: 우리는 \\(N \\ge M^2 &gt; L^2\\) (즉, \\(\\frac{1}{2N} \\le \\frac{1}{2M^2} &lt; \\frac{1}{2L^2}\\)) 로 \\(N\\)을 설정했습니다.\n결론: 우리의 근사(\\(\\frac{1}{2N}\\))는 CFA가 작동하기 위한 조건(\\(\\frac{1}{2L^2}\\))보다 훨씬 더 정밀하므로, CFA는 반드시 \\(L\\)의 (약수) 후보 \\(L'\\)를 찾아냅니다.\n\n\n\n\n\n[1] (양자) \\(H-Q_F-QFT \\to \\text{Measure}\\)를 1회 실행하여 \\(s\\)를 얻습니다. (확률 \\(\\ge 40\\%\\)로 “좋음”)\n[2] (고전 \\(O(n^3)\\)) CFA를 \\(\\frac{s}{N}\\)에 적용하여 기약분수 후보 \\(\\frac{k'}{L'}\\)를 찾습니다.\n[3] (고전 \\(O(n^3)\\)) 검증 (Verification): \\(L'\\)가 “진짜” 주기의 약수인지 확인합니다. \\(\\implies A^{L'} \\pmod M\\)을 계산합니다.\n[4] 판정 (Decision):\n\n(실패) \\(A^{L'} \\not\\equiv 1 \\pmod M\\) 이면, \\(s\\)가 “Junk”였거나 \\(k\\)가 \\(L\\)과 서로소가 아니어서(예: \\(k/L = 2/6 \\to 1/3\\)) \\(L'\\)가 \\(L\\)이 아닌 \\(L\\)의 약수(3)로 나온 경우입니다. \\(\\implies\\) 1단계로 돌아가 양자 알고리즘을 다시 실행합니다. (LCM 방식 등으로 보완 가능)\n(성공) \\(A^{L'} \\equiv 1 \\pmod M\\) 이면, \\(L'=L\\) (또는 \\(L\\)의 약수)을 찾은 것입니다. \\(\\implies\\) 2.1절의 4~8단계(L이 짝수인지, \\(R\\)이 비자명한지 확인 후 \\(\\text{gcd}\\))를 진행합니다."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  },
  {
    "objectID": "index.html#분야별-탐구",
    "href": "index.html#분야별-탐구",
    "title": "My Tech & Math Blog",
    "section": "",
    "text": "이 블로그는 컴퓨터 과학과 수학의 다양한 주제를 다룹니다.\n\n\n\n컴파일러, 양자 컴퓨팅 등 컴퓨터 과학의 다양한 주제를 탐구합니다.\n\n\n\n측도론, 위상수학 등 순수 수학의 개념들을 정리합니다."
  },
  {
    "objectID": "posts/cs/index.html",
    "href": "posts/cs/index.html",
    "title": "Computer Science",
    "section": "",
    "text": "컴퓨터 과학의 다양한 주제를 탐구합니다. 관심 있는 분야를 선택하세요.\n\n\n\nCFG, SSA, 최적화 등 컴파일러 백엔드의 핵심 원리를 구현하고 분석합니다.\n\n\n\n쇼어 알고리즘 등 양자 컴퓨터의 핵심 알고리즘을 탐구합니다."
  },
  {
    "objectID": "posts/cs/index.html#computer-science",
    "href": "posts/cs/index.html#computer-science",
    "title": "Computer Science",
    "section": "",
    "text": "컴퓨터 과학의 다양한 주제를 탐구합니다. 관심 있는 분야를 선택하세요.\n\n\n\nCFG, SSA, 최적화 등 컴파일러 백엔드의 핵심 원리를 구현하고 분석합니다.\n\n\n\n쇼어 알고리즘 등 양자 컴퓨터의 핵심 알고리즘을 탐구합니다."
  },
  {
    "objectID": "posts/cs/quantum/index.html",
    "href": "posts/cs/quantum/index.html",
    "title": "양자 컴퓨팅 시리즈",
    "section": "",
    "text": "양자 알고리즘의 핵심 원리를 탐구합니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nL10. Basics of Quantum Computing\n\n\n\nQuantum Computing\n\nQuantum Basics\n\nReversible Computing\n\n\n\n양자 회로가 고전 회로보다 강력한지(QC &gt;= CC) 탐구합니다. 고전 연산의 비가역성(irreversibility) 문제를 &lt;쓰레기 되돌리기(uncomputing)&gt; 트릭으로 해결하고, 양자 병렬성을 위한 표준 연산 $|x|y|x|y …\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL11. Revealing XOR-patterns I (Bernstein-Vazirani)\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nBernstein-Vazirani\n\nOracle\n\n\n\n양자 알고리즘의 핵심인 &lt;위상 반동(Phase Kickback)&gt; 트릭을 배우고,  구조를 사용해 \\(F(x) = s^* \\cdot x\\) 형태의 숨겨진 XOR-pattern(s*)을 단 한 번의 호출로 찾는 Bernstein-Vazirani 알고리즘을 분석합니다.…\n\n\n\nAnalysis by Gemini\n\n\nNov 3, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL12. Revealing XOR-patterns II (Boolean Fourier Transform)\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nFourier Transform\n\nBernstein-Vazirani\n\nSimon's Algorithm\n\n\n\nL11의 H-V-H 알고리즘을 &lt;푸리에 샘플링&gt;이라는 일반적인 프레임워크로 확장합니다. 데이터 벡터와 양자 상태의 관계(정규화)를 정의하고, Boolean Fourier Transform (BFT)의 기저가 되는  \\(\\{|\\chi_s\\rangle\\}\\)의 직교성을 증명합니다. BFT 계수가…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL13. Simon’s Algorithm\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nSimon's Algorithm\n\nOracle\n\nExponential Speedup\n\n\n\n고전적으로는 지수적(\\(\\Omega(2^{n/2})\\)) 시간이 걸리는 &lt;숨겨진 주기(L)&gt; 탐색 문제를, 양자 컴퓨터가 다항식(\\(O(n)\\)) 시간에 해결하는 Simon의 알고리즘을 분석합니다. 다중 비트 출력을 처리하기 위해  구조를 사용하며, 측정을 통해 $s…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL14. the Fourier Transform over Z_N\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nQFT\n\nShor's Algorithm\n\n\n\nBoolean Fourier Transform (\\(\\mathbb{Z}_2^n\\))을 Arithmetic ( \\(\\mathbb{Z}_N\\))으로 일반화하여 Discrete Fourier Transform (DFT)을 정의합니다. &lt;그룹의 문자(Character)&gt; 개념을 통해 DFT 기저 $_s(x) =…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL15. Period-Finding (Simon’s Algorithm over Z_N)\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nQFT\n\nShor's Algorithm\n\nPeriod Finding\n\n\n\nShor 알고리즘의 핵심인 “주기 찾기” 문제를 \\(\\mathbb{Z}_N\\) (산술) 그룹으로 일반화합니다. “L|N” (이상적 주기)의 경우, QFT가 “펄스 열”을 “펄스 열”로 변환함을 증명하고, \\(\\text{gcd}\\)를 이용한 \\(O(1)\\)의 효율적인 후처리를 분석합니다. 나아가 “L nmid N”…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL16. Shor’s Factoring Algorithm\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nShor's Algorithm\n\nFactoring\n\nNumber Theory\n\nQFT\n\n\n\nShor의 인수분해 알고리즘을 분석합니다. 이 알고리즘은 1970년대의 고전 정수론(인수분해를 “위수 찾기”로 환원)과 L15의 양자 “주기 찾기” 서브루틴을 결합합니다. 알고리즘의 병목인 \\(O(n^3)\\)의 “모듈러 지수 연산” 오라클 구현과, \\(N \\gg L^2\\) 설정을 통해 “연분수 알고리즘”으로 양자…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL17. The Hidden Subgroup Problem (HSP)\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nHSP\n\nGroup Theory\n\nShor's Algorithm\n\nSimon's Algorithm\n\n\n\n지금까지 배운 모든 효율적인 양자 알고리즘(Bernstein-Vazirani, Simon, Shor)을 ‘숨겨진 부분군 문제(HSP)’라는 단일 프레임워크로 일반화합니다. HSP를 ’그룹 G의 숨겨진 부분군 H를 찾는 문제’로 공식 정의하고, ’아벨 그룹(Abelian)’ HSP가 효율적으로 풀리는…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\n\n\n\n\n\n\n\nL18. Grover’s Algorithm\n\n\n\nQuantum Computing\n\nQuantum Algorithms\n\nGrover's Algorithm\n\nSearch\n\nComplexity Theory\n\n\n\nShor의 “구조적” 주기 찾기와 달리, “비구조적(unstructured)” 검색 문제를 다룹니다. 고전 \\(O(N)\\)의 검색 복잡도를 \\(O(\\sqrt{N})\\)으로 낮추는 “이차적(quadratic)” 양자 속도 향상을 보이며, 이는 BBBV “94 정리에 의해 최적(optimal)임이 증명되었습니다.…\n\n\n\nAnalysis by Gemini\n\n\nNov 2, 2025\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/cs/quantum/l14 - qft-zn/index.html",
    "href": "posts/cs/quantum/l14 - qft-zn/index.html",
    "title": "L14. the Fourier Transform over Z_N",
    "section": "",
    "text": "L12 (BFT): \\(\\mathbb{Z}_2^n\\) (Boolean) 그룹 상의 푸리에 변환(BFT)을 배웠습니다. BFT(\\(H^{\\otimes n}\\))는 “XOR-패턴” 기저 \\(\\chi_s(x) = (-1)^{s \\cdot x}\\)로 데이터를 분해합니다.\nL13 (Simon’s): \\(F(x \\oplus L) = F(x)\\) 약속을 가진 Simon의 문제를 BFT(푸리에 샘플링)를 \\(O(n)\\)번 사용하여 \\(\\Omega(\\sqrt{N})\\)의 고전적 한계를 깨고 다항식 시간에 해결했습니다.\n\n\n\n\n\n이제 모든 것을 “Boolean” \\((\\{0,1\\}^n, \\oplus)\\)에서 “Arithmetic” \\((\\mathbb{Z}_N, + \\pmod N)\\)으로 일반화합니다. 이는 Shor의 인수분해 알고리즘의 수학적 기반이 됩니다.\n\nShor의 문맥: \\(F(x) = A^x \\pmod M\\) (주기 \\(L\\)을 가짐)의 주기를 찾는 것이 목표입니다. 이 주기 \\(L\\)은 \\(\\mathbb{Z}_N\\) (산술) 그룹의 주기입니다.\n데이터: \\(g: \\mathbb{Z}_N \\to \\mathbb{C}\\) (여기서 \\(\\mathbb{Z}_N = \\{0, 1, \\dots, N-1\\}\\))\n양자 상태: \\(|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} g(x) |x\\rangle\\) ( \\(|x\\rangle\\)는 \\(0\\)부터 \\(N-1\\)까지의 정수를 나타냅니다.)\n\n\n\n\\(N\\)개의 새로운 직교정규(orthonormal) 패턴 벡터 \\(\\{|\\chi_s\\rangle\\}_{s=0}^{N-1}\\)를 정의합니다.\n\n[정의] DFT 기저 벡터 1. \\(N\\)제곱근 (Root of Unity): \\(\\omega_N = e^{2\\pi i / N}\\) 2. 패턴 함수 (Character): \\(\\chi_s(x) = \\omega_N^{s \\cdot x}\\) 3. 패턴 기저 벡터 (Basis Vector): \\[|\\chi_s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} \\chi_s(x) |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} \\omega_N^{s \\cdot x} |x\\rangle\\]\n\n\n(직관) 이 패턴들은 \\(\\pm 1\\) (XOR)과 달리, \\(x\\)가 증가함에 따라 복소 평면의 단위원(unit circle)을 \\(s\\)번 회전하는 “이산적인 사인/코사인파(discrete (co)sines)”입니다.\n\n[Image of N-th roots of unity on the complex unit circle]\n\n\n\n\n\nDiscrete Fourier Transform (DFT)는 데이터 \\(|g\\rangle\\)를 이 새로운 “주파수” 기저 \\(\\{|\\chi_s\\rangle\\}\\)로 변환하는 것입니다. Quantum Fourier Transform (QFT)는 이 DFT를 구현하는 양자 회로 \\(U_{\\text{QFT}}\\)입니다.\n\n\n\\(N=2^n\\) (\\(n=\\log N\\))이라고 가정할 때의 계산 복잡도입니다.\n\n고전 (Naïve DFT): \\(O(N^2) = O((2^n)^2) = O(4^n)\\) \\(\\implies\\) 지수적\n고전 (FFT - Fast Fourier Transform): \\(O(N \\log N) = O(2^n \\cdot n)\\) \\(\\implies\\) 여전히 지수적\n양자 (QFT): \\(O(n^2)\\) 개의 1, 2-큐비트 게이트 \\(\\implies\\) 다항식\n\n\n[핵심] QFT는 고전적으로 지수적(\\(O(N \\log N)\\)) 시간이 걸리는 DFT 연산을 다항식(\\(O(n^2)\\)) 시간 안에 수행하는 양자 회로입니다.\n\n\n\n\n\n\n“패턴” 함수 \\(\\chi_s\\)가 “왜” \\(\\omega_N^{sx}\\) 형태여야 하는지에 대한 수학적 근거는, 이 함수가 \\(\\mathbb{Z}_N\\) 그룹의 연산 구조를 보존하는 “문자(Character)”이기 때문입니다.\n\nL12 (\\(\\mathbb{Z}_2^n\\)): \\(\\chi_s(x \\oplus y) = \\chi_s(x) \\cdot \\chi_s(y)\\) (XOR \\(\\to\\) 곱셈)\nL14 (\\(\\mathbb{Z}_N\\)): 우리는 \\(\\chi_s(x + y) = \\chi_s(x) \\cdot \\chi_s(y)\\) (덧셈 \\(\\to\\) 곱셈)을 원합니다.\n\n이 준동형 사상(homomorphism) 속성을 만족하는 함수를 유도하면, \\(\\chi_s(x) = \\chi_s(1)^x\\) 이고, \\(\\chi_s(N)=\\chi_s(0)=1\\) 이어야 하므로, \\(\\chi_s(1)^N = 1\\) 이어야 합니다. 즉, \\(\\chi_s(1)\\)은 \\(N\\)제곱근(\\(\\omega_N^s\\))이어야 하며, 따라서 \\(\\chi_s(x) = \\omega_N^{sx}\\) 형태가 됩니다.\n\n\n\n\nDFT 기저 \\(\\{|\\chi_s\\rangle\\}\\)가 직교정규(\\(\\langle \\chi_t | \\chi_s \\rangle = \\delta_{s,t}\\))임을 증명합니다.\n\\[\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x=0}^{N-1} (\\omega_N^{tx})^* \\omega_N^{sx} = \\frac{1}{N} \\sum_{x=0}^{N-1} \\omega_N^{(s-t)x}\\] \\(R = s-t\\) 라고 놓습니다.\n\nCase 1: \\(s = t\\) (정규성)\n\n\\(R = 0\\) 이므로, \\(\\langle \\chi_s | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x} \\omega_N^0 = \\frac{1}{N} \\sum_{x} 1 = \\frac{N}{N} = 1\\)\n\nCase 2: \\(s \\neq t\\) (직교성)\n\n\\(R \\neq 0\\) 이므로, \\(\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x=0}^{N-1} (\\omega_N^R)^x\\) 입니다.\n이는 공비가 \\(r = \\omega_N^R \\neq 1\\)인 등비수열(geometric series)의 합입니다.\n합은 \\(\\sum_{x=0}^{N-1} r^x = \\frac{1 - r^N}{1 - r} = \\frac{1 - (\\omega_N^N)^R}{1 - r} = \\frac{1 - 1^R}{1 - r} = 0\\) 입니다.\n\\(\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\cdot 0 = 0\\)\n\n\n결론: DFT 기저는 직교정규 기저이며, \\(U_{\\text{QFT}}\\)는 Unitary 행렬입니다.\n\n\n\n\n\\(N=2^n\\)일 때, \\(N \\times N\\) 행렬 \\(U_{\\text{QFT}}\\)를 어떻게 \\(O(n^2)\\) 게이트로 구현할 수 있을까요? 답: \\(U_{\\text{QFT}}\\) 변환은 인수분해(factorized)되어 얽히지 않은(unentangled) 곱 상태(product state)로 표현될 수 있기 때문입니다.\n\\(U_{\\text{QFT}}\\)가 표준 기저 \\(|x\\rangle\\)에 작용하는 정의를 \\(n\\)개의 비트로 분해하면 다음과 같습니다. \\[U_{\\text{QFT}} |x\\rangle = \\bigotimes_{j=0}^{n-1} \\left[ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + \\omega_N^{x \\cdot 2^j} |1\\rangle \\right) \\right]\\] (여기서 \\(j\\)는 큐비트 인덱스, \\(x\\)는 입력 정수)\n의미: * BFT(\\(H^{\\otimes n}\\))와 달리, QFT의 \\(j\\)번째 출력 큐비트의 위상은 여러 입력 비트 \\(x\\)에 의존합니다. * 예를 들어, \\(n=4\\)일 때 \\(|x\\rangle = |x_3 x_2 x_1 x_0\\rangle\\) ( \\(x = 8x_3 + 4x_2 + 2x_1 + 1x_0\\))라면: * 출력 큐비트 \\(y_3\\) (MSB)의 위상은 \\(\\omega_{16}^{8x} = (-1)^{x_0}\\) \\(\\implies\\) \\(x_0\\)에만 의존. * 출력 큐비트 \\(y_2\\)의 위상은 \\(\\omega_{16}^{4x}\\) \\(\\implies\\) \\(x_1, x_0\\)에 의존. * … * 출력 큐비트 \\(y_0\\) (LSB)의 위상은 \\(\\omega_{16}^{1x}\\) \\(\\implies\\) \\(x_3, x_2, x_1, x_0\\) 모두에 의존. * 이 의존성은 제어-위상 (\\(C\\)-\\(R_k\\)) 게이트를 사용하여 구현됩니다.\n\n회로 구성: \\(n\\)개의 \\(H\\) 게이트와 \\(\\frac{n(n-1)}{2}\\)개의 \\(C\\)-\\(R_k\\) 게이트가 필요합니다.\n총 게이트 수: \\(n + \\frac{n(n-1)}{2} = O(n^2)\\)\n(필요시 \\(O(n)\\)개의 SWAP 게이트로 출력 순서를 맞춥니다.)\n\n\n\n\n\n\\(O(n^2)\\) 회로에는 심각한 물리적 한계가 있습니다. \\(n=1024\\)일 때, \\(C\\)-\\(R_{1024}\\) 게이트는 \\(e^{2\\pi i / 2^{1024}}\\)라는 극도로 미세한(incredibly tiny) 위상 각도를 구현해야 하며, 이는 물리적으로 불가능합니다.\n해법 (Coppersmith): * \\(k\\)가 클 때(예: \\(k \\gg \\log n\\)), 위상 각도 \\(\\theta = 2\\pi / 2^k\\)는 \\(0\\)에 매우 가깝습니다. * 이러한 게이트들은 계산에 거의 영향을 미치지 않으므로 제거(remove)해도 됩니다. * 정확도 \\(\\epsilon\\)을 유지하면서 \\(O(\\log(n/\\epsilon))\\)보다 큰 \\(k\\)를 가진 게이트를 제거하면, 총 게이트 수는 \\(O(n \\log n)\\)으로 줄어듭니다.\n결론: Shor의 알고리즘과 같은 “푸리에 샘플링” 알고리즘은 이러한 작은 오류에 매우 강건(robust)합니다. 덕분에 우리는 (물리적으로 불가능한) \\(O(n^2)\\)의 정확한 QFT 대신, (물리적으로 가능하고 더 효율적인) \\(O(n \\log n)\\)의 근사 QFT를 사용하여 양자 알고리즘을 구현할 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l14 - qft-zn/index.html#l14.-the-fourier-transform-over-mathbbz_n",
    "href": "posts/cs/quantum/l14 - qft-zn/index.html#l14.-the-fourier-transform-over-mathbbz_n",
    "title": "L14. the Fourier Transform over Z_N",
    "section": "",
    "text": "L12 (BFT): \\(\\mathbb{Z}_2^n\\) (Boolean) 그룹 상의 푸리에 변환(BFT)을 배웠습니다. BFT(\\(H^{\\otimes n}\\))는 “XOR-패턴” 기저 \\(\\chi_s(x) = (-1)^{s \\cdot x}\\)로 데이터를 분해합니다.\nL13 (Simon’s): \\(F(x \\oplus L) = F(x)\\) 약속을 가진 Simon의 문제를 BFT(푸리에 샘플링)를 \\(O(n)\\)번 사용하여 \\(\\Omega(\\sqrt{N})\\)의 고전적 한계를 깨고 다항식 시간에 해결했습니다.\n\n\n\n\n\n이제 모든 것을 “Boolean” \\((\\{0,1\\}^n, \\oplus)\\)에서 “Arithmetic” \\((\\mathbb{Z}_N, + \\pmod N)\\)으로 일반화합니다. 이는 Shor의 인수분해 알고리즘의 수학적 기반이 됩니다.\n\nShor의 문맥: \\(F(x) = A^x \\pmod M\\) (주기 \\(L\\)을 가짐)의 주기를 찾는 것이 목표입니다. 이 주기 \\(L\\)은 \\(\\mathbb{Z}_N\\) (산술) 그룹의 주기입니다.\n데이터: \\(g: \\mathbb{Z}_N \\to \\mathbb{C}\\) (여기서 \\(\\mathbb{Z}_N = \\{0, 1, \\dots, N-1\\}\\))\n양자 상태: \\(|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} g(x) |x\\rangle\\) ( \\(|x\\rangle\\)는 \\(0\\)부터 \\(N-1\\)까지의 정수를 나타냅니다.)\n\n\n\n\\(N\\)개의 새로운 직교정규(orthonormal) 패턴 벡터 \\(\\{|\\chi_s\\rangle\\}_{s=0}^{N-1}\\)를 정의합니다.\n\n[정의] DFT 기저 벡터 1. \\(N\\)제곱근 (Root of Unity): \\(\\omega_N = e^{2\\pi i / N}\\) 2. 패턴 함수 (Character): \\(\\chi_s(x) = \\omega_N^{s \\cdot x}\\) 3. 패턴 기저 벡터 (Basis Vector): \\[|\\chi_s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} \\chi_s(x) |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} \\omega_N^{s \\cdot x} |x\\rangle\\]\n\n\n(직관) 이 패턴들은 \\(\\pm 1\\) (XOR)과 달리, \\(x\\)가 증가함에 따라 복소 평면의 단위원(unit circle)을 \\(s\\)번 회전하는 “이산적인 사인/코사인파(discrete (co)sines)”입니다.\n\n[Image of N-th roots of unity on the complex unit circle]\n\n\n\n\n\nDiscrete Fourier Transform (DFT)는 데이터 \\(|g\\rangle\\)를 이 새로운 “주파수” 기저 \\(\\{|\\chi_s\\rangle\\}\\)로 변환하는 것입니다. Quantum Fourier Transform (QFT)는 이 DFT를 구현하는 양자 회로 \\(U_{\\text{QFT}}\\)입니다.\n\n\n\\(N=2^n\\) (\\(n=\\log N\\))이라고 가정할 때의 계산 복잡도입니다.\n\n고전 (Naïve DFT): \\(O(N^2) = O((2^n)^2) = O(4^n)\\) \\(\\implies\\) 지수적\n고전 (FFT - Fast Fourier Transform): \\(O(N \\log N) = O(2^n \\cdot n)\\) \\(\\implies\\) 여전히 지수적\n양자 (QFT): \\(O(n^2)\\) 개의 1, 2-큐비트 게이트 \\(\\implies\\) 다항식\n\n\n[핵심] QFT는 고전적으로 지수적(\\(O(N \\log N)\\)) 시간이 걸리는 DFT 연산을 다항식(\\(O(n^2)\\)) 시간 안에 수행하는 양자 회로입니다.\n\n\n\n\n\n\n“패턴” 함수 \\(\\chi_s\\)가 “왜” \\(\\omega_N^{sx}\\) 형태여야 하는지에 대한 수학적 근거는, 이 함수가 \\(\\mathbb{Z}_N\\) 그룹의 연산 구조를 보존하는 “문자(Character)”이기 때문입니다.\n\nL12 (\\(\\mathbb{Z}_2^n\\)): \\(\\chi_s(x \\oplus y) = \\chi_s(x) \\cdot \\chi_s(y)\\) (XOR \\(\\to\\) 곱셈)\nL14 (\\(\\mathbb{Z}_N\\)): 우리는 \\(\\chi_s(x + y) = \\chi_s(x) \\cdot \\chi_s(y)\\) (덧셈 \\(\\to\\) 곱셈)을 원합니다.\n\n이 준동형 사상(homomorphism) 속성을 만족하는 함수를 유도하면, \\(\\chi_s(x) = \\chi_s(1)^x\\) 이고, \\(\\chi_s(N)=\\chi_s(0)=1\\) 이어야 하므로, \\(\\chi_s(1)^N = 1\\) 이어야 합니다. 즉, \\(\\chi_s(1)\\)은 \\(N\\)제곱근(\\(\\omega_N^s\\))이어야 하며, 따라서 \\(\\chi_s(x) = \\omega_N^{sx}\\) 형태가 됩니다.\n\n\n\n\nDFT 기저 \\(\\{|\\chi_s\\rangle\\}\\)가 직교정규(\\(\\langle \\chi_t | \\chi_s \\rangle = \\delta_{s,t}\\))임을 증명합니다.\n\\[\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x=0}^{N-1} (\\omega_N^{tx})^* \\omega_N^{sx} = \\frac{1}{N} \\sum_{x=0}^{N-1} \\omega_N^{(s-t)x}\\] \\(R = s-t\\) 라고 놓습니다.\n\nCase 1: \\(s = t\\) (정규성)\n\n\\(R = 0\\) 이므로, \\(\\langle \\chi_s | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x} \\omega_N^0 = \\frac{1}{N} \\sum_{x} 1 = \\frac{N}{N} = 1\\)\n\nCase 2: \\(s \\neq t\\) (직교성)\n\n\\(R \\neq 0\\) 이므로, \\(\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\sum_{x=0}^{N-1} (\\omega_N^R)^x\\) 입니다.\n이는 공비가 \\(r = \\omega_N^R \\neq 1\\)인 등비수열(geometric series)의 합입니다.\n합은 \\(\\sum_{x=0}^{N-1} r^x = \\frac{1 - r^N}{1 - r} = \\frac{1 - (\\omega_N^N)^R}{1 - r} = \\frac{1 - 1^R}{1 - r} = 0\\) 입니다.\n\\(\\langle \\chi_t | \\chi_s \\rangle = \\frac{1}{N} \\cdot 0 = 0\\)\n\n\n결론: DFT 기저는 직교정규 기저이며, \\(U_{\\text{QFT}}\\)는 Unitary 행렬입니다.\n\n\n\n\n\\(N=2^n\\)일 때, \\(N \\times N\\) 행렬 \\(U_{\\text{QFT}}\\)를 어떻게 \\(O(n^2)\\) 게이트로 구현할 수 있을까요? 답: \\(U_{\\text{QFT}}\\) 변환은 인수분해(factorized)되어 얽히지 않은(unentangled) 곱 상태(product state)로 표현될 수 있기 때문입니다.\n\\(U_{\\text{QFT}}\\)가 표준 기저 \\(|x\\rangle\\)에 작용하는 정의를 \\(n\\)개의 비트로 분해하면 다음과 같습니다. \\[U_{\\text{QFT}} |x\\rangle = \\bigotimes_{j=0}^{n-1} \\left[ \\frac{1}{\\sqrt{2}} \\left( |0\\rangle + \\omega_N^{x \\cdot 2^j} |1\\rangle \\right) \\right]\\] (여기서 \\(j\\)는 큐비트 인덱스, \\(x\\)는 입력 정수)\n의미: * BFT(\\(H^{\\otimes n}\\))와 달리, QFT의 \\(j\\)번째 출력 큐비트의 위상은 여러 입력 비트 \\(x\\)에 의존합니다. * 예를 들어, \\(n=4\\)일 때 \\(|x\\rangle = |x_3 x_2 x_1 x_0\\rangle\\) ( \\(x = 8x_3 + 4x_2 + 2x_1 + 1x_0\\))라면: * 출력 큐비트 \\(y_3\\) (MSB)의 위상은 \\(\\omega_{16}^{8x} = (-1)^{x_0}\\) \\(\\implies\\) \\(x_0\\)에만 의존. * 출력 큐비트 \\(y_2\\)의 위상은 \\(\\omega_{16}^{4x}\\) \\(\\implies\\) \\(x_1, x_0\\)에 의존. * … * 출력 큐비트 \\(y_0\\) (LSB)의 위상은 \\(\\omega_{16}^{1x}\\) \\(\\implies\\) \\(x_3, x_2, x_1, x_0\\) 모두에 의존. * 이 의존성은 제어-위상 (\\(C\\)-\\(R_k\\)) 게이트를 사용하여 구현됩니다.\n\n회로 구성: \\(n\\)개의 \\(H\\) 게이트와 \\(\\frac{n(n-1)}{2}\\)개의 \\(C\\)-\\(R_k\\) 게이트가 필요합니다.\n총 게이트 수: \\(n + \\frac{n(n-1)}{2} = O(n^2)\\)\n(필요시 \\(O(n)\\)개의 SWAP 게이트로 출력 순서를 맞춥니다.)\n\n\n\n\n\n\\(O(n^2)\\) 회로에는 심각한 물리적 한계가 있습니다. \\(n=1024\\)일 때, \\(C\\)-\\(R_{1024}\\) 게이트는 \\(e^{2\\pi i / 2^{1024}}\\)라는 극도로 미세한(incredibly tiny) 위상 각도를 구현해야 하며, 이는 물리적으로 불가능합니다.\n해법 (Coppersmith): * \\(k\\)가 클 때(예: \\(k \\gg \\log n\\)), 위상 각도 \\(\\theta = 2\\pi / 2^k\\)는 \\(0\\)에 매우 가깝습니다. * 이러한 게이트들은 계산에 거의 영향을 미치지 않으므로 제거(remove)해도 됩니다. * 정확도 \\(\\epsilon\\)을 유지하면서 \\(O(\\log(n/\\epsilon))\\)보다 큰 \\(k\\)를 가진 게이트를 제거하면, 총 게이트 수는 \\(O(n \\log n)\\)으로 줄어듭니다.\n결론: Shor의 알고리즘과 같은 “푸리에 샘플링” 알고리즘은 이러한 작은 오류에 매우 강건(robust)합니다. 덕분에 우리는 (물리적으로 불가능한) \\(O(n^2)\\)의 정확한 QFT 대신, (물리적으로 가능하고 더 효율적인) \\(O(n \\log n)\\)의 근사 QFT를 사용하여 양자 알고리즘을 구현할 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html",
    "title": "L10. Basics of Quantum Computing",
    "section": "",
    "text": "양자 컴퓨팅(Quantum Computing)을 다루기 전에, 고전 컴퓨팅(Classical Computing)의 회로 모델(Circuit Model)을 간단히 복습하며 시작하겠습니다.\n\n\n고전 회로 \\(C\\)는 특정 함수 \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\)를 계산합니다.\n\n입력 (Input): \\(n\\)개의 비트 \\(x_1, \\dots, x_n\\)\n게이트 (Gates): AND, OR, NOT (혹은 NAND, NOT과 같은 universal gate set)\n출력 (Output): \\(m\\)개의 비트 \\(y_1, \\dots, y_m\\)\n\n\n\n\n\n우리는 주로 효율성, 즉 게이트의 수가 입력 크기 \\(n\\)에 따라 어떻게 확장(scale)되는지에 초점을 맞춥니다. 효율성을 측정하는 간단한 척도는 게이트의 수(# of gates)입니다.\n\n\n\n“왜 하필 (파이썬 코드나 튜링 머신이 아닌) 회로 모델에 집중하는가?”\n결론부터 말하면, 회로의 게이트 수(# of gates)는 다른 모델(예: 튜링 머신, Python 코드)의 실행 시간(running time)과 다항식(polynomially) 관계로 비교 가능하기 때문입니다.\n핵심 정리 (Fact/Theorem): &gt; 만약 Python 코드 (혹은 튜링 머신 등)로 작성된 알고리즘이 함수 \\(F\\)를 \\(T\\) 스텝 안에 계산한다면, &gt; 이 함수 \\(F\\)를 계산하는 고전 회로를 최대 \\(O(T \\log T)\\)개의 게이트를 사용하여 만들 수 있습니다.\n실질적으로 다음과 같은 근사가 가능합니다: 게이트의 수 \\(\\approx\\) 알고리즘의 실행 시간 \\(T\\)\n\n\n\n\nShannon의 정리에 따르면, 거의 모든(Almost all) 불리언 함수(Boolean Function) \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\)는 최소 \\(\\Omega(2^n / n)\\)개의 게이트를 필요로 합니다.\n\\(n=500\\)만 되어도 \\(2^{500}\\)은 실행 불가능한(infeasible) 숫자입니다. 다행히도, 우리는 “모든” 함수가 아닌 “흥미로운” 특정 함수들(예: 소수 판별, 최단 경로 탐색 등)에만 관심이 있으며, 이러한 함수들은 다행히도 다항식(polynomial) 수의 게이트(\\(O(n^k)\\))로 해결할 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#l10.-basics-of-quantum-computing",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#l10.-basics-of-quantum-computing",
    "title": "L10. Basics of Quantum Computing",
    "section": "",
    "text": "양자 컴퓨팅(Quantum Computing)을 다루기 전에, 고전 컴퓨팅(Classical Computing)의 회로 모델(Circuit Model)을 간단히 복습하며 시작하겠습니다.\n\n\n고전 회로 \\(C\\)는 특정 함수 \\(F: \\{0,1\\}^n \\to \\{0,1\\}^m\\)를 계산합니다.\n\n입력 (Input): \\(n\\)개의 비트 \\(x_1, \\dots, x_n\\)\n게이트 (Gates): AND, OR, NOT (혹은 NAND, NOT과 같은 universal gate set)\n출력 (Output): \\(m\\)개의 비트 \\(y_1, \\dots, y_m\\)\n\n\n\n\n\n우리는 주로 효율성, 즉 게이트의 수가 입력 크기 \\(n\\)에 따라 어떻게 확장(scale)되는지에 초점을 맞춥니다. 효율성을 측정하는 간단한 척도는 게이트의 수(# of gates)입니다.\n\n\n\n“왜 하필 (파이썬 코드나 튜링 머신이 아닌) 회로 모델에 집중하는가?”\n결론부터 말하면, 회로의 게이트 수(# of gates)는 다른 모델(예: 튜링 머신, Python 코드)의 실행 시간(running time)과 다항식(polynomially) 관계로 비교 가능하기 때문입니다.\n핵심 정리 (Fact/Theorem): &gt; 만약 Python 코드 (혹은 튜링 머신 등)로 작성된 알고리즘이 함수 \\(F\\)를 \\(T\\) 스텝 안에 계산한다면, &gt; 이 함수 \\(F\\)를 계산하는 고전 회로를 최대 \\(O(T \\log T)\\)개의 게이트를 사용하여 만들 수 있습니다.\n실질적으로 다음과 같은 근사가 가능합니다: 게이트의 수 \\(\\approx\\) 알고리즘의 실행 시간 \\(T\\)\n\n\n\n\nShannon의 정리에 따르면, 거의 모든(Almost all) 불리언 함수(Boolean Function) \\(F: \\{0,1\\}^n \\to \\{0,1\\}\\)는 최소 \\(\\Omega(2^n / n)\\)개의 게이트를 필요로 합니다.\n\\(n=500\\)만 되어도 \\(2^{500}\\)은 실행 불가능한(infeasible) 숫자입니다. 다행히도, 우리는 “모든” 함수가 아닌 “흥미로운” 특정 함수들(예: 소수 판별, 최단 경로 탐색 등)에만 관심이 있으며, 이러한 함수들은 다행히도 다항식(polynomial) 수의 게이트(\\(O(n^k)\\))로 해결할 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#양자-회로-모델-quantum-circuit-model",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#양자-회로-모델-quantum-circuit-model",
    "title": "L10. Basics of Quantum Computing",
    "section": "양자 회로 모델 (Quantum Circuit Model)",
    "text": "양자 회로 모델 (Quantum Circuit Model)\n\n입력 (Input): \\(n\\)개의 큐비트. (예: \\(|0\\rangle^{\\otimes n}\\))\n연산 (Operation): 1-큐비트 게이트(H, Rotation)와 2-큐비트 게이트(CNOT) 등의 연속적인 적용. (이 조합은 \\(2^n \\times 2^n\\) Unitary 행렬 \\(U\\)로 표현됩니다.)\n출력 (Output): \\(m\\)개의 고전적인 비트를 얻기 위한 측정(Measurement).\n\n\n💡 핵심 원칙: 지연된 측정의 원리 (Principle of Deferred Measurement)\n양자 회로를 분석할 때 매우 유용한 원칙입니다.\n\n회로 중간에 측정이 포함되어 있더라도, 보조 큐비트(ancilla qubit) 등을 사용하여 모든 측정을 회로의 맨 마지막 단계로 미루는(defer) 것과 동일한(behave identically) 회로를 구성할 수 있습니다.\n\n따라서, 일반성을 잃지 않고 (WLOG), 모든 양자 회로는 “초기 상태 준비 \\(\\to\\) 단일 Unitary 연산 \\(U\\) \\(\\to\\) 최종 측정”의 단순한 형태로 가정하고 분석할 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#확률적-컴퓨팅-probabilistic-computing",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#확률적-컴퓨팅-probabilistic-computing",
    "title": "L10. Basics of Quantum Computing",
    "section": "확률적 컴퓨팅 (Probabilistic Computing)",
    "text": "확률적 컴퓨팅 (Probabilistic Computing)\n고전 회로에 무작위 동전 던지기(FLIP) 게이트를 추가한 모델입니다.\n\n확률적 회로의 “계산”\n확률적 회로 \\(C\\)가 함수 \\(F\\)를 계산한다는 것은, 모든 입력 \\(x\\)에 대해 오답을 낼 확률이 \\(\\epsilon \\le 1/3\\)처럼 작다는 것을 의미합니다. \\[\\text{Pr}[C(x) \\neq F(x)] \\le \\epsilon\\] (오류 확률이 크더라도 여러 번 반복(repeat)하면 오류를 지수적으로 줄일 수 있습니다.)\n중요한 사실 (BPP = P 추측): &gt; 확률적 컴퓨터(BPP)는 결정론적 컴퓨터(P)보다 지수적으로(exponentially) 빠르지는 않다고 여겨집니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#양자-컴퓨팅-vs-고전-컴퓨팅-qc-vs-cc",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#양자-컴퓨팅-vs-고전-컴퓨팅-qc-vs-cc",
    "title": "L10. Basics of Quantum Computing",
    "section": "양자 컴퓨팅 vs 고전 컴퓨팅 (QC vs CC)",
    "text": "양자 컴퓨팅 vs 고전 컴퓨팅 (QC vs CC)\nQ1. 양자 회로(QC)가 고전 회로(CC)보다 더 효율적으로 계산할 수 있는 함수 \\(F\\)가 존재하는가? * A: 그렇다고 생각합니다 (Yes, think so). (예: 인수분해 - Shor의 알고리즘)\nQ2. (반대로) 양자 회로는 최소한 고전 회로만큼 강력한가? (QC \\(\\ge\\) CC ?) * A: 예. 하지만 이를 보이려면 “가역성” 문제를 해결해야 합니다. * 고전적인 AND 게이트를 양자 회로로 어떻게 구현할 수 있을까요?\nQ3. 게이트의 종류가 중요한가? * A: 근본적으로 중요하지 않습니다. {모든 1-큐비트 게이트 + CNOT 게이트} 조합이면 모든 Unitary 연산을 근사할 수 있습니다 (Universal gate set)."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#q2.-양자-회로는-고전-회로만큼-강력한가-가역성-문제",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#q2.-양자-회로는-고전-회로만큼-강력한가-가역성-문제",
    "title": "L10. Basics of Quantum Computing",
    "section": "Q2. 양자 회로는 고전 회로만큼 강력한가? (가역성 문제)",
    "text": "Q2. 양자 회로는 고전 회로만큼 강력한가? (가역성 문제)\n\n1. 양자 게이트: 가역적 (Reversible)\n모든 양자 게이트 \\(U\\)는 Unitary (\\(UU^\\dagger = I\\))이며, 항상 역행렬(\\(U^\\dagger\\))을 가집니다. 이는 출력을 알면 입력을 알 수 있음을 의미합니다.\n\n\n2. 고전 AND 게이트: 비가역적 (Irreversible)\n입력 (00, 01, 10)은 모두 동일한 출력 0을 만듭니다. 출력 0에서 입력을 복원할 수 없으며, 이 과정에서 정보가 삭제(erase info)됩니다.\n\n\n3. 물리적 고찰: Landauer의 원리 (정보 삭제와 에너지)\nLandauer의 원리에 따르면, 계산 단계 자체가 아니라 “정보를 삭제(erasing info)”하는 비가역적 과정이 근본적으로 에너지(열)를 방출해야 합니다.\n\n가역적 연산 (예: NOT): 이론적으로 에너지 손실 없이 수행 가능합니다.\n비가역적 연산 (예: AND): 정보를 잃고 엔트로피가 증가하므로, 반드시 열을 방출해야 합니다.\n\n\n\n4. 해법: 고전 가역 컴퓨팅 (Classical Reversible Computing)\nCharles Bennett 등은 “보조 비트(Ancilla bits)”를 사용하여 모든 고전적 연산을 가역적으로 수행할 수 있음을 보였습니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#고전-연산의-가역적-구현-예시",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#고전-연산의-가역적-구현-예시",
    "title": "L10. Basics of Quantum Computing",
    "section": "고전 연산의 가역적 구현 (예시)",
    "text": "고전 연산의 가역적 구현 (예시)\n핵심 아이디어는 \\(y=F(x)\\)를 계산하는 대신, \\(U_F: |x\\rangle |0\\rangle \\mapsto |x\\rangle |F(x)\\rangle\\) 처럼 입력 \\(|x\\rangle\\)를 보존하면서 답을 “복사”하는 것입니다.\n\n1. FANOUT (복제 / CNOT)\n고전 비트 \\(x\\)를 \\(x, x\\)로 복제하는 연산은 CNOT 게이트로 완벽하게 구현됩니다.\n\n연산: \\(U_{\\text{CNOT}}: |x\\rangle |a\\rangle \\mapsto |x\\rangle |a \\oplus x\\rangle\\)\n구현: 보조 큐비트를 \\(|0\\rangle\\)으로 초기화하면 (\\(a=0\\)),\n\n\\(U_{\\text{CNOT}}: |x\\rangle |0\\rangle \\mapsto |x\\rangle |x\\rangle\\)\n\n\n\nquantee 코드 스니펫 (CNOT Gate):\n::: {quantee}\nqcircuit:\n  qubits: 2\n  circuit:\n    - CNOT: [0, 1] # 0번(제어), 1번(타겟)\n:::\n\n\n\n2. AND (논리곱 / Toffoli)\nToffoli (CCNOT) 게이트를 사용합니다.\n\n연산: \\(U_{\\text{Toffoli}}: |x_1\\rangle |x_2\\rangle |a\\rangle \\mapsto |x_1\\rangle |x_2\\rangle |a \\oplus (x_1 \\land x_2)\\rangle\\)\n구현: 보조 큐비트를 \\(|0\\rangle\\)으로 초기화하면 (\\(a=0\\)),\n\n\\(U_{\\text{Toffoli}}: |x_1\\rangle |x_2\\rangle |0\\rangle \\mapsto |x_1\\rangle |x_2\\rangle |x_1 \\land x_2\\rangle\\)\n\n\n\nquantee 코드 스니펫 (Toffoli Gate):\n::: {quantee}\nqcircuit:\n  qubits: 3\n  circuit:\n    - control: [0, 1]  # 0번, 1번 큐비트가 제어\n      target: 2        # 2번 큐비트가 타겟\n      gate: X          # (CC-X, 즉 Toffoli)\n:::\n\n\n\n3. OR (논리합 / De Morgan’s Law)\nOR 게이트는 AND와 NOT 게이트를 조합하여 만들 수 있습니다. (드모르간의 법칙: \\(x_1 \\lor x_2 = \\neg (\\neg x_1 \\land \\neg x_2)\\)) 이 또한 가역 게이트(X, Toffoli)의 조합으로 구현 가능합니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#핵심-결론-고전-회로의-효율적인-양자-시뮬레이션",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#핵심-결론-고전-회로의-효율적인-양자-시뮬레이션",
    "title": "L10. Basics of Quantum Computing",
    "section": "핵심 결론: 고전 회로의 효율적인 양자 시뮬레이션",
    "text": "핵심 결론: 고전 회로의 효율적인 양자 시뮬레이션\n정리 (Bennett, 1973): &gt; \\(G\\)개의 게이트를 가진 임의의 고전 회로 \\(C\\)는, &gt; \\(O(G)\\)개의 가역 게이트를 사용하는 가역 회로 \\(R.C.\\) (따라서 양자 회로 \\(U_C\\))로 매우 효율적으로(very efficiently) 변환될 수 있다.\n최종 결론: 이 변환은 효율적이므로(inefficient 하지 않다), 양자 컴퓨터(QC)는 모든 고전 컴퓨터(CC)의 연산을 효율적으로 시뮬레이션할 수 있습니다.\n\\[\\text{QC} \\ge \\text{CC}\\]"
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#가역-회로의-함정-쓰레기garbage-비트",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#가역-회로의-함정-쓰레기garbage-비트",
    "title": "L10. Basics of Quantum Computing",
    "section": "가역 회로의 함정: “쓰레기(Garbage)” 비트",
    "text": "가역 회로의 함정: “쓰레기(Garbage)” 비트\n하지만 이 변환에는 치명적인 문제가 있습니다. \\[U_C: |x\\rangle_n |0\\rangle_a \\mapsto |x\\rangle_n |F(x)\\rangle_m |G(x)\\rangle_{\\text{garbage}}\\] 이 연산은 원하는 답 \\(|F(x)\\rangle\\) 외에, 연산 과정에서 발생한 부가 정보인 “쓰레기(garbage)” 비트 \\(|G(x)\\rangle\\)를 생성합니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#양자-알고리즘의-진짜-문제-쓰레기는-간섭interference을-막는다",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#양자-알고리즘의-진짜-문제-쓰레기는-간섭interference을-막는다",
    "title": "L10. Basics of Quantum Computing",
    "section": "양자 알고리즘의 진짜 문제: 쓰레기는 간섭(Interference)을 막는다",
    "text": "양자 알고리즘의 진짜 문제: 쓰레기는 간섭(Interference)을 막는다\n양자 알고리즘의 핵심은 중첩과 간섭입니다. 하지만 쓰레기 비트는 이를 불가능하게 만듭니다.\n중첩 상태 \\(\\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\)를 입력하면, 출력은 다음과 같은 얽힌(entangled) 상태가 됩니다:\n\\[\\frac{1}{\\sqrt{2}} \\left( |0\\rangle |F(0)\\rangle |G(0)\\rangle + |1\\rangle |F(1)\\rangle |G(1)\\rangle \\right)\\]\n\n만약 \\(G(0) \\neq G(1)\\)이라면, \\(|G(0)\\rangle\\)과 \\(|G(1)\\rangle\\)은 서로 직교(orthogonal)합니다.\n이로 인해, 우리가 원하는 결과 큐비트 \\(|F(0)\\rangle\\)과 \\(|F(1)\\rangle\\)은 더 이상 서로 간섭할 수 없습니다.\n쓰레기 비트를 무시(trace out)하면, 결과 레지스터는 원하는 순수 중첩 상태(\\(\\frac{1}{\\sqrt{2}}(|F(0)\\rangle + |F(1)\\rangle)\\))가 아닌, 확률적인 혼합 상태(mixed state)가 되어버립니다.\n결론: 쓰레기 비트는 양자 알고리즘의 핵심인 간섭 현상을 “망쳐버립니다(ruins things)”."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#쓰레기-되돌리기-uncomputing-garbage",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#쓰레기-되돌리기-uncomputing-garbage",
    "title": "L10. Basics of Quantum Computing",
    "section": "쓰레기 되돌리기 (Uncomputing Garbage)",
    "text": "쓰레기 되돌리기 (Uncomputing Garbage)\n이 문제를 해결하기 위해 Bennett의 “Uncomputing” 트릭을 사용합니다.\n\n1. 이상적인 연산 형태\n우리가 진정으로 원하는 “쓰레기 없는” 연산은 다음과 같습니다: \\[U_F: |x\\rangle_n |y\\rangle_m \\mapsto |x\\rangle_n |y \\oplus F(x)\\rangle_m\\]\n\n\n2. Bennett의 “Uncomputing” 트릭\n이 이상적인 연산은 다음 3단계로 구현할 수 있습니다.\n\n[Step 1] 계산 (Compute): \\(F(x)\\)와 쓰레기 \\(G(x)\\)를 생성합니다.\n\n\\(|x\\rangle |0\\rangle_{\\text{anc}} |0\\rangle_{\\text{out}} \\xrightarrow{R_F} |x\\rangle |G(x)\\rangle_{\\text{anc}} |F(x)\\rangle_{\\text{out}}\\)\n\n[Step 2] 답 복사 (Copy Answer): CNOT을 사용해 \\(F(x)\\)를 새로운 “최종 답” 레지스터로 복사합니다.\n\n\\(|x\\rangle |G(x)\\rangle |F(x)\\rangle |0\\rangle_{\\text{final}} \\xrightarrow{\\text{CNOTs}} |x\\rangle |G(x)\\rangle |F(x)\\rangle |F(x)\\rangle_{\\text{final}}\\)\n\n[Step 3] 되돌리기 (Uncompute): Step 1의 역연산(\\(R_F^\\dagger\\))을 적용하여 쓰레기 \\(G(x)\\)와 중간 계산값 \\(F(x)\\)를 “삭제”하고 보조 큐비트를 \\(|0\\rangle\\)으로 되돌립니다.\n\n\\(|x\\rangle |G(x)\\rangle |F(x)\\rangle |F(x)\\rangle_{\\text{final}} \\xrightarrow{R_F^\\dagger} |x\\rangle |0\\rangle_{\\text{anc}} |0\\rangle_{\\text{out}} |F(x)\\rangle_{\\text{final}}\\)\n\n\n최종 결과: \\[|x\\rangle |0 \\dots 0\\rangle \\mapsto |x\\rangle |0 \\dots 0\\rangle |F(x)\\rangle_{\\text{final}}\\]\n\n우리는 입력 \\(|x\\rangle\\)와 깨끗한 답 \\(|F(x)\\rangle\\)만을 얻었고, 연산에 사용된 모든 “작업 공간(scratch space)”은 모두 \\(|0\\rangle\\)으로 깔끔하게 초기화되었습니다.\n효율성: 이 트릭은 게이트 수를 약 2배(\\(\\times 2\\))로 늘리지만, 여전히 효율적(efficient)입니다."
  },
  {
    "objectID": "posts/cs/quantum/l10 - qc-basics/index.html#l10.-결론-양자-회로의-고전-함수-계산법",
    "href": "posts/cs/quantum/l10 - qc-basics/index.html#l10.-결론-양자-회로의-고전-함수-계산법",
    "title": "L10. Basics of Quantum Computing",
    "section": "L10. 결론: 양자 회로의 고전 함수 계산법",
    "text": "L10. 결론: 양자 회로의 고전 함수 계산법\n\n1. 표준 정의: “쓰레기 없는” XOR 연산\n“쓰레기” 문제를 해결했으므로, “양자 회로가 고전 함수 \\(F\\)를 계산한다”는 것을 다음과 같이 표준적으로 정의합니다.\n\n[정의] 양자 회로 \\(U_F\\)는 다음 변환을 수행한다: \\[U_F: |x\\rangle_n |y\\rangle_m \\mapsto |x\\rangle_n |y \\oplus F(x)\\rangle_m\\]\n\n\n\n2. 양자 병렬성 (Quantum Parallelism)\n이 표준 정의가 강력한 진짜 이유는 \\(|x\\rangle\\)가 중첩 상태일 때 발생합니다.\n\n\\(n\\)-큐비트 입력이 모든 가능한 입력의 균등 중첩(uniform superposition) 상태라고 가정해봅시다: \\[|\\psi_{\\text{in}}\\rangle = \\left( \\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle \\right) |0\\rangle_m\\]\n여기에 \\(U_F\\) 연산을 (단 한 번) 적용하면, \\(F(x)\\)가 모든 \\(x\\)에 대해 동시에 계산됩니다: \\[|\\psi_{\\text{out}}\\rangle = U_F |\\psi_{\\text{in}}\\rangle = \\frac{1}{\\sqrt{2^n}} \\sum_{x \\in \\{0,1\\}^n} |x\\rangle |F(x)\\rangle\\]\n\n이것이 바로 양자 병렬성(Quantum Parallelism)입니다. \\(U_F\\)를 단 한 번만 실행함으로써, 우리는 \\(2^n\\)개의 모든 \\(F(x)\\) 값을 포함하는 얽힌 중첩 상태를 얻었습니다.\n\n[L10의 핵심] 우리는 고전 함수 \\(F(x)\\)를 “쓰레기 없이” 중첩 상태에 적용하여 \\(|x\\rangle |F(x)\\rangle\\)의 거대한 얽힘 상태를 만드는 방법을 배웠습니다.\n다음 강의(L11~)부터의 과제: 어떻게 이 중첩 상태에서 유용한 정보(예: \\(F(x)\\)의 주기(period), 특정 패턴)를 측정 없이 “추출(extract)”할 것인가? (이것이 바로 양자 푸리에 변환(QFT)과 같은 알고리즘이 하는 일입니다.)"
  },
  {
    "objectID": "posts/cs/quantum/l12 - xor-patterns-2/index.html",
    "href": "posts/cs/quantum/l12 - xor-patterns-2/index.html",
    "title": "L12. Revealing XOR-patterns II (Boolean Fourier Transform)",
    "section": "",
    "text": "이번 강의는 “암시적으로 표현된 데이터(implicitly-represented data)”에서 패턴을 찾는 것이라는 양자 컴퓨팅의 핵심 주제를 다룹니다.\n\n\n\\(N=2^n\\) (\\(n\\)은 큐비트 수)이라고 할 때, 우리의 “데이터”는 \\(\\mathbb{C}^N\\) 공간의 벡터 \\(|g\\rangle\\)입니다.\n\n고전적(Classical) 관점: 데이터의 크기 \\(N\\)은 “물리적 크기”이며, \\(|g\\rangle\\)는 \\(N\\)개의 항목을 가진 명시적인(explicit) 벡터입니다.\n양자적(Quantum) 관점: 큐비트 수 \\(n\\)이 “물리적 크기”입니다. 데이터 \\(|g\\rangle\\)는 \\(n\\)개의 큐비트로 표현된 “양자 상태(quantum state)”이며, \\(N=2^n\\)개의 데이터 항목(진리표)은 이 상태의 진폭(amplitude)에 “암시적으로” 저장됩니다. \\[|g\\rangle = \\sum_{x \\in \\{0,1\\}^n} g(x) |x\\rangle\\]\n\n\n\n\n“데이터 처리” 또는 “패턴 찾기”는 본질적으로 이 데이터 벡터 \\(|g\\rangle\\)를 표준 기저 \\(\\{|x\\rangle\\}\\)에서 다른 “패턴 기저(pattern basis)” \\(\\{|\\chi_s\\rangle\\}\\)로 변환하는 것입니다.\n데이터 \\(|g\\rangle\\)를 이 새로운 “패턴 기저”로 전개할 수 있습니다. \\[|g\\rangle = \\sum_{s \\in \\{0,1\\}^n} \\tilde{g}(s) |\\chi_s\\rangle\\]\n여기서 계수 \\(\\tilde{g}(s) = \\langle \\chi_s | g \\rangle\\)는 데이터 \\(|g\\rangle\\)에 \\(s\\)번째 패턴이 얼마나 많이(strength) 포함되어 있는지를 나타냅니다.\n\n\n\n양자 회로 \\(U_{\\text{FT}}\\)의 역할은 이 “Strength” \\(\\tilde{g}(s)\\)를 계산하는 것입니다. 즉, \\(|g\\rangle\\) 상태를 입력받아, \\(\\tilde{g}(s)\\)를 진폭으로 갖는 상태로 변환합니다. \\[U_{\\text{FT}}: |g\\rangle = \\sum_x g(x) |x\\rangle \\mapsto |\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\]\n이 강의 시리즈에서는 두 가지 핵심적인 푸리에 변환을 다룹니다.\n\n오늘의 주제: Boolean Fourier Transform (BFT)\n\n패턴: “XOR-patterns”\n변환 \\(U_{\\text{FT}}\\): Hadamard Transform (\\(H^{\\otimes n}\\))\n효율성: 매우 효율적입니다. (각 큐비트에 \\(H\\) 게이트 1개 적용)\n\n이후 주제: Discrete Fourier Transform (DFT)\n\n패턴: “주기성(Periodicity)” (Number Theory)\n변환 \\(U_{\\text{FT}}\\): Quantum Fourier Transform (QFT)\n활용: Shor의 인수분해 알고리즘.\n\n\n\n\n\n\n“데이터”를 다룰 때, (1) 함수 \\(f(x)\\), (2) 벡터 \\(f\\), (3) 양자 상태 \\(|g\\rangle\\)를 구분해야 합니다.\n\n부호 벡터 (Sign Vector): \\(f(x) = (-1)^{F(x)}\\) 값들의 벡터 \\(f\\)는 노름(norm) 제곱이 \\(\\sum |f(x)|^2 = N\\) 입니다.\n양자 상태 (Quantum State): \\(|g\\rangle\\)는 노름 제곱이 \\(\\sum |g(x)|^2 = 1\\) 이어야 합니다.\n\n따라서 함수 \\(f(x)\\)의 정보를 “로드”한 양자 상태는 \\(f\\)를 정규화(normalize)한 것이어야 합니다.\n\n[정의] 함수의 양자 상태 표현 “부호 벡터” \\(f\\)에 해당하는 (정규화된) 양자 상태 \\(|g\\rangle\\)는 다음과 같습니다. \\[|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} f(x) |x\\rangle\\]\n\n(L11에서 \\(H-V_F-H\\)의 2단계 결과물이 바로 이 상태였습니다.)\n\n\n\n\nL11의 알고리즘은 BFT를 이용한 “기저 변환”으로 재해석할 수 있습니다. BFT의 “패턴 기저” \\(\\{|\\chi_s\\rangle\\}\\)는 다음과 같이 정의됩니다.\n1. 패턴 함수 (Pattern Function): \\[\\chi_s(x) = (-1)^{s \\cdot x} = (-1)^{\\sum_i s_i x_i \\pmod 2}\\]\n2. 패턴 기저 벡터 (Pattern Basis Vector): \\[|\\chi_s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} \\chi_s(x) |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |x\\rangle\\]\n\n(L11의 발견) L11의 증명 과정 \\(\\left( |\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_1\\rangle \\right)\\)에서, 우리는 \\(|\\psi_1\\rangle = |\\chi_{s^*}\\rangle\\) 이고 \\(|\\psi_{\\text{final}}\\rangle = |s^*\\rangle\\) 임을 보였습니다. 즉, \\(H^{\\otimes n} |\\chi_s\\rangle = |s\\rangle\\) 입니다.\n(L12의 발견) \\(H^{\\otimes n}\\)은 그 자체가 역변환(\\(H^{\\otimes n}H^{\\otimes n}=I\\))이므로, \\(H^{\\otimes n} |s\\rangle = |\\chi_s\\rangle\\) 또한 성립합니다.\n결론: BFT(\\(H^{\\otimes n}\\))는 표준 기저 \\(\\{|s\\rangle\\}\\)와 XOR-패턴 기저 \\(\\{|\\chi_s\\rangle\\}\\) 사이를 변환하는 연산자입니다.\n\n\n\n\\(|\\chi_s\\rangle\\) 벡터들이 직교정규 기저(\\(\\langle \\chi_{s_1} | \\chi_{s_2} \\rangle = \\delta_{s_1, s_2}\\))를 이루는지 확인합니다. \\[\\langle \\chi_{s_1} | \\chi_{s_2} \\rangle = \\frac{1}{N} \\sum_x (-1)^{s_1 \\cdot x} (-1)^{s_2 \\cdot x} = \\frac{1}{N} \\sum_x (-1)^{(s_1 \\oplus s_2) \\cdot x}\\]\n\nCase 1: \\(s_1 = s_2\\) (정규성)\n\n\\(s_1 \\oplus s_2 = 0\\) 이므로, 합은 \\(\\frac{1}{N} \\sum_x (-1)^0 = \\frac{N}{N} = 1\\) 입니다.\n\nCase 2: \\(s_1 \\neq s_2\\) (직교성)\n\n\\(s' = s_1 \\oplus s_2 \\neq 0\\) 입니다. \\(s' \\cdot x\\)는 \\(N\\)개의 \\(x\\) 중 정확히 절반(N/2)에 대해 0이고 절반(N/2)에 대해 1입니다.\n따라서 \\(\\sum_x (-1)^{s' \\cdot x}\\)는 \\((N/2)\\)개의 \\((+1)\\)과 \\((N/2)\\)개의 \\((-1)\\)의 합이므로 0입니다.\n\n결론: \\(\\{|\\chi_s\\rangle\\}\\)는 직교정규(orthonormal) 기저입니다.\n\n\n\n\n\n\nL11과 L12의 내용을 종합하여, 강력하고 일반적인 “푸리에 샘플링” 패러다임을 정의할 수 있습니다.\n알고리즘 3단계:\n\n[LOAD DATA] (1+2단계):\n\n\\(H^{\\otimes n}\\)과 \\(V_F\\) 오라클(칩)을 1회 사용하여 \\(n\\) 큐비트 상태에 \\(N=2^n\\) 크기의 “데이터” \\(f(x)\\)를 진폭으로 로드합니다.\n\\[|f\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} f(x) |x\\rangle\\]\n\n[Apply BFT] (3단계):\n\n“데이터 상태” \\(|f\\rangle\\)에 BFT(\\(H^{\\otimes n}\\))를 적용하여 “푸리에 상태” \\(|\\tilde{f}\\rangle\\)를 만듭니다.\n\\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |f\\rangle = \\sum_{s \\in \\{0,1\\}^n} \\tilde{f}(s) |s\\rangle\\]\n\n[Measure] (4단계):\n\n최종 상태를 측정합니다.\n\n\n\n\n“푸리에 상태”의 진폭 \\(\\tilde{f}(s)\\)는 데이터 \\(f\\)와 패턴 \\(\\chi_s\\)의 상관관계(correlation)입니다. \\[\\tilde{f}(s) = \\langle \\chi_s | f \\rangle = \\frac{1}{N} \\sum_x f(x) \\chi_s(x)\\] * \\(\\tilde{f}(s) = (\\text{Frac. of } x\\text{'s where } f(x) = \\chi_s(x)) - (\\text{Frac. of } x\\text{'s where } f(x) \\neq \\chi_s(x))\\)\n\n\n\n최종 상태 \\(|\\psi_{\\text{final}}\\rangle = \\sum_s \\tilde{f}(s) |s\\rangle\\) 를 측정하면, &gt; 측정 결과 \\(s\\)가 나올 확률은 \\(P(s) = |\\tilde{f}(s)|^2\\) 입니다.\n즉, 푸리에 샘플링은 “데이터 \\(f(x)\\)와 가장 상관관계가 높은 패턴 \\(s\\)를 그 상관관계의 제곱에 비례하는 확률로 샘플링”하는 물리적 절차입니다.\n\n장점: \\(n\\) 큐비트로 \\(N=2^n\\) 크기의 데이터를 처리하는 지수적 효율성.\n단점: 전체 푸리에 스펙트럼 \\(\\tilde{f}(s)\\)를 얻는 것이 아니라, 단 하나의 \\(s\\)만 샘플링됩니다.\n\n\n\n\n\n\n이 “푸리에 샘플링” 트릭이 고전 컴퓨터보다 얼마나 강력한지 오라클 문제를 통해 비교할 수 있습니다.\n\n\n\n문제: \\(F(x) = s^* \\cdot x\\) (즉 \\(f = \\chi_{s^*}\\))일 때 \\(s^*\\)를 찾으시오.\n고전 (CC): \\(s^*\\)의 \\(n\\)개 비트를 알기 위해 \\(n\\)번의 오라클 호출이 필요합니다.\n양자 (QC): \\(f\\)와 \\(\\chi_{s^*}\\)의 상관관계가 완벽히 1 (\\(\\tilde{f}(s^*) = 1\\))이므로, 푸리에 샘플링(H-V-H)을 하면 단 1번의 호출로 \\(100\\%\\) 확률로 \\(s^*\\)를 얻습니다.\n결과: \\(n\\) vs \\(1\\) (다항식 vs 상수)\n\n\n\n\n\n문제: \\(F(x) = F(y) \\iff y = x \\oplus s^*\\) 일 때 \\(s^*\\)를 찾으시오.\n고전 (CC): \\(s^*\\)를 찾으려면 약 \\(2^{n/2}\\) (즉, \\(\\sqrt{N}\\)) 번의 호출이 필요합니다. (지수적 시간)\n양자 (QC): \\(H-V-F-H\\)와 유사한 구조를 통해 \\(O(n)\\)번 (다항식 시간)의 호출만으로 \\(s^*\\)를 높은 확률로 찾을 수 있습니다.\n결과: \\(2^{n/2}\\) vs \\(n\\) (지수적 vs 다항식)\n\nSimon의 알고리즘은 고전 지수 시간 vs 양자 다항 시간이라는 진정한 지수적 분리(separation)를 보여줍니다.\n\n\n\nBV나 Simon의 “미스터리 칩(오라클)” 시나리오는 꾸며낸 듯(contrived) 보일 수 있습니다. 하지만 Shor의 알고리즘에서는 “미스터리 칩”을 우리 자신이 직접 만듭니다.\n\nShor: 우리는 \\(F(x) = a^x \\pmod N\\) 회로를 직접 만듭니다.\n우리는 이 회로의 “주기성”이라는 속성을 모릅니다.\n우리는 우리가 만든 이 회로를 “오라클”처럼 사용하여 푸리에 샘플링(QFT)을 다항식(\\(O(n^k)\\)) 횟수만큼 호출하여 그 “주기”를 찾아냅니다.\n고전적으로는 이 “주기”를 찾는 데 지수적 시간이 걸립니다.\n\n최종 결론: 양자 알고리즘(푸리에 샘플링)을 이용하면, 우리가 직접 만든 회로의 글로벌 속성(패턴, 주기)을 고전적으로는 불가능한(지수적인) 속도(다항식)로 파악해낼 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l12 - xor-patterns-2/index.html#l12.-revealing-xor-patterns-ii",
    "href": "posts/cs/quantum/l12 - xor-patterns-2/index.html#l12.-revealing-xor-patterns-ii",
    "title": "L12. Revealing XOR-patterns II (Boolean Fourier Transform)",
    "section": "",
    "text": "이번 강의는 “암시적으로 표현된 데이터(implicitly-represented data)”에서 패턴을 찾는 것이라는 양자 컴퓨팅의 핵심 주제를 다룹니다.\n\n\n\\(N=2^n\\) (\\(n\\)은 큐비트 수)이라고 할 때, 우리의 “데이터”는 \\(\\mathbb{C}^N\\) 공간의 벡터 \\(|g\\rangle\\)입니다.\n\n고전적(Classical) 관점: 데이터의 크기 \\(N\\)은 “물리적 크기”이며, \\(|g\\rangle\\)는 \\(N\\)개의 항목을 가진 명시적인(explicit) 벡터입니다.\n양자적(Quantum) 관점: 큐비트 수 \\(n\\)이 “물리적 크기”입니다. 데이터 \\(|g\\rangle\\)는 \\(n\\)개의 큐비트로 표현된 “양자 상태(quantum state)”이며, \\(N=2^n\\)개의 데이터 항목(진리표)은 이 상태의 진폭(amplitude)에 “암시적으로” 저장됩니다. \\[|g\\rangle = \\sum_{x \\in \\{0,1\\}^n} g(x) |x\\rangle\\]\n\n\n\n\n“데이터 처리” 또는 “패턴 찾기”는 본질적으로 이 데이터 벡터 \\(|g\\rangle\\)를 표준 기저 \\(\\{|x\\rangle\\}\\)에서 다른 “패턴 기저(pattern basis)” \\(\\{|\\chi_s\\rangle\\}\\)로 변환하는 것입니다.\n데이터 \\(|g\\rangle\\)를 이 새로운 “패턴 기저”로 전개할 수 있습니다. \\[|g\\rangle = \\sum_{s \\in \\{0,1\\}^n} \\tilde{g}(s) |\\chi_s\\rangle\\]\n여기서 계수 \\(\\tilde{g}(s) = \\langle \\chi_s | g \\rangle\\)는 데이터 \\(|g\\rangle\\)에 \\(s\\)번째 패턴이 얼마나 많이(strength) 포함되어 있는지를 나타냅니다.\n\n\n\n양자 회로 \\(U_{\\text{FT}}\\)의 역할은 이 “Strength” \\(\\tilde{g}(s)\\)를 계산하는 것입니다. 즉, \\(|g\\rangle\\) 상태를 입력받아, \\(\\tilde{g}(s)\\)를 진폭으로 갖는 상태로 변환합니다. \\[U_{\\text{FT}}: |g\\rangle = \\sum_x g(x) |x\\rangle \\mapsto |\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\]\n이 강의 시리즈에서는 두 가지 핵심적인 푸리에 변환을 다룹니다.\n\n오늘의 주제: Boolean Fourier Transform (BFT)\n\n패턴: “XOR-patterns”\n변환 \\(U_{\\text{FT}}\\): Hadamard Transform (\\(H^{\\otimes n}\\))\n효율성: 매우 효율적입니다. (각 큐비트에 \\(H\\) 게이트 1개 적용)\n\n이후 주제: Discrete Fourier Transform (DFT)\n\n패턴: “주기성(Periodicity)” (Number Theory)\n변환 \\(U_{\\text{FT}}\\): Quantum Fourier Transform (QFT)\n활용: Shor의 인수분해 알고리즘.\n\n\n\n\n\n\n“데이터”를 다룰 때, (1) 함수 \\(f(x)\\), (2) 벡터 \\(f\\), (3) 양자 상태 \\(|g\\rangle\\)를 구분해야 합니다.\n\n부호 벡터 (Sign Vector): \\(f(x) = (-1)^{F(x)}\\) 값들의 벡터 \\(f\\)는 노름(norm) 제곱이 \\(\\sum |f(x)|^2 = N\\) 입니다.\n양자 상태 (Quantum State): \\(|g\\rangle\\)는 노름 제곱이 \\(\\sum |g(x)|^2 = 1\\) 이어야 합니다.\n\n따라서 함수 \\(f(x)\\)의 정보를 “로드”한 양자 상태는 \\(f\\)를 정규화(normalize)한 것이어야 합니다.\n\n[정의] 함수의 양자 상태 표현 “부호 벡터” \\(f\\)에 해당하는 (정규화된) 양자 상태 \\(|g\\rangle\\)는 다음과 같습니다. \\[|g\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} f(x) |x\\rangle\\]\n\n(L11에서 \\(H-V_F-H\\)의 2단계 결과물이 바로 이 상태였습니다.)\n\n\n\n\nL11의 알고리즘은 BFT를 이용한 “기저 변환”으로 재해석할 수 있습니다. BFT의 “패턴 기저” \\(\\{|\\chi_s\\rangle\\}\\)는 다음과 같이 정의됩니다.\n1. 패턴 함수 (Pattern Function): \\[\\chi_s(x) = (-1)^{s \\cdot x} = (-1)^{\\sum_i s_i x_i \\pmod 2}\\]\n2. 패턴 기저 벡터 (Pattern Basis Vector): \\[|\\chi_s\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} \\chi_s(x) |x\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} (-1)^{s \\cdot x} |x\\rangle\\]\n\n(L11의 발견) L11의 증명 과정 \\(\\left( |\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |\\psi_1\\rangle \\right)\\)에서, 우리는 \\(|\\psi_1\\rangle = |\\chi_{s^*}\\rangle\\) 이고 \\(|\\psi_{\\text{final}}\\rangle = |s^*\\rangle\\) 임을 보였습니다. 즉, \\(H^{\\otimes n} |\\chi_s\\rangle = |s\\rangle\\) 입니다.\n(L12의 발견) \\(H^{\\otimes n}\\)은 그 자체가 역변환(\\(H^{\\otimes n}H^{\\otimes n}=I\\))이므로, \\(H^{\\otimes n} |s\\rangle = |\\chi_s\\rangle\\) 또한 성립합니다.\n결론: BFT(\\(H^{\\otimes n}\\))는 표준 기저 \\(\\{|s\\rangle\\}\\)와 XOR-패턴 기저 \\(\\{|\\chi_s\\rangle\\}\\) 사이를 변환하는 연산자입니다.\n\n\n\n\\(|\\chi_s\\rangle\\) 벡터들이 직교정규 기저(\\(\\langle \\chi_{s_1} | \\chi_{s_2} \\rangle = \\delta_{s_1, s_2}\\))를 이루는지 확인합니다. \\[\\langle \\chi_{s_1} | \\chi_{s_2} \\rangle = \\frac{1}{N} \\sum_x (-1)^{s_1 \\cdot x} (-1)^{s_2 \\cdot x} = \\frac{1}{N} \\sum_x (-1)^{(s_1 \\oplus s_2) \\cdot x}\\]\n\nCase 1: \\(s_1 = s_2\\) (정규성)\n\n\\(s_1 \\oplus s_2 = 0\\) 이므로, 합은 \\(\\frac{1}{N} \\sum_x (-1)^0 = \\frac{N}{N} = 1\\) 입니다.\n\nCase 2: \\(s_1 \\neq s_2\\) (직교성)\n\n\\(s' = s_1 \\oplus s_2 \\neq 0\\) 입니다. \\(s' \\cdot x\\)는 \\(N\\)개의 \\(x\\) 중 정확히 절반(N/2)에 대해 0이고 절반(N/2)에 대해 1입니다.\n따라서 \\(\\sum_x (-1)^{s' \\cdot x}\\)는 \\((N/2)\\)개의 \\((+1)\\)과 \\((N/2)\\)개의 \\((-1)\\)의 합이므로 0입니다.\n\n결론: \\(\\{|\\chi_s\\rangle\\}\\)는 직교정규(orthonormal) 기저입니다.\n\n\n\n\n\n\nL11과 L12의 내용을 종합하여, 강력하고 일반적인 “푸리에 샘플링” 패러다임을 정의할 수 있습니다.\n알고리즘 3단계:\n\n[LOAD DATA] (1+2단계):\n\n\\(H^{\\otimes n}\\)과 \\(V_F\\) 오라클(칩)을 1회 사용하여 \\(n\\) 큐비트 상태에 \\(N=2^n\\) 크기의 “데이터” \\(f(x)\\)를 진폭으로 로드합니다.\n\\[|f\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x \\in \\{0,1\\}^n} f(x) |x\\rangle\\]\n\n[Apply BFT] (3단계):\n\n“데이터 상태” \\(|f\\rangle\\)에 BFT(\\(H^{\\otimes n}\\))를 적용하여 “푸리에 상태” \\(|\\tilde{f}\\rangle\\)를 만듭니다.\n\\[|\\psi_{\\text{final}}\\rangle = H^{\\otimes n} |f\\rangle = \\sum_{s \\in \\{0,1\\}^n} \\tilde{f}(s) |s\\rangle\\]\n\n[Measure] (4단계):\n\n최종 상태를 측정합니다.\n\n\n\n\n“푸리에 상태”의 진폭 \\(\\tilde{f}(s)\\)는 데이터 \\(f\\)와 패턴 \\(\\chi_s\\)의 상관관계(correlation)입니다. \\[\\tilde{f}(s) = \\langle \\chi_s | f \\rangle = \\frac{1}{N} \\sum_x f(x) \\chi_s(x)\\] * \\(\\tilde{f}(s) = (\\text{Frac. of } x\\text{'s where } f(x) = \\chi_s(x)) - (\\text{Frac. of } x\\text{'s where } f(x) \\neq \\chi_s(x))\\)\n\n\n\n최종 상태 \\(|\\psi_{\\text{final}}\\rangle = \\sum_s \\tilde{f}(s) |s\\rangle\\) 를 측정하면, &gt; 측정 결과 \\(s\\)가 나올 확률은 \\(P(s) = |\\tilde{f}(s)|^2\\) 입니다.\n즉, 푸리에 샘플링은 “데이터 \\(f(x)\\)와 가장 상관관계가 높은 패턴 \\(s\\)를 그 상관관계의 제곱에 비례하는 확률로 샘플링”하는 물리적 절차입니다.\n\n장점: \\(n\\) 큐비트로 \\(N=2^n\\) 크기의 데이터를 처리하는 지수적 효율성.\n단점: 전체 푸리에 스펙트럼 \\(\\tilde{f}(s)\\)를 얻는 것이 아니라, 단 하나의 \\(s\\)만 샘플링됩니다.\n\n\n\n\n\n\n이 “푸리에 샘플링” 트릭이 고전 컴퓨터보다 얼마나 강력한지 오라클 문제를 통해 비교할 수 있습니다.\n\n\n\n문제: \\(F(x) = s^* \\cdot x\\) (즉 \\(f = \\chi_{s^*}\\))일 때 \\(s^*\\)를 찾으시오.\n고전 (CC): \\(s^*\\)의 \\(n\\)개 비트를 알기 위해 \\(n\\)번의 오라클 호출이 필요합니다.\n양자 (QC): \\(f\\)와 \\(\\chi_{s^*}\\)의 상관관계가 완벽히 1 (\\(\\tilde{f}(s^*) = 1\\))이므로, 푸리에 샘플링(H-V-H)을 하면 단 1번의 호출로 \\(100\\%\\) 확률로 \\(s^*\\)를 얻습니다.\n결과: \\(n\\) vs \\(1\\) (다항식 vs 상수)\n\n\n\n\n\n문제: \\(F(x) = F(y) \\iff y = x \\oplus s^*\\) 일 때 \\(s^*\\)를 찾으시오.\n고전 (CC): \\(s^*\\)를 찾으려면 약 \\(2^{n/2}\\) (즉, \\(\\sqrt{N}\\)) 번의 호출이 필요합니다. (지수적 시간)\n양자 (QC): \\(H-V-F-H\\)와 유사한 구조를 통해 \\(O(n)\\)번 (다항식 시간)의 호출만으로 \\(s^*\\)를 높은 확률로 찾을 수 있습니다.\n결과: \\(2^{n/2}\\) vs \\(n\\) (지수적 vs 다항식)\n\nSimon의 알고리즘은 고전 지수 시간 vs 양자 다항 시간이라는 진정한 지수적 분리(separation)를 보여줍니다.\n\n\n\nBV나 Simon의 “미스터리 칩(오라클)” 시나리오는 꾸며낸 듯(contrived) 보일 수 있습니다. 하지만 Shor의 알고리즘에서는 “미스터리 칩”을 우리 자신이 직접 만듭니다.\n\nShor: 우리는 \\(F(x) = a^x \\pmod N\\) 회로를 직접 만듭니다.\n우리는 이 회로의 “주기성”이라는 속성을 모릅니다.\n우리는 우리가 만든 이 회로를 “오라클”처럼 사용하여 푸리에 샘플링(QFT)을 다항식(\\(O(n^k)\\)) 횟수만큼 호출하여 그 “주기”를 찾아냅니다.\n고전적으로는 이 “주기”를 찾는 데 지수적 시간이 걸립니다.\n\n최종 결론: 양자 알고리즘(푸리에 샘플링)을 이용하면, 우리가 직접 만든 회로의 글로벌 속성(패턴, 주기)을 고전적으로는 불가능한(지수적인) 속도(다항식)로 파악해낼 수 있습니다."
  },
  {
    "objectID": "posts/cs/quantum/l15 - period-finding/index.html",
    "href": "posts/cs/quantum/l15 - period-finding/index.html",
    "title": "L15. Period-Finding (Simon’s Algorithm over Z_N)",
    "section": "",
    "text": "이 강의는 Shor의 인수분해 알고리즘의 핵심 구성 요소입니다. L13(Simon)이 \\(\\mathbb{Z}_2^n\\) (XOR) 그룹의 “숨겨진 주기” \\(L\\)을 찾는 것이었다면, L15는 \\(\\mathbb{Z}_N\\) (산술) 그룹의 “숨겨진 주기” \\(L\\)을 찾는 문제입니다.\n\n\n\n함수: \\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\) (즉, \\(n=\\log N\\) 큐비트를 입력받아 \\(m\\) 큐비트 “색깔”을 출력합니다.)\n오라클: \\(Q_F\\) (XOR 오라클) \\(U_F: |x\\rangle |y\\rangle \\mapsto |x\\rangle |y \\oplus F(x)\\rangle\\)에 접근할 수 있습니다.\n목표: \\(F\\)의 “주기” \\(L\\)을 효율적으로 (즉, 오라클 호출을 다항식 \\(O(poly(n))\\) 횟수만큼 사용하여) 찾는 것입니다.\n\n\n\n\n\n[주기성 약속 (L-periodic)] 숨겨진 “주기” \\(L\\)이 존재하여, 1. 모든 \\(x \\in \\mathbb{Z}_N\\)에 대해 \\(F(x) = F(x+L \\pmod N)\\)이 성립합니다. 2. 주기 내의 모든 값은 고유합니다. (즉, \\(F(x) = F(y) \\iff L | (y-x) \\pmod N\\))\n\n예시 (\\(L=4\\)): 함수 \\(F\\)는 \\(L\\)개의 고유한 “색깔” (R, G, B, Y)을 가지고, 이 패턴이 \\(N/L\\)번 반복됩니다. \\(F: (R, G, B, Y | R, G, B, Y | R, G, B, Y | \\dots)\\) \\(x: (0, 1, 2, 3 | 4, 5, 6, 7 | 8, 9, 10, 11 | \\dots)\\)\n\n\n\n알고리즘은 L12/L13에서 배운 “푸리에 샘플링” 패러다임을 그대로 따릅니다.\n\n[LOAD DATA]: \\(Q_F\\) 오라클을 사용하여 \\(F(x)\\)의 “주기성” 정보를 양자 상태의 진폭에 “로드”합니다.\n[FOURIER TRANSFORM]: \\(\\mathbb{Z}_2^n\\)의 BFT(\\(H^{\\otimes n}\\)) 대신, \\(\\mathbb{Z}_N\\)의 QFT (L14)를 적용합니다.\n[MEASURE]: 변환된 “주파수” 상태를 측정하여 \\(L\\)에 대한 “단서(clue)”를 얻습니다.\n\n\n\n\n\nL13(Simon)에서와 정확히 동일한 방식으로 “데이터”를 로드합니다.\n\n준비: \\(|0\\rangle^{\\otimes n} |0\\rangle^{\\otimes m}\\)\n[Rotate]: 입력 레지스터에 \\(H^{\\otimes n}\\)을 적용하여 균등 중첩을 만듭니다. ( \\(N=2^n\\) 가정) \\[\\left( \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle \\right) |0\\rangle^{\\otimes m}\\]\n[Compute]: \\(Q_F\\) (XOR 오라클)을 적용합니다. \\[|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |F(x)\\rangle\\]\n\n이 결과물 \\(|\\psi_1\\rangle\\)은 모든 입력 \\(|x\\rangle\\)와 그에 해당하는 “색깔” \\(|F(x)\\rangle\\)가 얽힌(entangled) 상태입니다.\n\n\n\n\n이 얽힌 상태 \\(|\\psi_1\\rangle\\)를 분석하기 위해, 출력 레지스터를 측정(Measure)한다고 “가정”합니다 (지연된 측정의 원리).\n\n측정: \\(m\\)-큐비트 출력 레지스터를 측정하면, “색깔” \\(C^*\\)가 관측됩니다.\n붕괴 (Collapse): \\(F(x) = C^*\\)를 만족하는 \\(x\\) 값들만 살아남습니다. \\(L|N\\)이라는 “이상적인” 가정 하에서, 이 \\(x\\) 값들은 정확히 \\(K = N/L\\)개 존재합니다. ( \\(x_0, x_0+L, x_0+2L, \\dots, x_0 + (K-1)L\\) )\n“신호” 상태: 출력 레지스터 \\(|C^*\\rangle\\)를 무시(discard)하고 나면, \\(n\\) 큐비트의 입력 레지스터는 다음과 같은 “신호” 상태가 됩니다. \\[|\\psi_{\\text{signal}}\\rangle = |\\psi_{x_0}\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{K-1} |x_0 + kL\\rangle\\]\n이것은 \\(x_0\\)라는 무작위 시작점(random offset)을 갖는 “펄스 열(pulse train)”입니다.\n\n\n\n\n\n\n\n\\(x_0\\)가 무작위 값이라는 것은 심각한 문제처럼 보입니다. 하지만 푸리에 이동 정리가 이 문제를 해결합니다.\n\n[Lemma] (Pleasing Fact!) “이동된” 신호 \\(|g_{x_0}\\rangle\\)의 QFT \\(|\\tilde{g}_{x_0}\\rangle\\)는, “이동 안 된” 신호(\\(x_0=0\\))의 QFT \\(|\\tilde{g}\\rangle\\)에 위상 항(phase term) \\(\\omega_N^{-s \\cdot x_0}\\)만 곱한 것입니다. \\[|\\tilde{g}_{x_0}\\rangle = \\sum_s \\left( \\tilde{g}(s) \\cdot \\omega_N^{-s \\cdot x_0} \\right) |s\\rangle\\]\n\n측정 확률 (The Punchline): 측정 확률은 진폭의 제곱 \\(P(s) = |\\tilde{g}_{x_0}(s)|^2 = |\\tilde{g}(s)|^2 \\cdot |\\omega_N^{-s \\cdot x_0}|^2\\) 입니다. \\(|\\omega_N^{-s \\cdot x_0}|^2 = 1\\) 이므로, \\(P(s) = |\\tilde{g}(s)|^2\\) 입니다.\n결론: 최종 측정 확률 분포는 무작위 오프셋 \\(x_0\\)와 완전히 독립적(independent)입니다. 따라서 \\(x_0=0\\)인 가장 간단한 경우만 분석하면 됩니다.\n\n\n\n\\(x_0=0\\)인 “신호” \\(|g_0\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{K-1} |kL\\rangle\\) (주기 \\(L\\), 펄스 \\(K=N/L\\)개)의 QFT \\(|\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\)를 계산합니다.\n\\(s\\)번째 진폭 \\(\\tilde{g}(s) = \\langle s | U_{\\text{QFT}} | g_0 \\rangle\\)는 공비 \\(r = \\omega_N^{-sL}\\)를 갖는 등비수열의 합입니다. \\[\\tilde{g}(s) = \\frac{\\sqrt{L}}{N} \\sum_{k=0}^{K-1} \\left( \\omega_N^{-sL} \\right)^k\\]\n\nCase 1: \\(s \\cdot L = 0 \\pmod N\\) ( \\(s\\)가 \\(K=N/L\\)의 배수)\n\n\\(r=1\\)이 되어 결맞는 간섭이 일어납니다.\n\\(\\tilde{g}(s) = \\frac{\\sqrt{L}}{N} \\cdot K = \\frac{\\sqrt{L}}{N} \\cdot \\frac{N}{L} = \\frac{1}{\\sqrt{L}}\\)\n\nCase 2: \\(s \\cdot L \\neq 0 \\pmod N\\) ( \\(s\\)가 \\(K\\)의 배수가 아님)\n\n\\(r \\neq 1\\)이지만 \\(r^K = (\\omega_N^{-sL})^{N/L} = (\\omega_N^{-N})^s = 1^s = 1\\) 입니다.\n등비수열 합 공식 \\(\\frac{1-r^K}{1-r} = \\frac{1-1}{1-r} = 0\\) 이므로 상쇄 간섭이 일어납니다.\n\\(\\tilde{g}(s) = 0\\)\n\n\n결론 (측정): QFT의 결과 \\(|\\psi_{\\text{final}}\\rangle\\)는 주기 \\(K=N/L\\)을 가진 또 다른 “펄스 열”입니다. \\[|\\psi_{\\text{final}}\\rangle = \\sum_{j=0}^{L-1} \\frac{1}{\\sqrt{L}} |j \\cdot K\\rangle \\quad (\\text{where } K = N/L)\\] 측정 시, 우리는 \\(\\mathbf{K=N/L}\\)의 배수 \\(s = j \\cdot (N/L)\\) ( \\(j\\)는 랜덤)를 확률 \\(1/L\\)로 얻습니다.\n\n\n\n\n\n\\(s = j \\cdot (N/L)\\) 라는 단서(\\(s/N = j/L\\))로부터 \\(L\\)을 어떻게 찾을까요?\n\n\\(H-Q_F-QFT \\to \\text{Measure}\\) 회로를 두 번 반복하여 \\(s_1, s_2\\)를 얻습니다 ( \\(s_i \\neq 0\\) 가정).\n\\(s_1 = j_1 (N/L)\\), \\(s_2 = j_2 (N/L)\\) 입니다.\n\\(K' = \\text{gcd}(s_1, s_2)\\)를 (고전적으로) 계산합니다.\n\\(K' = \\text{gcd}(j_1 K, j_2 K) = K \\cdot \\text{gcd}(j_1, j_2)\\)\n두 무작위 정수 \\(j_1, j_2\\)가 서로소(\\(\\text{gcd}(j_1, j_2)=1\\))일 확률은 \\(\\frac{6}{\\pi^2} \\approx 60.7\\%\\) (상수) 입니다.\n높은 확률로 \\(K' = K = N/L\\) 이므로, \\(L = N/K'\\)로 \\(L\\)을 복원합니다.\n총 비용: \\(O(1)\\) (상수) 횟수의 양자 호출과 \\(O(n^3)\\)의 고전 후처리(GCD)로, 다항식(polynomial) 시간에 \\(L\\)을 찾습니다.\n\n\n\n\n\nShor의 실제 문제에서는 \\(L\\)이 \\(N\\)을 나누지 않습니다 (\\(K=N/L\\)가 정수가 아님).\n\n입력 (Time): “신호” \\(|\\psi_{\\text{signal}}\\rangle\\)는 \\(M' = \\lfloor N/L \\rfloor\\) 또는 \\(\\lceil N/L \\rceil\\) 개의 펄스를 가진 “불완전한” 펄스 열입니다.\nQFT (Freq.): \\(|\\psi_{\\text{final}}\\rangle\\)는 완벽한 “펄스 열”이 아니라, “이상적인” 주파수(\\(s \\approx jN/L\\)) “근처(near)”에 확률이 “집중(peaked)”되는 “흐트러진(smeared)” 스펙트럼이 됩니다.\n증명 (Shor’s Lemma): 이 “불완전한” 펄스 열의 QFT를 수학적으로 분석하면(L15-3-2-1, L15-3-2-2-1, L15-3-2-2-2 개인 노트), \\(jN/L\\)에 “가장 가까운” 정수 \\(s = \\lfloor jN/L \\rceil\\)를 측정할 확률 \\(P(s)\\)가 최악의 경우에도 \\(4/\\pi^2 \\approx 0.405\\) 이상임이 보장됩니다 (단, 이는 \\(L\\)개 피크 중 하나에 대한 확률). \\[P(s = \\lfloor jN/L \\rceil) \\ge \\frac{4}{\\pi^2 L} \\approx \\frac{0.405}{L}\\]\n\n최종 결론 (Shor): \\(L \\nmid N\\)이라는 “현실적인” 경우에도, \\(H-Q_F-QFT\\)를 측정하면 \\(\\frac{s}{N} \\approx \\frac{j}{L}\\)를 만족하는 “좋은” \\(s\\)를 \\(O(n)\\)번의 반복으로 높은 확률로 샘플링할 수 있습니다.\n이 “나쁜” 근사 분수 \\(\\frac{s}{N}\\)로부터 \\(L\\)을 복원하기 위해, 연분수 알고리즘 (Continued Fractions Algorithm)이라는 강력한 고전 \\(O(n^3)\\) 후처리 기법을 사용합니다.\n총 비용: \\(O(n \\log n)\\) (근사 QFT) \\(\\times\\) \\(O(n)\\) (반복) + \\(O(n^3)\\) (연분수) \\(\\implies\\) 총 다항식(polynomial) 시간"
  },
  {
    "objectID": "posts/cs/quantum/l15 - period-finding/index.html#l15.-period-finding-simons-algorithm-over-mathbbz_n",
    "href": "posts/cs/quantum/l15 - period-finding/index.html#l15.-period-finding-simons-algorithm-over-mathbbz_n",
    "title": "L15. Period-Finding (Simon’s Algorithm over Z_N)",
    "section": "",
    "text": "이 강의는 Shor의 인수분해 알고리즘의 핵심 구성 요소입니다. L13(Simon)이 \\(\\mathbb{Z}_2^n\\) (XOR) 그룹의 “숨겨진 주기” \\(L\\)을 찾는 것이었다면, L15는 \\(\\mathbb{Z}_N\\) (산술) 그룹의 “숨겨진 주기” \\(L\\)을 찾는 문제입니다.\n\n\n\n함수: \\(F: \\mathbb{Z}_N \\to \\text{COLORS}\\) (즉, \\(n=\\log N\\) 큐비트를 입력받아 \\(m\\) 큐비트 “색깔”을 출력합니다.)\n오라클: \\(Q_F\\) (XOR 오라클) \\(U_F: |x\\rangle |y\\rangle \\mapsto |x\\rangle |y \\oplus F(x)\\rangle\\)에 접근할 수 있습니다.\n목표: \\(F\\)의 “주기” \\(L\\)을 효율적으로 (즉, 오라클 호출을 다항식 \\(O(poly(n))\\) 횟수만큼 사용하여) 찾는 것입니다.\n\n\n\n\n\n[주기성 약속 (L-periodic)] 숨겨진 “주기” \\(L\\)이 존재하여, 1. 모든 \\(x \\in \\mathbb{Z}_N\\)에 대해 \\(F(x) = F(x+L \\pmod N)\\)이 성립합니다. 2. 주기 내의 모든 값은 고유합니다. (즉, \\(F(x) = F(y) \\iff L | (y-x) \\pmod N\\))\n\n예시 (\\(L=4\\)): 함수 \\(F\\)는 \\(L\\)개의 고유한 “색깔” (R, G, B, Y)을 가지고, 이 패턴이 \\(N/L\\)번 반복됩니다. \\(F: (R, G, B, Y | R, G, B, Y | R, G, B, Y | \\dots)\\) \\(x: (0, 1, 2, 3 | 4, 5, 6, 7 | 8, 9, 10, 11 | \\dots)\\)\n\n\n\n알고리즘은 L12/L13에서 배운 “푸리에 샘플링” 패러다임을 그대로 따릅니다.\n\n[LOAD DATA]: \\(Q_F\\) 오라클을 사용하여 \\(F(x)\\)의 “주기성” 정보를 양자 상태의 진폭에 “로드”합니다.\n[FOURIER TRANSFORM]: \\(\\mathbb{Z}_2^n\\)의 BFT(\\(H^{\\otimes n}\\)) 대신, \\(\\mathbb{Z}_N\\)의 QFT (L14)를 적용합니다.\n[MEASURE]: 변환된 “주파수” 상태를 측정하여 \\(L\\)에 대한 “단서(clue)”를 얻습니다.\n\n\n\n\n\nL13(Simon)에서와 정확히 동일한 방식으로 “데이터”를 로드합니다.\n\n준비: \\(|0\\rangle^{\\otimes n} |0\\rangle^{\\otimes m}\\)\n[Rotate]: 입력 레지스터에 \\(H^{\\otimes n}\\)을 적용하여 균등 중첩을 만듭니다. ( \\(N=2^n\\) 가정) \\[\\left( \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle \\right) |0\\rangle^{\\otimes m}\\]\n[Compute]: \\(Q_F\\) (XOR 오라클)을 적용합니다. \\[|\\psi_1\\rangle = \\frac{1}{\\sqrt{N}} \\sum_{x=0}^{N-1} |x\\rangle |F(x)\\rangle\\]\n\n이 결과물 \\(|\\psi_1\\rangle\\)은 모든 입력 \\(|x\\rangle\\)와 그에 해당하는 “색깔” \\(|F(x)\\rangle\\)가 얽힌(entangled) 상태입니다.\n\n\n\n\n이 얽힌 상태 \\(|\\psi_1\\rangle\\)를 분석하기 위해, 출력 레지스터를 측정(Measure)한다고 “가정”합니다 (지연된 측정의 원리).\n\n측정: \\(m\\)-큐비트 출력 레지스터를 측정하면, “색깔” \\(C^*\\)가 관측됩니다.\n붕괴 (Collapse): \\(F(x) = C^*\\)를 만족하는 \\(x\\) 값들만 살아남습니다. \\(L|N\\)이라는 “이상적인” 가정 하에서, 이 \\(x\\) 값들은 정확히 \\(K = N/L\\)개 존재합니다. ( \\(x_0, x_0+L, x_0+2L, \\dots, x_0 + (K-1)L\\) )\n“신호” 상태: 출력 레지스터 \\(|C^*\\rangle\\)를 무시(discard)하고 나면, \\(n\\) 큐비트의 입력 레지스터는 다음과 같은 “신호” 상태가 됩니다. \\[|\\psi_{\\text{signal}}\\rangle = |\\psi_{x_0}\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{K-1} |x_0 + kL\\rangle\\]\n이것은 \\(x_0\\)라는 무작위 시작점(random offset)을 갖는 “펄스 열(pulse train)”입니다.\n\n\n\n\n\n\n\n\\(x_0\\)가 무작위 값이라는 것은 심각한 문제처럼 보입니다. 하지만 푸리에 이동 정리가 이 문제를 해결합니다.\n\n[Lemma] (Pleasing Fact!) “이동된” 신호 \\(|g_{x_0}\\rangle\\)의 QFT \\(|\\tilde{g}_{x_0}\\rangle\\)는, “이동 안 된” 신호(\\(x_0=0\\))의 QFT \\(|\\tilde{g}\\rangle\\)에 위상 항(phase term) \\(\\omega_N^{-s \\cdot x_0}\\)만 곱한 것입니다. \\[|\\tilde{g}_{x_0}\\rangle = \\sum_s \\left( \\tilde{g}(s) \\cdot \\omega_N^{-s \\cdot x_0} \\right) |s\\rangle\\]\n\n측정 확률 (The Punchline): 측정 확률은 진폭의 제곱 \\(P(s) = |\\tilde{g}_{x_0}(s)|^2 = |\\tilde{g}(s)|^2 \\cdot |\\omega_N^{-s \\cdot x_0}|^2\\) 입니다. \\(|\\omega_N^{-s \\cdot x_0}|^2 = 1\\) 이므로, \\(P(s) = |\\tilde{g}(s)|^2\\) 입니다.\n결론: 최종 측정 확률 분포는 무작위 오프셋 \\(x_0\\)와 완전히 독립적(independent)입니다. 따라서 \\(x_0=0\\)인 가장 간단한 경우만 분석하면 됩니다.\n\n\n\n\\(x_0=0\\)인 “신호” \\(|g_0\\rangle = \\sqrt{\\frac{L}{N}} \\sum_{k=0}^{K-1} |kL\\rangle\\) (주기 \\(L\\), 펄스 \\(K=N/L\\)개)의 QFT \\(|\\tilde{g}\\rangle = \\sum_s \\tilde{g}(s) |s\\rangle\\)를 계산합니다.\n\\(s\\)번째 진폭 \\(\\tilde{g}(s) = \\langle s | U_{\\text{QFT}} | g_0 \\rangle\\)는 공비 \\(r = \\omega_N^{-sL}\\)를 갖는 등비수열의 합입니다. \\[\\tilde{g}(s) = \\frac{\\sqrt{L}}{N} \\sum_{k=0}^{K-1} \\left( \\omega_N^{-sL} \\right)^k\\]\n\nCase 1: \\(s \\cdot L = 0 \\pmod N\\) ( \\(s\\)가 \\(K=N/L\\)의 배수)\n\n\\(r=1\\)이 되어 결맞는 간섭이 일어납니다.\n\\(\\tilde{g}(s) = \\frac{\\sqrt{L}}{N} \\cdot K = \\frac{\\sqrt{L}}{N} \\cdot \\frac{N}{L} = \\frac{1}{\\sqrt{L}}\\)\n\nCase 2: \\(s \\cdot L \\neq 0 \\pmod N\\) ( \\(s\\)가 \\(K\\)의 배수가 아님)\n\n\\(r \\neq 1\\)이지만 \\(r^K = (\\omega_N^{-sL})^{N/L} = (\\omega_N^{-N})^s = 1^s = 1\\) 입니다.\n등비수열 합 공식 \\(\\frac{1-r^K}{1-r} = \\frac{1-1}{1-r} = 0\\) 이므로 상쇄 간섭이 일어납니다.\n\\(\\tilde{g}(s) = 0\\)\n\n\n결론 (측정): QFT의 결과 \\(|\\psi_{\\text{final}}\\rangle\\)는 주기 \\(K=N/L\\)을 가진 또 다른 “펄스 열”입니다. \\[|\\psi_{\\text{final}}\\rangle = \\sum_{j=0}^{L-1} \\frac{1}{\\sqrt{L}} |j \\cdot K\\rangle \\quad (\\text{where } K = N/L)\\] 측정 시, 우리는 \\(\\mathbf{K=N/L}\\)의 배수 \\(s = j \\cdot (N/L)\\) ( \\(j\\)는 랜덤)를 확률 \\(1/L\\)로 얻습니다.\n\n\n\n\n\n\\(s = j \\cdot (N/L)\\) 라는 단서(\\(s/N = j/L\\))로부터 \\(L\\)을 어떻게 찾을까요?\n\n\\(H-Q_F-QFT \\to \\text{Measure}\\) 회로를 두 번 반복하여 \\(s_1, s_2\\)를 얻습니다 ( \\(s_i \\neq 0\\) 가정).\n\\(s_1 = j_1 (N/L)\\), \\(s_2 = j_2 (N/L)\\) 입니다.\n\\(K' = \\text{gcd}(s_1, s_2)\\)를 (고전적으로) 계산합니다.\n\\(K' = \\text{gcd}(j_1 K, j_2 K) = K \\cdot \\text{gcd}(j_1, j_2)\\)\n두 무작위 정수 \\(j_1, j_2\\)가 서로소(\\(\\text{gcd}(j_1, j_2)=1\\))일 확률은 \\(\\frac{6}{\\pi^2} \\approx 60.7\\%\\) (상수) 입니다.\n높은 확률로 \\(K' = K = N/L\\) 이므로, \\(L = N/K'\\)로 \\(L\\)을 복원합니다.\n총 비용: \\(O(1)\\) (상수) 횟수의 양자 호출과 \\(O(n^3)\\)의 고전 후처리(GCD)로, 다항식(polynomial) 시간에 \\(L\\)을 찾습니다.\n\n\n\n\n\nShor의 실제 문제에서는 \\(L\\)이 \\(N\\)을 나누지 않습니다 (\\(K=N/L\\)가 정수가 아님).\n\n입력 (Time): “신호” \\(|\\psi_{\\text{signal}}\\rangle\\)는 \\(M' = \\lfloor N/L \\rfloor\\) 또는 \\(\\lceil N/L \\rceil\\) 개의 펄스를 가진 “불완전한” 펄스 열입니다.\nQFT (Freq.): \\(|\\psi_{\\text{final}}\\rangle\\)는 완벽한 “펄스 열”이 아니라, “이상적인” 주파수(\\(s \\approx jN/L\\)) “근처(near)”에 확률이 “집중(peaked)”되는 “흐트러진(smeared)” 스펙트럼이 됩니다.\n증명 (Shor’s Lemma): 이 “불완전한” 펄스 열의 QFT를 수학적으로 분석하면(L15-3-2-1, L15-3-2-2-1, L15-3-2-2-2 개인 노트), \\(jN/L\\)에 “가장 가까운” 정수 \\(s = \\lfloor jN/L \\rceil\\)를 측정할 확률 \\(P(s)\\)가 최악의 경우에도 \\(4/\\pi^2 \\approx 0.405\\) 이상임이 보장됩니다 (단, 이는 \\(L\\)개 피크 중 하나에 대한 확률). \\[P(s = \\lfloor jN/L \\rceil) \\ge \\frac{4}{\\pi^2 L} \\approx \\frac{0.405}{L}\\]\n\n최종 결론 (Shor): \\(L \\nmid N\\)이라는 “현실적인” 경우에도, \\(H-Q_F-QFT\\)를 측정하면 \\(\\frac{s}{N} \\approx \\frac{j}{L}\\)를 만족하는 “좋은” \\(s\\)를 \\(O(n)\\)번의 반복으로 높은 확률로 샘플링할 수 있습니다.\n이 “나쁜” 근사 분수 \\(\\frac{s}{N}\\)로부터 \\(L\\)을 복원하기 위해, 연분수 알고리즘 (Continued Fractions Algorithm)이라는 강력한 고전 \\(O(n^3)\\) 후처리 기법을 사용합니다.\n총 비용: \\(O(n \\log n)\\) (근사 QFT) \\(\\times\\) \\(O(n)\\) (반복) + \\(O(n^3)\\) (연분수) \\(\\implies\\) 총 다항식(polynomial) 시간"
  },
  {
    "objectID": "posts/cs/compiler/4-toolkit/index.html",
    "href": "posts/cs/compiler/4-toolkit/index.html",
    "title": "컴파일러 백엔드 시리즈 4부(부록): 컴파일러 툴킷",
    "section": "",
    "text": "1부에서 3부까지 우리는 CFG 생성, SSA 변환, 최적화, 그리고 SSA 해제로 이어지는 컴파일러 백엔드의 핵심 파이프라인을 구축했습니다.\n이번 4부(부록)에서는 이 파이프라인을 직접 구성하지는 않지만, 그 기반이 되는 핵심 이론 프레임워크와 프로젝트를 보조하는 유용한 툴킷 파일들을 살펴봅니다."
  },
  {
    "objectID": "posts/cs/compiler/4-toolkit/index.html#심화-학습-일반적인-데이터-흐름-분석dataflow-analysis-프레임워크",
    "href": "posts/cs/compiler/4-toolkit/index.html#심화-학습-일반적인-데이터-흐름-분석dataflow-analysis-프레임워크",
    "title": "컴파일러 백엔드 시리즈 4부(부록): 컴파일러 툴킷",
    "section": "10. 심화 학습: 일반적인 데이터 흐름 분석(Dataflow Analysis) 프레임워크",
    "text": "10. 심화 학습: 일반적인 데이터 흐름 분석(Dataflow Analysis) 프레임워크\n2부의 dom.py에서 지배자(Dominator)를 계산하기 위해 ‘반복적 데이터 흐름 분석’ 알고리즘을 사용했던 것을 기억하시나요? dom.py가 ’지배자 분석’이라는 특정한(specific) 목적을 위해 하드코딩된 구현체였다면, df.py는 한발 더 나아가 어떤 종류의 데이터 흐름 분석이든 수행할 수 있도록 일반화시킨 강력한 프레임워크입니다.\n\n데이터 흐름 분석이란? CFG를 따라 프로그램의 상태 값(예: “이 변수가 상수인가?”, “이 변수가 나중에 사용되는가?”)이 어떻게 전파되는지 계산하는 정적 분석 기법입니다. 이 분석은 “고정점(fixed-point)”에 도달할 때까지, 즉 더 이상 정보가 갱신되지 않을 때까지 반복적으로 수행됩니다.\n\ndf.py는 특정 분석에 종속되지 않고, Analysis라는 명세만 넘겨주면 알아서 고정점을 찾아주는 범용 워크리스트 알고리즘(Worklist Algorithm)을 제공합니다.\n\n1. ‘Analysis’ 추상화\n이 프레임워크의 핵심은 Analysis 네임드튜플(namedtuple)입니다. 어떤 데이터 흐름 분석이든 다음 네 가지 요소로 정의할 수 있다는 아이디어에 기반합니다.\nAnalysis = namedtuple('Analysis', ['forward', 'init', 'merge', 'transfer'])\n\nforward (방향): True이면 순방향(Forward) 분석 (진입 \\(\\rightarrow\\) 종료), False이면 역방향(Backward) 분석 (종료 \\(\\rightarrow\\) 진입)을 수행합니다.\ninit (초기값): 각 블록의 in 또는 out 상태가 처음 시작할 때 가지는 값입니다. (Lattice의 \\(\\top\\) 또는 \\(\\bot\\) 원소)\nmerge (병합 함수): 여러 경로가 합쳐지는 지점(예: if문 다음 블록)에서 각 경로의 상태 값을 어떻게 합칠 것인지 정의합니다. (Meet 연산자 \\(\\cap\\) 또는 \\(\\cup\\))\ntransfer (전달 함수): 특정 블록을 통과할 때, 블록의 in 상태가 어떻게 out 상태로 변환되는지 정의합니다. ( \\(f(x)\\) )\n\n\n\n2. df_worklist 알고리즘\n이 함수가 바로 데이터 흐름 분석 엔진입니다. 모든 블록을 무작정 반복하는 대신, 상태 값에 변경이 생긴 블록의 후임자(또는 전임자)만을 worklist라는 큐에 넣어 효율적으로 고정점을 찾습니다.\ndef df_worklist(blocks, analysis):\n    # ... ( preds, succs 계산, 방향 설정 ) ...\n    \n    # 1. 초기화\n    in_ = {first_block: analysis.init}\n    out = {node: analysis.init for node in blocks}\n    \n    worklist = list(blocks.keys())\n    while worklist:\n        node = worklist.pop(0)\n\n        # 2. Merge: 모든 전임자(predecessor)들의 out 값을 병합\n        inval = analysis.merge(out[n] for n in in_edges[node])\n        in_[node] = inval\n\n        # 3. Transfer: 블록을 통과시키며 out 값을 계산\n        outval = analysis.transfer(blocks[node], inval)\n\n        # 4. 고정점 확인: out 값이 변경되었는지 확인\n        if outval != out[node]:\n            out[node] = outval\n            # 변경되었다면, 이 노드의 후임자(successor)들을 worklist에 추가\n            worklist += out_edges[node]\n            \n    # ... (결과 반환) ...\ndef normalize():\n    # ... (CSV 읽기) ...\n\n    # 1. Get normalization baselines.\n    baselines = {\n        row['benchmark']: int(row['result'])\n        for row in in_data\n        if row['run'] == 'baseline'\n    }\n\n    # 2. Write output CSV back out.\n    # ... (writer 생성) ...\n    ratios = defaultdict(list)\n    for row in in_data:\n        # 3. Calculate ratio against baseline\n        ratio = int(row['result']) / baselines[row['benchmark']]\n        ratios[row['run']].append(ratio)\n        row['result'] = ratio\n        writer.writerow(row)\n\n    # 4. Print stats.\n    for run, rs in ratios.items():\n        for name, func in STATS.items():\n            print(\n                '{}({}) = {:.2f}'.format(name, run, func(rs)),\n                file=sys.stderr,\n            )\n\n\n3. 구현된 분석 예제\ndf.py는 이 프레임워크를 사용한 두 가지 고전적인 분석을 예제로 제공합니다.\n\n1. ‘live’: 활성 변수 분석 (Live Variable Analysis)\n\n목적: 어떤 변수가 “활성(live)” 상태인지, 즉 “현재 지점에서 정의된 값이 미래에 사용될 가능성이 있는지”를 파악합니다. (주로 레지스터 할당, 정교한 죽은 코드 제거에 사용됩니다.)\n특징: 역방향(Backward) 분석입니다 (forward: False). 프로그램의 끝에서부터 거꾸로 분석을 수행합니다.\n전달 함수: \\(LiveIn(n) = Use(n) \\cup (LiveOut(n) - Gen(n))\\)\n\n\\(Use(n)\\): 이 블록에서 (정의되기 전에) 사용되는 변수.\n\\(Gen(n)\\): 이 블록에서 정의되는(덮어쓰이는) 변수.\n\n\n\n\n2. ‘cprop’: 상수 전파 (Constant Propagation)\n\n목적: “어떤 변수가 항상 특정 상수 값을 가지는가?”를 파악합니다.\n특징: 순방향(Forward) 분석입니다 (forward: True).\n상태 값: { 'v': 5, 'x': '?', 'z': 10 }\n\n5: 이 지점에서 v는 항상 5입니다.\n'?': 이 지점에서 x는 상수가 아니거나, 여러 경로에서 온 상수 값이 다릅니다 (Lattice의 \\(\\top\\)).\n\nMerge 함수 (cprop_merge):\n\nmerge({v: 5}, {v: 5}) \\(\\rightarrow\\) {v: 5}\nmerge({v: 5}, {v: 7}) \\(\\rightarrow\\) {v: '?'}"
  },
  {
    "objectID": "posts/cs/compiler/4-toolkit/index.html#최적화-성능-측정-normalize.py",
    "href": "posts/cs/compiler/4-toolkit/index.html#최적화-성능-측정-normalize.py",
    "title": "컴파일러 백엔드 시리즈 4부(부록): 컴파일러 툴킷",
    "section": "11. 최적화 성능 측정 (normalize.py)",
    "text": "11. 최적화 성능 측정 (normalize.py)\n3부에서 lvn.py (중복 연산 제거)와 tdce.py (죽은 코드 제거) 같은 최적화 패스를 구현했습니다. 그렇다면 이 최적화들이 과연 “얼마나” 코드를 향상시켰을까요?\n이를 확인하려면 벤치마킹(Benchmarking)이 필요합니다. normalize.py는 이 벤치마킹 결과를 처리해주는 유틸리티입니다.\n\nnormalize.py는 각 벤치마크의 여러 실행 결과(예: 총 명령어 수)가 담긴 CSV 파일을 입력받습니다.\n\n\nnormalize.py 핵심 로직 분석\n이 스크립트의 목적은 “절대적인 명령어 수” (예: 150개)를 “상대적인 성능 비율” (예: 0.85배)로 변환하는 것입니다.\n\nCSV 읽기: 벤치마킹 결과 CSV를 읽습니다. (예상 형식: benchmark, run, result)\n‘baseline’ 찾기: run == 'baseline'인 행을 찾아, 각 벤치마크의 기준 성능(baselines[...] = int(row['result']))을 맵에 저장합니다.\n정규화(Normalize):\n\nCSV를 다시 순회하며 각 행(row)의 result를 baseline의 result로 나눕니다.\nratio = int(row['result']) / baselines[row['benchmark']]\n(예: lvn_run의 result가 85, baseline이 100이었다면 ratio = 0.85)\n\n통계 출력:\n\n각 run (예: lvn_only)별로 모든 ratio의 기하 평균(geometric_mean)을 계산하여 출력합니다.\n\n\ndef normalize():\n    # ... (CSV 읽기) ...\n\n    # 1. Get normalization baselines.\n    baselines = {\n        row['benchmark']: int(row['result'])\n        for row in in_data\n        if row['run'] == 'baseline'\n    }\n\n    # 2. Write output CSV back out.\n    # ... (writer 생성) ...\n    ratios = defaultdict(list)\n    for row in in_data:\n        # 3. Calculate ratio against baseline\n        ratio = int(row['result']) / baselines[row['benchmark']]\n        ratios[row['run']].append(ratio)\n        row['result'] = ratio\n        writer.writerow(row)\n\n    # 4. Print stats.\n    for run, rs in ratios.items():\n        for name, func in STATS.items():\n            print(\n                '{}({}) = {:.2f}'.format(name, run, func(rs)),\n                file=sys.stderr,\n            )\n\n이 스크립트를 통해 “LVN 최적화를 켰더니, 기준(baseline) 대비 명령어 수가 평균 85% 수준(기하 평균 0.85)이 되었다”와 같은 정량적인 결론을 내릴 수 있습니다."
  },
  {
    "objectID": "posts/cs/compiler/4-toolkit/index.html#공통-유틸리티-함수-util.py",
    "href": "posts/cs/compiler/4-toolkit/index.html#공통-유틸리티-함수-util.py",
    "title": "컴파일러 백엔드 시리즈 4부(부록): 컴파일러 툴킷",
    "section": "12. 공통 유틸리티 함수 (util.py)",
    "text": "12. 공통 유틸리티 함수 (util.py)\n파이프라인 전반에 걸쳐 사용된 몇 가지 편의 함수들이 util.py에 정의되어 있습니다.\n\n1. flatten(ll)\nreassemble 함수 등에서 여러 기본 블록(리스트의 리스트)을 다시 하나의 긴 명령어 리스트로 합칠 때 사용됩니다.\nimport itertools\n\ndef flatten(ll):\n    \"\"\"Flatten an iterable of iterable to a single list.\n    \"\"\"\n    return list(itertools.chain(*ll))\n\n\n2. fresh(seed, names)\ncfg.py의 block_map 함수에서 레이블이 없는 익명 블록(anonymous block)에 b1, b2와 같이 고유한 이름을 붙여줄 때 사용됩니다.\ndef fresh(seed, names):\n    \"\"\"Generate a new name that is not in `names` starting with `seed.\n    \"\"\"\n    i = 1\n    while True:\n        name = seed + str(i)\n        if name not in names:\n            return name\n        i += 1"
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html",
    "href": "posts/cs/compiler/2-ssa/index.html",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "",
    "text": "1부에서는 Bril 코드를 기본 블록으로 나누어 제어 흐름 그래프(CFG)를 구축했습니다. CFG가 “어디로 갈 수 있는가”에 대한 흐름을 보여준다면, 2부에서는 “어떤 노드를 실행하기 위해 반드시 먼저 거쳐야 하는 노드가 무엇인가”에 대한 구조를 분석합니다.\n이것이 바로 지배자(Dominator) 분석이며, SSA 폼 변환의 심장부입니다."
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html#지배자-분석-반드시-거치는-길-찾기",
    "href": "posts/cs/compiler/2-ssa/index.html#지배자-분석-반드시-거치는-길-찾기",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "4. 지배자 분석: “반드시 거치는 길” 찾기",
    "text": "4. 지배자 분석: “반드시 거치는 길” 찾기\n\n지배 (Dominance)란? CFG에서 노드 \\(A\\)가 노드 \\(B\\)를 지배(dominates)한다는 것은, 프로그램의 진입(entry) 노드에서 \\(B\\)로 가는 모든 경로가 반드시 \\(A\\)를 거쳐야 함을 의미합니다. (이때 \\(A\\)는 \\(B\\) 자신일 수도 있습니다.) * \\(LaTeX\\) 표기: \\(A \\text{ dom } B\\) * 직관적 의미: \\(B\\)를 실행했다면, 그전에 \\(A\\)는 무조건 실행되었음이 보장된다. * 예시: 루프(loop)의 헤더(header) 블록은 루프 본체(body)의 모든 블록을 지배합니다.\n\ndom.py 스크립트는 이 지배 관계를 계산하고, 이를 바탕으로 SSA 변환에 필수적인 두 가지 핵심 자료구조를 구축합니다.\n\n지배자 (Dominators) / get_dom: 각 노드 \\(n\\)에 대해, \\(n\\)을 지배하는 모든 노드의 집합 \\(Dom(n)\\)을 계산합니다.\n지배 경계 (Dominance Frontier) / dom_fronts: \\(\\phi\\) 함수를 어디에 삽입할지 알려주는 핵심 정보입니다.\n\n\n1. 지배자 관계 계산 (get_dom)\nget_dom 함수는 고전적인 반복적 데이터 흐름 분석(iterative data-flow analysis) 알고リズム을 사용하여 지배자 집합 \\(Dom(n)\\)을 계산합니다.\n이 알고리즘은 다음의 재귀적인 정의에 기반합니다. \\[Dom(n) = \\{n\\} \\cup \\left( \\bigcap_{p \\in \\text{pred}(n)} Dom(p) \\right)\\]\n\n\\(Dom(n)\\): 노드 \\(n\\)의 지배자 집합\n\\(\\text{pred}(n)\\): 노드 \\(n\\)의 모든 전임자(predecessor) 노드 집합\n(예외: 진입 노드 \\(n_0\\)의 경우 \\(Dom(n_0) = \\{n_0\\}\\) 입니다.)\n\n\n코드 해설\nget_dom 함수는 이 수식을 ’고정점(fixed-point)’에 도달할 때까지 반복 계산합니다.\ndef get_dom(succ, entry):\n    pred = map_inv(succ)\n    # 1. RPO(Reverse Postorder)로 노드 순회 순서 결정 (빠른 수렴을 위함)\n    nodes = list(reversed(postorder(succ, entry))) \n\n    # 2. 초기화: Dom(n) = {모든 노드} (데이터 흐름 분석의 'Top' 원소)\n    dom = {v: set(nodes) for v in succ}\n    # 진입 노드의 Dom(entry)는 {entry}여야 하지만,\n    # 아래 루프의 첫 번째 반복에서 자동으로 그렇게 설정됩니다.\n\n    while True:\n        changed = False\n\n        # 3. 모든 노드를 RPO 순서로 순회\n        for node in nodes:\n            # 4. Meet 연산: pred(node)의 Dom 집합들의 교집합(intersection) 계산\n            new_dom = intersect(dom[p] for p in pred[node])\n            # 5. Transfer 함수: {n}을 추가\n            new_dom.add(node)\n\n            # 6. 수렴(Convergence) 확인\n            if dom[node] != new_dom:\n                dom[node] = new_dom\n                changed = True\n\n        if not changed:\n            break  # 고정점에 도달하면(더 이상 변경이 없으면) 종료\n\n    return dom"
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html#지배자-트리-dominator-tree",
    "href": "posts/cs/compiler/2-ssa/index.html#지배자-트리-dominator-tree",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "2. 지배자 트리 (Dominator Tree)",
    "text": "2. 지배자 트리 (Dominator Tree)\nget_dom이 계산한 \\(Dom(n)\\)은 모든 지배자 집합입니다. 하지만 이 관계는 ‘트리’ 구조로 단순화할 수 있습니다.\n\n즉시 지배자 (Immediate Dominator, idom)\n노드 \\(B\\)를 지배하는 노드 \\(A\\)가 \\(B\\)의 즉시 지배자라는 것은, \\(A\\)와 \\(B\\) 사이에 \\(A\\)를 지배하면서 \\(B\\)를 지배하는 다른 노드가 존재하지 않는다는 의미입니다. (즉, \\(A\\)가 \\(B\\)로 가는 길의 ‘마지막’ 지배자입니다.)\n\n진입 노드를 제외한 모든 노드는 유일한(unique) 즉시 지배자를 가집니다.\n\n이 idom 관계를 모아 그린 것이 지배자 트리(Dominator Tree)입니다. CFG가 복잡한 그래프일지라도, 지배자 트리는 항상 단순한 트리 구조가 됩니다. dom_tree 함수는 get_dom의 결과를 바탕으로 이 idom 관계(부모-자식 관계)를 계산합니다."
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html#지배-경계-dominance-frontier",
    "href": "posts/cs/compiler/2-ssa/index.html#지배-경계-dominance-frontier",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "3. 지배 경계 (Dominance Frontier)",
    "text": "3. 지배 경계 (Dominance Frontier)\n드디어 SSA 변환의 가장 핵심적인 개념인 지배 경계(Dominance Frontier)입니다.\n\n지배 경계 (Dominance Frontier, DF) 란?\n노드 \\(A\\)의 지배 경계 \\(DF(A)\\)는, \\(A\\)가 지배하는 노드(\\(A\\) 자신 포함)의 후임자이면서, \\(A\\)가 엄격하게(strictly) 지배하지는 않는 노드들의 집합입니다.\n\n엄격한 지배(Strict Dominance): \\(A \\text{ dom } B\\) 이고 \\(A \\ne B\\) 인 경우.\n직관적 의미: 변수의 영향력이 \\(A\\)의 ’지배 영역’을 벗어나 처음으로 도달하는 합류 지점(join point)입니다.\n\n\n이것이 왜 중요할까요?\n어떤 블록 \\(A\\)에서 변수 \\(x\\)에 새로운 값이 할당(정의)되었다고 가정해봅시다. 이 \\(x\\)의 값은 \\(A\\)가 지배하는 모든 블록에서 유효합니다. 하지만 \\(A\\)의 ’지배 영역’을 벗어나는 순간(즉, \\(DF(A)\\)에 속하는 블록), 다른 경로에서 온 \\(x\\)의 값과 합쳐져야 합니다.\n따라서 \\(DF(A)\\)는 \\(\\phi\\) (phi) 함수가 삽입되어야 할 위치를 정확히 알려줍니다.\n\n코드 해설 (dom_fronts)\ndom_fronts 함수는 이 정의를 코드로 정확하게 구현합니다.\ndef dom_fronts(dom, succ):\n    \"\"\"Compute the dominance frontier, given the dominance relation.\n    \"\"\"\n    # dom_inv[A] = A가 지배하는 모든 노드 집합\n    dom_inv = map_inv(dom)\n\n    frontiers = {}\n    for block in dom:  # 모든 노드 A (block)에 대해\n        # Find all successors of dominated blocks.\n        dominated_succs = set()\n        # 1. A가 지배하는 모든 노드(dominated)를 찾고,\n        for dominated in dom_inv[block]:\n            # 2. 그 노드들의 모든 후임자(successors)를 찾는다.\n            dominated_succs.update(succ[dominated])\n\n        # 3. 이 후임자(b)들 중에서,\n        #    A가 '엄격하게' 지배하지 않는 노드만 필터링한다.\n        frontiers[block] = [b for b in dominated_succs\n                            if b not in dom_inv[block] or b == block]\n\n    return frontiers"
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html#ssa-폼-변환-phi-함수와-변수-이름-변경",
    "href": "posts/cs/compiler/2-ssa/index.html#ssa-폼-변환-phi-함수와-변수-이름-변경",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "5. SSA 폼 변환: \\(\\phi\\) 함수와 변수 이름 변경",
    "text": "5. SSA 폼 변환: \\(\\phi\\) 함수와 변수 이름 변경\n이제 우리는 CFG, 지배자 트리, 그리고 지배 경계라는 재료를 모두 확보했습니다. 이 재료들을 사용해 IR을 SSA (Static Single Assignment) 폼으로 변환할 차례입니다.\n\nSSA (Static Single Assignment)란? 모든 변수(variable)가 프로그램 텍스트 상에서 단 한 번만 할당(assignment)되도록 보장하는 IR의 한 형태입니다. * 예시: x = 1; x = x + 1; * SSA 변환: x.0 = 1; x.1 = add x.0 1;\n\n이 “단일 할당” 속성 덕분에, 변수의 ‘정의(definition)’와 ’사용(use)’ 관계가 매우 명확해져, 다양한 최적화를 강력하고 효율적으로 만듭니다.\n이 변환은 두 단계 알고리즘으로 수행됩니다.\n\n\\(\\phi\\) 함수 삽입: 지배 경계(DF)를 이용해 \\(\\phi\\) 함수가 필요한 위치를 찾습니다.\n변수 이름 변경 (Renaming): 지배자 트리(Dominator Tree)를 순회하며 모든 변수의 정의와 사용을 x.0, x.1 등으로 다시 명명합니다.\n\n\n1단계: \\(\\phi\\) 함수 위치 선정 (get_phis)\nget_phis 함수는 dom_fronts가 계산한 지배 경계를 사용해 \\(\\phi\\) 함수가 필요한 위치를 찾습니다.\n\n\\(v\\)에 대한 정의가 블록 \\(D\\)에서 발생할 때, \\(DF(D)\\)에 속하는 모든 블록은 \\(v\\)에 대한 \\(\\phi\\) 함수가 필요할 수 있는 ’합류 지점’입니다.\nget_phis는 이 과정을 \\(\\phi\\) 함수 자신이 또 다른 정의가 되는 것까지 고려하여, 새로운 \\(\\phi\\) 함수가 더 이상 추가되지 않을 때까지 반복적으로(Iterated Dominance Frontier) 수행합니다.\n\ndef get_phis(blocks, df, defs):\n    \"\"\"Find where to insert phi-nodes in the blocks.\n    ...\n    \"\"\"\n    phis = {b: set() for b in blocks}\n    for v, v_defs in defs.items():\n        v_defs_list = list(v_defs)  # W = 리스트 (워크리스트)\n        for d in v_defs_list:  # W에서 하나씩 꺼내는 동안 (W가 증가 가능)\n            for block in df[d]:  # d의 지배 경계에 속하는 모든 블록\n                if v not in phis[block]:\n                    # 이 블록에 v에 대한 phi 함수가 필요하다고 표시\n                    phis[block].add(v)\n                    # phi 함수 자체가 새로운 정의이므로,\n                    # 이 블록(block)도 워크리스트에 추가\n                    if block not in v_defs_list:\n                        v_defs_list.append(block)\n    return phis\n\n\n2단계: 변수 이름 변경 (ssa_rename)\nssa_rename 함수는 지배자 트리를 전위 순회(pre-order traversal)하는 재귀 알고리즘을 사용해 실제 변수 이름을 v.0, v.1 등으로 변경합니다.\n\n각 변수명(예: ‘x’)마다, 현재 유효한 이름(예: ‘x.3’)을 저장하는 스택을 유지합니다.\n지배자 트리를 순회하는 이유: 트리를 따라 내려갈 때(즉, \\(A\\)에서 \\(A\\)가 지배하는 \\(B\\)로 이동할 때), 부모(\\(A\\))에서 정의된 변수 버전이 자식(\\(B\\))에서도 유효함이 보장됩니다.\n\n_rename(block) 함수의 핵심 로직은 다음과 같습니다.\n\n스택 백업: 현재 스택 상태를 old_stack에 저장합니다.\n\\(\\phi\\) 함수 정의: 현재 블록의 \\(\\phi\\) 함수 목적지(dest) 이름을 새로 만듭니다(예: x.4). 이 새 이름을 스택에 푸시합니다.\n일반 명령어 순회:\n\n사용(args): 명령어의 인자는 스택의 맨 위(stack[arg][0]) 이름으로 교체합니다.\n정의(dest): 명령어의 목적지(dest)는 새 이름을 만들고(예: v.1), 스택에 푸시합니다.\n\n후임자(\\(\\phi\\)) 인자 채우기: CFG의 후임자(successor) 블록에 있는 \\(\\phi\\) 함수의 인자를 현재 스택의 맨 위 이름으로 채워줍니다.\n재귀 호출: 지배자 트리의 자식(child)에 대해 _rename(b)를 재귀 호출합니다.\n스택 복원: old_stack을 사용해 스택을 재귀 호출 이전 상태로 되돌립니다. (형제 노드에게 영향을 주지 않기 위함)\n\ndef ssa_rename(blocks, phis, succ, domtree, args):\n    stack = defaultdict(list, {v: [v] for v in args}) # var -&gt; [v.2, v.1, v.0]\n    # ... (phi_args, phi_dests, counters 초기화) ...\n\n    def _push_fresh(var):\n        fresh = '{}.{}'.format(var, counters[var])\n        counters[var] += 1\n        stack[var].insert(0, fresh)\n        return fresh\n\n    def _rename(block):\n        # 1. 스택 상태 저장\n        old_stack = {k: list(v) for k, v in stack.items()}\n\n        # 2. 이 블록의 phi-node 목적지(dest) 이름 변경\n        for p in phis[block]:\n            phi_dests[block][p] = _push_fresh(p)\n\n        # 3. 일반 명령어 순회 (사용 -&gt; 정의 순)\n        for instr in blocks[block]:\n            if 'args' in instr:\n                instr['args'] = [stack[arg][0] for arg in instr['args']]\n            if 'dest' in instr:\n                instr['dest'] = _push_fresh(instr['dest'])\n\n        # 4. 후임자(successor) 블록의 phi-node 인자(arg) 채우기\n        for s in succ[block]:\n            for p in phis[s]:\n                if stack[p]:\n                    phi_args[s][p].append((block, stack[p][0]))\n                # ... (undefined 처리) ...\n\n        # 5. 지배자 트리의 자식 노드 재귀 방문\n        for b in sorted(domtree[block]):\n            _rename(b)\n\n        # 6. 이 블록에서 정의한 이름들을 스택에서 팝 (상태 복원)\n        stack.clear()\n        stack.update(old_stack)\n\n    entry = list(blocks.keys())[0]\n    _rename(entry)\n    # ... (결과 반환) ..."
  },
  {
    "objectID": "posts/cs/compiler/2-ssa/index.html#ssa-폼-검증하기-is_ssa",
    "href": "posts/cs/compiler/2-ssa/index.html#ssa-폼-검증하기-is_ssa",
    "title": "컴파일러 백엔드 시리즈 2부: SSA 폼 변환과 지배자 트리",
    "section": "6. SSA 폼 검증하기 (is_ssa)",
    "text": "6. SSA 폼 검증하기 (is_ssa)\nto_ssa.py의 변환은 매우 복잡합니다. 이 변환이 성공했는지, 그 결과물이 SSA의 핵심 속성을 만족하는지 어떻게 보장할 수 있을까요? is_ssa.py 스크립트는 이 변환을 검증하는 간단한 유틸리티입니다.\n\nSSA의 핵심 정의: 모든 변수는 함수 내의 텍스트에서 단 한 번만 할당(정의)되어야 합니다.\n\nis_ssa 함수는 assigned라는 집합(set)을 사용해, 함수 전체를 선형 스캔하며 ‘dest’ 키를 가진 변수명이 이미 assigned 집합에 있는지(즉, 중복 정의되었는지) 검사합니다.\ndef is_ssa(bril):\n    \"\"\"Check whether a Bril program is in SSA form.\n    \"\"\"\n    for func in bril['functions']:\n        assigned = set()\n        for instr in func['instrs']:\n            if 'dest' in instr:\n                if instr['dest'] in assigned:\n                    # This variable was already assigned to. Not SSA.\n                    return False\n                else:\n                    # This is the first assignment. Record it.\n                    assigned.add(instr['dest'])\n    # No variable was assigned to more than once.\n    return True"
  }
]